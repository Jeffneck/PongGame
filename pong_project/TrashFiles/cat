# game/admin.py

from django.contrib import admin
from .models import GameSession, GameResult, GameParameters, GameInvitation

@admin.register(GameSession)
class GameSessionAdmin(admin.ModelAdmin):
    list_display = ('id', 'player_left', 'player_right', 'status', 'created_at')

@admin.register(GameResult)
class GameResultAdmin(admin.ModelAdmin):
    list_display = ('game', 'winner', 'score_left', 'score_right', 'ended_at')

@admin.register(GameParameters)
class GameParametersAdmin(admin.ModelAdmin):
    list_display = ('game_session', 'ball_speed', 'paddle_size', 'bonus_enabled', 'obstacles_enabled')

@admin.register(GameInvitation)
class GameInvitationAdmin(admin.ModelAdmin):
    list_display = ('from_user', 'to_user', 'status', 'created_at')
from django.apps import AppConfig


class GameConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'game'
# game/consumers.py

import json
import redis
from django.conf import settings
from channels.generic.websocket import AsyncWebsocketConsumer

r = redis.Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=0
)

class PongConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.game_id = self.scope['url_route']['kwargs']['game_id']
        self.group_name = f"pong_{self.game_id}"

        await self.accept()
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket connected for game_id={self.game_id}")

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket disconnected for game_id={self.game_id}")

    async def receive(self, text_data=None, bytes_data=None):
        """
        Nouveau protocole:
        {
          "action": "start_move",
          "player": "left",
          "direction": "up"
        }
        ou
        {
          "action": "stop_move",
          "player": "left"
        }
        """
        data = json.loads(text_data)
        action = data.get('action')
        player = data.get('player')

        if action == 'start_move':
            # Le joueur commence à bouger le paddle
            direction = data.get('direction')  # 'up' ou 'down'
            await self.start_move_paddle(player, direction)

        elif action == 'stop_move':
            # Le joueur arrête de bouger le paddle
            await self.stop_move_paddle(player)

    async def start_move_paddle(self, player, direction):
        """
        Met une vélocité non nulle dans Redis tant que la touche est enfoncée.
        """
        velocity = 0
        if direction == 'up':
            velocity = -8  # Ajustez la vitesse selon vos préférences
        elif direction == 'down':
            velocity = 8

        r.set(f"{self.game_id}:paddle_{player}_velocity", velocity)
        print(f"[PongConsumer] start_move_paddle: player={player}, velocity={velocity}")

    async def stop_move_paddle(self, player):
        """
        Remet la vélocité à 0 quand la touche est relâchée.
        """
        r.set(f"{self.game_id}:paddle_{player}_velocity", 0)
        print(f"[PongConsumer] stop_move_paddle: player={player}")

    async def broadcast_game_state(self, event):
        """
        Reçoit { 'type': 'broadcast_game_state', 'data': { ... } }
        et envoie data au client.
        """
        await self.send(json.dumps(event['data']))
        # print(f"[PongConsumer] Broadcast game_state to game_id={self.game_id}")

    async def game_over(self, event):
        """
        Reçoit { 'type': 'game_over', 'winner': 'left' } par ex.
        """
        await self.send(json.dumps({
            'type': 'game_over',
            'winner': event['winner']
        }))
        print(f"[PongConsumer] Broadcast game_over to game_id={self.game_id}, winner={event['winner']}")

    async def powerup_applied(self, event):
        """
        Reçoit { 'type': 'powerup_applied', 'player': 'left', 'effect': 'flash' }
        """
        await self.send(json.dumps({
            'type': 'powerup_applied',
            'player': event['player'],
            'effect': event['effect']
        }))
        print(f"[PongConsumer] Broadcast powerup_applied to game_id={self.game_id}, player={event['player']}, effect={event['effect']}")
# game/forms.py

from django import forms
from .models import GameParameters

class GameParametersForm(forms.ModelForm):
    class Meta:
        model = GameParameters
        fields = ['ball_speed', 'paddle_size', 'bonus_enabled', 'obstacles_enabled']
        widgets = {
            'ball_speed': forms.Select(attrs={'class': 'form-control'}),
            'paddle_size': forms.Select(attrs={'class': 'form-control'}),
            'bonus_enabled': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            'obstacles_enabled': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }
        labels = {
            'ball_speed': 'Vitesse de la balle',
            'paddle_size': 'Taille de la raquette',
            'bonus_enabled': 'Activer les bonus/malus',
            'obstacles_enabled': 'Activer les bumpers/obstacles',
        }
# game/game_loop.py

import redis
import asyncio
from django.conf import settings
from channels.layers import get_channel_layer
from .models import GameSession, GameResult, GameParameters
from .game_objects import Paddle, Ball, PowerUpOrb, Bumper
from asgiref.sync import sync_to_async
import math
import random
import time

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

FIELD_WIDTH = 800
FIELD_HEIGHT = 400
WIN_SCORE = 4

# collision avec les bumpers
COOLDOWN_TIME = 0.5  # Temps en secondes

# Initialize paddles and ball
async def initialize_game_objects(game_id, parameters):
    paddle_size = {1: 30, 2: 60, 3: 90}[parameters.paddle_size]
    paddle_speed = 6  # Can be made adjustable if needed
    ball_speed_multiplier = parameters.ball_speed

    # Obtenir les dimensions du terrain
    terrain_rect = await get_terrain_rect(game_id)

    # Initialize paddles
    paddle_left = Paddle('left', paddle_size, paddle_speed)
    paddle_right = Paddle('right', paddle_size, paddle_speed)

    # Initialize ball
    initial_ball_speed_x = 4 * ball_speed_multiplier
    initial_ball_speed_y = 4 * ball_speed_multiplier
    ball = Ball(
        terrain_rect['left'] + terrain_rect['width'] // 2,
        terrain_rect['top'] + terrain_rect['height'] // 2,
        initial_ball_speed_x,
        initial_ball_speed_y
    )

    # Initialize power-ups and bumpers
    powerup_orbs = [
        PowerUpOrb(game_id, 'invert', terrain_rect, color=(255, 105, 180)),  # Pink for invert
        PowerUpOrb(game_id, 'shrink', terrain_rect, color=(255, 0, 0)),      # Red for shrink
        PowerUpOrb(game_id, 'ice', terrain_rect, color=(0, 255, 255)),       # Cyan for ice
        PowerUpOrb(game_id, 'speed', terrain_rect, color=(255, 215, 0)),     # Gold for speed
        PowerUpOrb(game_id, 'flash', terrain_rect, color=(255, 255, 0)),     # Yellow for flash
        PowerUpOrb(game_id, 'sticky', terrain_rect, color=(50, 205, 50))     # Lime green for sticky
    ]

    bumpers = []
    if parameters.obstacles_enabled:
        bumpers = [Bumper(game_id, terrain_rect) for _ in range(3)]  # Adjust number as needed

    return paddle_left, paddle_right, ball, powerup_orbs, bumpers

async def get_terrain_rect(game_id):
    """
    Retourne les dimensions du terrain. Peut être ajusté pour récupérer les dimensions dynamiquement.
    """
    return {
        'left': 50,
        'top': 50,
        'width': 700,
        'height': 300
    }

async def game_loop(game_id):
    """
    Boucle principale pour UNE partie identifiée par game_id.
    Tourne ~60 fois/s tant que la partie est "running".
    """
    channel_layer = get_channel_layer()
    dt = 1/60
    print(f"[game_loop.py] Starting loop for game_id={game_id}.")

    try:
        # Récupérer les paramètres du jeu
        parameters = await get_game_parameters(game_id)
        if not parameters:
            print(f"[game_loop.py] No parameters found for game_id={game_id}. Using defaults.")
            parameters = await sync_to_async(GameParameters.objects.create)(
                game_session=await sync_to_async(GameSession.objects.get)(pk=game_id)
            )
        
        # Initialiser les objets de jeu
        paddle_left, paddle_right, ball, powerup_orbs, bumpers = await initialize_game_objects(game_id, parameters)
        print(f"[game_loop.py] Game objects initialized for game_id={game_id}.")
        
        # Initialiser les positions et vélocités dans Redis
        await initialize_redis(game_id, paddle_left, paddle_right, ball, powerup_orbs, bumpers)
        print(f"[game_loop.py] Game objects positions initialized in Redis for game_id={game_id}.")
        
        last_powerup_spawn_time = time.time()
        powerup_spawn_interval = 10  # Adjust as needed

        last_bumper_spawn_time = time.time()
        bumper_spawn_interval = 15  # Adjust as needed

        while True:
            current_time = time.time()
            # print(f"[game_loop.py] game_id={game_id} - Loop iteration at {current_time}")

            # Vérifier si la partie est encore "running"
            session_status = await get_game_status(game_id)
            # print(f"[game_loop.py] game_id={game_id} - Session status: {session_status}")
            if session_status != 'running':
                print(f"[game_loop.py] game_id={game_id} is not running (status={session_status}), breaking loop.")
                break

            # 1. Mettre à jour les positions des raquettes depuis Redis en fonction de la vélocité
            await update_paddles_from_redis(game_id, paddle_left, paddle_right)
            # print(f"[game_loop.py] game_id={game_id} - Paddles positions updated from Redis.")

            # 2. Mettre à jour la position de la balle
            ball.move()
            await update_ball_redis(game_id, ball)
            # print(f"[game_loop.py] game_id={game_id} - Ball position updated to ({ball.x}, {ball.y})")

            # 3. Vérifier les collisions
            collision = await check_collisions(game_id, paddle_left, paddle_right, ball, bumpers, powerup_orbs)
            if collision in ['score_left', 'score_right']:
                await handle_score(game_id, collision)
                # print(f"[game_loop.py] game_id={game_id} - Handling score for {collision}")
                
                # Vérifier si quelqu'un a gagné
                score_left = int(r.get(f"{game_id}:score_left") or 0)
                score_right = int(r.get(f"{game_id}:score_right") or 0)
                if score_left >= WIN_SCORE or score_right >= WIN_SCORE:
                    # On arrête la boucle si la partie est terminée
                    break
                else:
                    # Personne n'a encore gagné,
                    # on réinitialise la balle pour continuer la partie
                    terrain_rect = await get_terrain_rect(game_id)
                    center_x = terrain_rect['left'] + terrain_rect['width'] // 2
                    center_y = terrain_rect['top'] + terrain_rect['height'] // 2
                    ball.reset(center_x, center_y, 4, 4)  # Vitesse X/Y à ajuster
                    await update_ball_redis(game_id, ball)
                    print(f"[game_loop.py] Ball reset to ({ball.x}, {ball.y}) with speed ({ball.speed_x}, {ball.speed_y})")

            # 4. Gérer les power-ups
            if parameters.bonus_enabled:
                if current_time - last_powerup_spawn_time >= powerup_spawn_interval:
                    # Tenter de spawn un power-up
                    active_powerups = await count_active_powerups(game_id, powerup_orbs)
                    # print(f"[game_loop.py] game_id={game_id} - Active power-ups: {active_powerups}")
                    if active_powerups < 2:  # MAX_ACTIVE_POWERUPS = 2
                        powerup_orb = random.choice(powerup_orbs)
                        if not powerup_orb.active:
                            spawned = await spawn_powerup(game_id, powerup_orb)
                            if spawned:
                                last_powerup_spawn_time = current_time
                                print(f"[game_loop.py] game_id={game_id} - PowerUp {powerup_orb.effect_type} spawned.")

            # 5. Gérer les bumpers
            if parameters.obstacles_enabled:
                if current_time - last_bumper_spawn_time >= bumper_spawn_interval:
                    # Tenter de spawn un bumper
                    active_bumpers = await count_active_bumpers(game_id, bumpers)
                    # print(f"[game_loop.py] game_id={game_id} - Active bumpers: {active_bumpers}")
                    if active_bumpers < 2:  # MAX_BUMPERS = 2
                        bumper = random.choice(bumpers)
                        if not bumper.active:
                            spawned = await spawn_bumper(game_id, bumper)
                            if spawned:
                                last_bumper_spawn_time = current_time
                                print(f"[game_loop.py] game_id={game_id} - Bumper spawned at ({bumper.x}, {bumper.y}).")

            # 6. Gérer les power-ups expirés
            await handle_powerup_expiration(game_id, powerup_orbs)
            # print(f"[game_loop.py] game_id={game_id} - Handled power-up expiration.")

            # 7. Gérer les bumpers expirés
            await handle_bumper_expiration(game_id, bumpers)
            # print(f"[game_loop.py] game_id={game_id} - Handled bumper expiration.")

            # 8. Broadcast l'état actuel du jeu
            await broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers)
            # print(f"[game_loop.py] game_id={game_id} - Broadcasted game state.")

            # Attendre le prochain cycle
            await asyncio.sleep(dt)
    
    except Exception as e:
        print(f"[game_loop.py] game_id={game_id} encountered an exception: {e}")
    
    finally:
        print(f"[game_loop.py] game_id={game_id} loop ended.")

async def update_paddles_from_redis(game_id, paddle_left, paddle_right):
    """
    Lit la vélocité dans Redis et met à jour la position (y) des paddles.
    """
    left_vel = float(r.get(f"{game_id}:paddle_left_velocity") or 0)
    right_vel = float(r.get(f"{game_id}:paddle_right_velocity") or 0)

    # Appliquer la vélocité
    paddle_left.y += left_vel
    paddle_right.y += right_vel

    # Contraindre le mouvement dans [50, 350 - paddle.height]
    paddle_left.y = max(50, min(350 - paddle_left.height, paddle_left.y))
    paddle_right.y = max(50, min(350 - paddle_right.height, paddle_right.y))

    # Stocker la position mise à jour
    r.set(f"{game_id}:paddle_left_y", paddle_left.y)
    r.set(f"{game_id}:paddle_right_y", paddle_right.y)

async def get_game_status(game_id):
    """
    Récupère le statut de la partie depuis la base de données.
    """
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        return session.status
    except GameSession.DoesNotExist:
        return 'finished'

async def get_game_parameters(game_id):
    """
    Récupère les paramètres (GameParameters) de la partie depuis la base de données.
    """
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        parameters = await sync_to_async(getattr)(session, 'parameters', None)
        return parameters
    except GameSession.DoesNotExist:
        return None

async def initialize_redis(game_id, paddle_left, paddle_right, ball, powerup_orbs, bumpers):
    """
    Initialise les positions et vitesses dans Redis pour chaque objet.
    """
    # Positions initiales des paddles
    r.set(f"{game_id}:paddle_left_y", paddle_left.y)
    r.set(f"{game_id}:paddle_right_y", paddle_right.y)

    # Vélocités initiales des paddles (0 => immobiles)
    r.set(f"{game_id}:paddle_left_velocity", 0)
    r.set(f"{game_id}:paddle_right_velocity", 0)

    # Balle
    r.set(f"{game_id}:ball_x", ball.x)
    r.set(f"{game_id}:ball_y", ball.y)
    r.set(f"{game_id}:ball_vx", ball.speed_x)
    r.set(f"{game_id}:ball_vy", ball.speed_y)

    # Power-ups
    for powerup_orb in powerup_orbs:
        r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_active")
        r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_x")
        r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_y")

    # Bumpers
    for bumper in bumpers:
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_active")
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_x")
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_y")

async def update_ball_redis(game_id, ball):
    """
    Met à jour la position de la balle dans Redis.
    """
    r.set(f"{game_id}:ball_x", ball.x)
    r.set(f"{game_id}:ball_y", ball.y)
    r.set(f"{game_id}:ball_vx", ball.speed_x)
    r.set(f"{game_id}:ball_vy", ball.speed_y)

async def check_collisions(game_id, paddle_left, paddle_right, ball, bumpers, powerup_orbs):
    """
    Vérifie collisions ball/paddles/bumpers/bords, retourne 'score_left', 'score_right' ou None.
    """
    result = await handle_paddle_collisions(game_id, paddle_left, paddle_right, ball)
    if result:
        return result

    handle_border_collisions(ball)

    await handle_bumper_collision(game_id, ball, bumpers)

    await handle_powerup_collision(game_id, ball, powerup_orbs)

    return None


async def handle_paddle_collisions(game_id, paddle_left, paddle_right, ball):
    """
    Gère les collisions avec les paddles gauche et droite.
    """
    # Left paddle
    if ball.x - ball.size <= paddle_left.x + paddle_left.width:
        if paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height:
            ball.last_player = 'left'  # Mettre à jour le dernier joueur
            await handle_paddle_collision(game_id, 'left', paddle_left, ball)
            return None
        else:
            return 'score_right'

    # Right paddle
    if ball.x + ball.size >= paddle_right.x:
        if paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height:
            ball.last_player = 'right'  # Mettre à jour le dernier joueur
            await handle_paddle_collision(game_id, 'right', paddle_right, ball)
            return None
        else:
            return 'score_left'

    return None


def handle_border_collisions(ball):
    """
    Gère les collisions avec les bords supérieur et inférieur.
    """
    if ball.y - ball.size <= 50:
        ball.speed_y = abs(ball.speed_y)  # Rebond vers le bas
    elif ball.y + ball.size >= 350:
        ball.speed_y = -abs(ball.speed_y)  # Rebond vers le haut



async def handle_bumper_collision(game_id, ball, bumpers):
    # Bumpers
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active:
            dist = math.hypot(ball.x - bumper.x, ball.y - bumper.y)
            if dist <= ball.size + bumper.size:
                if current_time - bumper.last_collision_time >= COOLDOWN_TIME:
                    angle = math.atan2(ball.y - bumper.y, ball.x - bumper.x)
                    speed = math.hypot(ball.speed_x, ball.speed_y) * 1.05
                    ball.speed_x = speed * math.cos(angle)
                    ball.speed_y = speed * math.sin(angle)

                    # Mettre à jour la balle dans Redis
                    await update_ball_redis(game_id, ball)

                    # Mettre à jour le temps de la dernière collision
                    bumper.last_collision_time = current_time

                    print(f"[game_loop.py] Ball collided with bumper at ({bumper.x}, {bumper.y}). New speed: ({ball.speed_x}, {ball.speed_y})")


async def handle_paddle_collision(game_id, paddle_side, paddle, ball):
    """
    Gère la logique de collision entre la balle et une raquette.
    """
    relative_y = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2)
    relative_y = max(-1, min(1, relative_y))  # Limiter à l'intervalle [-1, 1]

    angle = relative_y * (math.pi / 4)  # Max 45 degrés
    speed = math.hypot(ball.speed_x, ball.speed_y) * 1.03  # Augmenter la vitesse

    if paddle_side == 'left':
        ball.speed_x = speed * math.cos(angle)
    else:
        ball.speed_x = -speed * math.cos(angle)

    ball.speed_y = speed * math.sin(angle)

    # Mettre à jour la balle dans Redis
    await update_ball_redis(game_id, ball)

    print(f"[game_loop.py] Ball collided with {paddle_side} paddle. New speed: ({ball.speed_x}, {ball.speed_y})")

async def handle_powerup_collision(game_id, ball, powerup_orbs):
    """
    Vérifie si la balle a ramassé un power-up en dehors des collisions avec les paddles.
    """
    for powerup_orb in powerup_orbs:
        if powerup_orb.active:
            dist = math.hypot(ball.x - powerup_orb.x, ball.y - powerup_orb.y)
            if dist <= ball.size + powerup_orb.size:
                # Associer le power-up au dernier joueur qui a touché la balle
                last_player = ball.last_player
                if last_player:
                    await apply_powerup(game_id, last_player, powerup_orb)
                    powerup_orb.deactivate()
                    r.set(f"{game_id}:powerup_{powerup_orb.effect_type}_active", 0)
                    print(f"[game_loop.py] Player {last_player} collected power-up {powerup_orb.effect_type} at ({powerup_orb.x}, {powerup_orb.y})")
                else:
                    # Si aucun joueur n'a touché la balle récemment, attribuer au joueur gauche par défaut
                    await apply_powerup(game_id, 'left', powerup_orb)
                    powerup_orb.deactivate()
                    r.set(f"{game_id}:powerup_{powerup_orb.effect_type}_active", 0)
                    print(f"[game_loop.py] Player left collected power-up {powerup_orb.effect_type} at ({powerup_orb.x}, {powerup_orb.y}) by default")

async def apply_powerup(game_id, player, powerup_orb):
    """
    Applique l'effet du power-up au joueur.
    """
    # Implémenter la logique d'application des effets
    print(f"[game_loop.py] Applying power-up {powerup_orb.effect_type} to {player}")

    # le power_up est detruit car consommé par le joueur  
    powerup_orb.deactivate()
    r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_active")
    r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_x")
    r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_y")

    # Exemple de notification
    channel_layer = get_channel_layer()
    effect = powerup_orb.effect_type
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_applied',
            'player': player,
            'effect': effect
        }
    )


async def handle_score(game_id, scorer):
    """
    Gère l'incrément du score, vérifie si la partie est terminée.
    """
    if scorer == 'score_left':
        score_left = int(r.get(f"{game_id}:score_left") or 0) + 1
        r.set(f"{game_id}:score_left", score_left)
        print(f"[game_loop.py] Player Left scored. Score: {score_left} - {r.get(f'{game_id}:score_right')}")
        if score_left >= WIN_SCORE:
            await finish_game(game_id, 'left')
    elif scorer == 'score_right':
        score_right = int(r.get(f"{game_id}:score_right") or 0) + 1
        r.set(f"{game_id}:score_right", score_right)
        print(f"[game_loop.py] Player Right scored. Score: {r.get(f'{game_id}:score_left')} - {score_right}")
        if score_right >= WIN_SCORE:
            await finish_game(game_id, 'right')

async def finish_game(game_id, winner):
    """
    Termine la partie, notifie, supprime les clés Redis, enregistre GameResult.
    """
    print(f"[game_loop.py] Game {game_id} finished, winner={winner}")
    channel_layer = get_channel_layer()
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        session.status = 'finished'
        await sync_to_async(session.save)()

        score_left = int(r.get(f"{game_id}:score_left") or 0)
        score_right = int(r.get(f"{game_id}:score_right") or 0)
        await sync_to_async(GameResult.objects.create)(
            game=session,
            winner=winner,
            score_left=score_left,
            score_right=score_right
        )
        print(f"[game_loop.py] GameResult created for game_id={game_id}, winner={winner}")
    except GameSession.DoesNotExist:
        print(f"[game_loop.py] GameSession {game_id} does not exist.")
        pass

    # Notifier
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'game_over',
            'winner': winner
        }
    )
    # print(f"[game_loop.py] Broadcast game_over for game_id={game_id}, winner={winner}")

    # Nettoyer les clés Redis
    keys = list(r.scan_iter(f"{game_id}:*"))
    for key in keys:
        r.delete(key)
    print(f"[game_loop.py] Redis keys deleted for game_id={game_id}")

async def spawn_powerup(game_id, powerup_orb):
    if powerup_orb.active:
        print(f"[game_loop.py] PowerUp {powerup_orb.effect_type} is already active, skipping spawn.")
        return False

    terrain_rect = await get_terrain_rect(game_id)
    if await sync_to_async(powerup_orb.spawn)(terrain_rect):
        r.set(f"{game_id}:powerup_{powerup_orb.effect_type}_active", 1)
        r.set(f"{game_id}:powerup_{powerup_orb.effect_type}_x", powerup_orb.x)
        r.set(f"{game_id}:powerup_{powerup_orb.effect_type}_y", powerup_orb.y)
        print(f"[game_loop.py] PowerUp {powerup_orb.effect_type} spawned at ({powerup_orb.x}, {powerup_orb.y})")
        return True
    return False

async def spawn_bumper(game_id, bumper):
    terrain_rect = await get_terrain_rect(game_id)
    if await sync_to_async(bumper.spawn)(terrain_rect):
        key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
        r.set(key, 1)
        r.set(f"{game_id}:bumper_{bumper.x}_{bumper.y}_x", bumper.x)
        r.set(f"{game_id}:bumper_{bumper.x}_{bumper.y}_y", bumper.y)
        print(f"[game_loop.py] Bumper spawned at ({bumper.x}, {bumper.y})")
        return True
    return False

async def count_active_powerups(game_id, powerup_orbs):
    """
    Compte le nombre de power-ups actifs.
    """
    count = 0
    for powerup_orb in powerup_orbs:
        active = r.get(f"{game_id}:powerup_{powerup_orb.effect_type}_active")
        if active and active.decode('utf-8') == '1':
            count += 1
    print(f"[game_loop.py] count_active_powerups ({count})")
    return count


async def count_active_bumpers(game_id, bumpers):
    """
    Compte le nombre de bumpers actifs.
    """
    count = 0
    for bumper in bumpers:
        active = r.get(f"{game_id}:bumper_{bumper.x}_{bumper.y}_active")
        if active and active.decode('utf-8') == '1':
            count += 1
    print(f"[game_loop.py] count_active_bumpers ({count})")
    return count


async def handle_powerup_expiration(game_id, powerup_orbs):
    current_time = time.time()
    for powerup_orb in powerup_orbs:
        if powerup_orb.active and current_time - powerup_orb.spawn_time >= powerup_orb.duration:
            powerup_orb.deactivate()
            r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_active")
            r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_x")
            r.delete(f"{game_id}:powerup_{powerup_orb.effect_type}_y")
            print(f"[game_loop.py] PowerUp {powerup_orb.effect_type} expired at ({powerup_orb.x}, {powerup_orb.y})")

async def handle_bumper_expiration(game_id, bumpers):
    """
    Gère l'expiration des bumpers.
    """
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active and current_time - bumper.spawn_time >= bumper.duration:
            bumper.deactivate()
            key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
            r.set(key, 0)
            print(f"[game_loop.py] Bumper at ({bumper.x}, {bumper.y}) expired")


async def broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers):
    """
    Envoie l'état actuel du jeu aux clients via WebSocket.
    """
    # Récupérer les états des power-ups
    powerups = []
    for powerup_orb in powerup_orbs:
        active = r.get(f"{game_id}:powerup_{powerup_orb.effect_type}_active")
        if active and active.decode('utf-8') == '1':
            x = float(r.get(f"{game_id}:powerup_{powerup_orb.effect_type}_x"))
            y = float(r.get(f"{game_id}:powerup_{powerup_orb.effect_type}_y"))
            powerups.append({
                'type': powerup_orb.effect_type,
                'x': x,
                'y': y,
                'color': list(powerup_orb.color)  # Convertir en liste pour JSON
            })

    # Récupérer les états des bumpers
    active_bumpers = []
    for bumper in bumpers:
        key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
        active = r.get(key)
        if active and active.decode('utf-8') == '1':
            active_bumpers.append({
                'x': bumper.x,
                'y': bumper.y,
                'size': bumper.size,
                'color': list(bumper.color)  # Convertir en liste pour JSON
            })

    data = {
        'type': 'game_state',
        'ball_x': ball.x,
        'ball_y': ball.y,
        'ball_size': ball.size,
        'ball_speed_x': ball.speed_x,
        'ball_speed_y': ball.speed_y,
        'paddle_left_y': paddle_left.y,
        'paddle_right_y': paddle_right.y,
        'paddle_width': paddle_left.width,
        'paddle_left_height': paddle_left.height,
        'paddle_right_height': paddle_right.height,
        'score_left': int(r.get(f"{game_id}:score_left") or 0),
        'score_right': int(r.get(f"{game_id}:score_right") or 0),
        'powerups': powerups,
        'bumpers': active_bumpers,
    }

    await channel_layer.group_send(f"pong_{game_id}", {
        'type': 'broadcast_game_state',
        'data': data
    })
    # print(f"[game_loop.py] Broadcast game_state for game_id={game_id}")

# game/game_objects.py

import random
import math
import time

class Paddle:
    def __init__(self, position, size, speed):
        """
        position: 'left' ou 'right'
        size: taille initiale de la raquette
        speed: vitesse de déplacement
        """
        self.position = position
        self.width = 10
        self.height = size
        self.x = 50 if position == 'left' else 750
        self.y = 200 - self.height // 2
        self.speed = speed
        self.velocity = 0
        self.on_ice = False
        self.shown_size = size  # Current displayed size

    def move(self, direction, is_on_ice, terrain_top, terrain_bottom, speed_boost=False):
        if is_on_ice:
            acceleration = 0.5
            friction = 0.02
            self.velocity += direction * acceleration
            self.velocity *= (1 - friction)
        else:
            self.velocity = direction * (self.speed * 1.5 if speed_boost else self.speed)

        # Apply movement with boundary checking
        new_y = self.y + self.velocity
        if new_y < terrain_top:
            new_y = terrain_top
            self.velocity = 0
        elif new_y + self.height > terrain_bottom:
            new_y = terrain_bottom - self.height
            self.velocity = 0

        self.y = new_y

    def resize(self, new_height):
        self.height = new_height

class Ball:
    def __init__(self, x, y, speed_x, speed_y, size=7):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.size = size
        self.last_player = None  # Nouvel attribut pour suivre le dernier joueur

    def move(self):
        self.x += self.speed_x
        self.y += self.speed_y

    def reset(self, x, y, speed_x, speed_y):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.last_player = None  # Réinitialiser le dernier joueur

class PowerUpOrb:
    def __init__(self, game_id, effect_type, terrain_rect, color=None):
        self.game_id = game_id
        self.effect_type = effect_type  # 'invert', 'shrink', 'ice', 'speed', 'sticky', 'flash'
        self.size = 15
        self.color = color or self.get_default_color()
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 0

    def get_default_color(self):
        colors = {
            'invert': (255, 105, 180),  # Pink
            'shrink': (255, 0, 0),      # Red
            'ice': (0, 255, 255),       # Cyan
            'speed': (255, 215, 0),     # Gold
            'flash': (255, 255, 0),     # Yellow
            'sticky': (50, 205, 50)     # Lime green
        }
        return colors.get(self.effect_type, (255, 255, 255))

    def spawn(self, terrain_rect):
        left = terrain_rect['left']
        right = terrain_rect['left'] + terrain_rect['width']
        top = terrain_rect['top']
        bottom = terrain_rect['top'] + terrain_rect['height']

        max_attempts = 100
        for _ in range(max_attempts):
            new_x = random.randint(left + 50, right - 50)
            new_y = random.randint(top + 50, bottom - 50)

            # Ici on suppose qu'il n'y a pas d'autres collisions à vérifier.
            self.x = new_x
            self.y = new_y
            self.rect = (self.x, self.y, self.size, self.size)
            self.active = True
            self.spawn_time = time.time()
            self.duration = 10
            return True

        return False

    def deactivate(self):
        self.active = False
        self.x = None
        self.y = None
        self.spawn_time = None

class Bumper:
    def __init__(self, game_id, terrain_rect):
        self.game_id = game_id
        self.size = 20
        self.color = (255, 255, 255)  # White
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 0
        self.last_collision_time = 0 

    def spawn(self, terrain_rect):
        left = terrain_rect['left']
        right = terrain_rect['left'] + terrain_rect['width']
        top = terrain_rect['top']
        bottom = terrain_rect['top'] + terrain_rect['height']

        max_attempts = 100
        for _ in range(max_attempts):
            new_x = random.randint(left + 50, right - 50)
            new_y = random.randint(top + 50, bottom - 50)

            # Ici on suppose qu'il n'y a pas d'autres collisions à vérifier.
            self.x = new_x
            self.y = new_y
            self.rect = (self.x, self.y, self.size, self.size)
            self.active = True
            self.spawn_time = time.time()
            self.duration = 10
            return True

        return False

    def deactivate(self):
        self.active = False
# game/manager.py

import asyncio
from .tasks import start_game_loop
import sys

_GLOBAL_LOOP = None

def set_global_loop(loop):
    """
    Stocke une référence à l'event loop principale.
    Appelée lors du démarrage dans asgi.py via LifespanHandler.
    """
    global _GLOBAL_LOOP
    _GLOBAL_LOOP = loop
    print(f"[manager.py] Global loop set: {loop}")

def get_global_loop():
    """
    Renvoie la référence à l'event loop principale.
    """
    return _GLOBAL_LOOP

def schedule_game(game_id):
    """
    Programme l'exécution de start_game_loop(game_id) sans bloquer la requête.
    Tente d'utiliser create_task, sinon fallback sur run_coroutine_threadsafe avec la loop globale.
    """
    try:
        # Essayer de récupérer l'event loop courant
        current_loop = asyncio.get_event_loop()
        if not current_loop.is_running():
            raise RuntimeError("Event loop is not running")
        current_loop.create_task(start_game_loop(game_id))
        print(f"[schedule_game] create_task OK dans loop={current_loop} pour game_id={game_id}")
    except (RuntimeError, AttributeError) as e:
        # Si aucun event loop n'est disponible dans ce thread, utiliser la loop globale
        print("No current event loop in this thread, fallback run_coroutine_threadsafe", file=sys.stderr)
        global_loop = get_global_loop()
        if global_loop and global_loop.is_running():
            future = asyncio.run_coroutine_threadsafe(start_game_loop(game_id), global_loop)
            print(f"[schedule_game] run_coroutine_threadsafe OK dans global_loop={global_loop} pour game_id={game_id}")
        else:
            print("No global loop available or loop is not running, game cannot be scheduled.", file=sys.stderr)
import uuid
from django.db import models
from django.conf import settings

class GameSession(models.Model):
    """
    Un enregistrement pour représenter une partie (en cours ou terminée).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    player_left = models.CharField(max_length=50, null=True, blank=True)
    player_right = models.CharField(max_length=50, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    # ex: "running", "finished"
    status = models.CharField(max_length=10, default='running')

    def __str__(self):
        return f"GameSession {self.id} (status={self.status})"


class GameParameters(models.Model):
    BALL_SPEED_CHOICES = [
        (1, 'Slow'),
        (2, 'Medium'),
        (3, 'Fast'),
    ]
    ball_speed = models.PositiveSmallIntegerField(choices=BALL_SPEED_CHOICES, default=2)

    paddle_size_CHOICES = [
        (1, 'Small'),
        (2, 'Medium'),
        (3, 'Large'),
    ]
    paddle_size = models.PositiveSmallIntegerField(choices=paddle_size_CHOICES, default=2)

    bonus_enabled = models.BooleanField(default=True)
    obstacles_enabled = models.BooleanField(default=False)

    game_session = models.OneToOneField(
        GameSession,
        related_name='parameters',
        on_delete=models.CASCADE
    )

    def __str__(self):
        return (f"Ball speed: {self.get_ball_speed_display()}, "
                f"Racket size: {self.get_paddle_size_display()}, "
                f"Bonus/Malus: {'On' if self.bonus_enabled else 'Off'}, "
                f"Bumpers: {'On' if self.obstacles_enabled else 'Off'}")


class GameResult(models.Model):
    """
    Enregistre le score final d'une partie terminée.
    """
    game = models.ForeignKey(GameSession, on_delete=models.CASCADE)
    winner = models.CharField(max_length=10)  # "left" ou "right"
    score_left = models.IntegerField()
    score_right = models.IntegerField()
    ended_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"[{self.game.id}] winner={self.winner} => {self.score_left}-{self.score_right}"


class GameInvitation(models.Model):
    from_user = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='invitations_sent', on_delete=models.CASCADE)
    to_user = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='invitations_received', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=10,
        choices=[('pending', 'Pending'), ('accepted', 'Accepted'), ('rejected', 'Rejected')],
        default='pending'
    )
    
    def __str__(self):
        return f"Invitation de {self.from_user.username} à {self.to_user.username} - {self.status}"
from django.urls import re_path
from .consumers import PongConsumer

websocket_urlpatterns = [
    # ws://host/ws/pong/<uuid>/
    re_path(r'^ws/pong/(?P<game_id>[0-9a-f-]+)/$', PongConsumer.as_asgi()),
]
# game/tasks.py

import asyncio

ACTIVE_GAMES = {}  # Dict: { game_id -> asyncio.Task }

async def start_game_loop(game_id):
    """
    Lance la game_loop(game_id) et stocke la Task dans ACTIVE_GAMES.
    """
    from .game_loop import game_loop

    # Créer une nouvelle Task
    task = asyncio.create_task(game_loop(game_id))
    ACTIVE_GAMES[game_id] = task

    print(f"[tasks.py] Game loop started for game_id={game_id}")

    try:
        # Attendre que la boucle se termine (score atteint ou session finished)
        await task
    except asyncio.CancelledError:
        print(f"[tasks.py] Game loop for game_id={game_id} was cancelled.")
    finally:
        # Une fois terminé ou annulé, enlever de ACTIVE_GAMES
        del ACTIVE_GAMES[game_id]
        print(f"[tasks.py] Game loop ended for game_id={game_id}")

def is_game_running(game_id):
    """
    Vérifie si une partie est en cours.
    """
    return game_id in ACTIVE_GAMES

def stop_game(game_id):
    """
    Permet de stopper manuellement une partie en cours (annuler la Task).
    """
    task = ACTIVE_GAMES.get(game_id)
    if task:
        task.cancel()
        print(f"[tasks.py] Game loop for game_id={game_id} has been cancelled.")
from django.test import TestCase

# Create your tests here.
# game/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('create/', views.create_game, name='create_game'),
    path('<uuid:game_id>/', views.game_page, name='game'),
    path('results/', views.list_results, name='list_results'),
]
from django.shortcuts import render, redirect
from .models import GameSession, GameResult, GameParameters
from .manager import schedule_game
from .forms import GameParametersForm
from django.conf import settings
import redis

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

def index(request):
    """
    Page d'accueil -> bouton pour créer une partie
    """
    return render(request, 'game/index.html')

def create_game(request):
    """
    Crée un GameSession (UUID), init Redis avec les paramètres personnalisés, lance la loop en non-bloquant
    """
    if request.method == 'POST':
        form = GameParametersForm(request.POST)
        if form.is_valid():
            # Créer une nouvelle GameSession
            session = GameSession.objects.create(status='running') 
            game_id = str(session.id)

            # Créer les GameParameters liés à cette session
            parameters = form.save(commit=False)
            parameters.game_session = session
            parameters.save()

            # Initialiser Redis avec les paramètres personnalisés
            r.set(f"{game_id}:score_left", 0)
            r.set(f"{game_id}:score_right", 0)
            r.set(f"{game_id}:paddle_left_y", 150)
            r.set(f"{game_id}:paddle_right_y", 150)
            r.set(f"{game_id}:ball_x", 300)
            r.set(f"{game_id}:ball_y", 200)
            # Ajuster la vitesse de la balle selon le paramètre
            ball_vx = 3 * parameters.ball_speed
            ball_vy = 2 * parameters.ball_speed
            r.set(f"{game_id}:ball_vx", ball_vx)
            r.set(f"{game_id}:ball_vy", ball_vy)

            # Si les bumpers sont activés, initialiser leurs positions ou autres configurations
            if parameters.obstacles_enabled:
                # Exemple: ajouter des bumpers dans Redis
                # À implémenter selon la logique du jeu
                pass

            print(f"[create_game] GameSession {game_id} created avec paramètres personnalisés. Scheduling game_loop.")
            schedule_game(game_id)

            return redirect('game', game_id=game_id)
    else:
        form = GameParametersForm()

    return render(request, 'game/create_game.html', {'form': form})

def game_page(request, game_id):
    """
    Affiche la page HTML (canvas + websocket) pour la partie <game_id>
    """
    return render(request, 'game/game.html', {'game_id': game_id})

def list_results(request):
    """
    Affiche la liste des parties terminées.
    """
    results = GameResult.objects.select_related('game').order_by('-ended_at')[:20]
    return render(request, 'game/results.html', {'results': results})
