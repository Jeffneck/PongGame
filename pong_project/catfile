# game/game_loop/ball_utils.py
from .redis_utils import get_key, set_key
from .dimensions_utils import get_terrain_rect

# -------------- BALL : UPDATE OBJECTS  --------------------
def move_ball(game_id, ball):
    ball.x = float(get_key(game_id, "ball_x")) + float(get_key(game_id, "ball_vx"))
    ball.y = float(get_key(game_id, "ball_y")) + float(get_key(game_id, "ball_vy"))


def reset_ball(game_id, ball):
    terrain_rect = get_terrain_rect(game_id)
    center_x = terrain_rect['left'] + terrain_rect['width'] // 2
    center_y = terrain_rect['top'] + terrain_rect['height'] // 2
    ball.reset(center_x, center_y, 4, 4)  # Vitesse X/Y à ajuster
    update_ball_redis(game_id, ball)
    print(f"[game_loop.py] Ball reset to ({ball.x}, {ball.y}) with speed ({ball.speed_x}, {ball.speed_y})")


# -------------- BALL : UPDATE REDIS --------------------
def update_ball_redis(game_id, ball):
    set_key(game_id, "ball_x", ball.x)
    set_key(game_id, "ball_y", ball.y)
    set_key(game_id, "ball_vx", ball.speed_x)
    set_key(game_id, "ball_vy", ball.speed_y)# game/game_loop/broadcast.py

from channels.layers import get_channel_layer
from .redis_utils import get_key


# --------- GAME STATE : NOTIFICATIONS -----------
async def broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers):
    """
    Envoie l'état actuel du jeu aux clients via WebSocket.
    """
    # Récupérer les états des power-ups
    powerups = []
    for powerup_orb in powerup_orbs:
        active = get_key(game_id, f"powerup_{powerup_orb.effect_type}_active" or 0)
        if active and active.decode('utf-8') == '1':
            x = float(get_key(game_id, f"powerup_{powerup_orb.effect_type}_x") or 0)
            y = float(get_key(game_id, f"powerup_{powerup_orb.effect_type}_y") or 0)
            powerups.append({
                'type': powerup_orb.effect_type,
                'x': x,
                'y': y,
                'color': list(powerup_orb.color)  # Convertir en liste pour JSON
            })

    # Récupérer les états des bumpers
    # print(f"[game_loop.py] bumpers to send: {bumpers}")
    bumpers = []
    for bumper in bumpers:
        print("BUMPER")
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active" or 0)
        if active and active.decode('utf-8') == '1':
            x = float(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x") or 0)
            y = float(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y") or 0)
            bumpers.append({
                'x': x,
                'y': y,
                'size': bumper.size,
                'color': list(bumper.color)  # Convertir en liste pour JSON
            })

    data = {
        'type': 'game_state',
        'ball_x': ball.x,
        'ball_y': ball.y,
        'ball_size': ball.size,
        'ball_speed_x': ball.speed_x,
        'ball_speed_y': ball.speed_y,
        'paddle_left_y': paddle_left.y,
        'paddle_right_y': paddle_right.y,
        'paddle_width': paddle_left.width,
        'paddle_left_height': paddle_left.height,
        'paddle_right_height': paddle_right.height,
        'score_left': int(get_key(game_id, "score_left") or 0),
        'score_right': int(get_key(game_id, "score_right") or 0),
        'powerups': powerups,
        'bumpers': bumpers,
    }

    await channel_layer.group_send(f"pong_{game_id}", {
        'type': 'broadcast_game_state',
        'data': data
    })
    # print(f"[game_loop.py] Broadcast game_state for game_id={game_id}")




# --------- POWER UPS : NOTIFICATIONS -----------
async def notify_powerup_spawned(game_id, powerup_orb):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_spawned',
            'powerup': {
                'type': powerup_orb.effect_type,
                'x': powerup_orb.x,
                'y': powerup_orb.y,
                'color': list(powerup_orb.color)
            }
        }
    )

async def notify_powerup_applied(game_id, player, effect):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_applied',
            'player': player,
            'effect': effect
        }
    )

async def notify_powerup_expired(game_id, powerup_orb):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_expired',
            'powerup': {
                'type': powerup_orb.effect_type,
                'x': powerup_orb.x,
                'y': powerup_orb.y
            }
        }
    )

# --------- BUMPERS : NOTIFICATIONS -----------
async def notify_bumper_spawned(game_id, bumper):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'bumper_spawned',
            'bumper': {
                'x': bumper.x,
                'y': bumper.y,
            }
        }
    )


async def notify_bumper_expired(game_id, bumper):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'bumper_expired',
            'bumper': {
                'x': bumper.x,
                'y': bumper.y
            }
        }
    )

# --------- COLLISIONS : NOTIFICATIONS -----------
async def notify_collision(game_id, collision_info):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'collision_event',
            'collision': collision_info
        }
    )

async def notify_paddle_collision(game_id, paddle_side, ball):
    collision_info = {
        'type': 'paddle_collision',
        'paddle_side': paddle_side,
        'new_speed_x': ball.speed_x,
        'new_speed_y': ball.speed_y,
    }
    await notify_collision(game_id, collision_info)

    print(f"[collisions.py] Ball collided with {paddle_side} paddle. New speed: ({ball.speed_x}, {ball.speed_y})")

async def notify_border_collision(game_id, border_side, ball):
    collision_info = {
        'type': 'border_collision',
        'border_side': border_side,
        'coor_x_collision': ball.x,
    }
    await notify_collision(game_id, collision_info)

    print(f"[collisions.py] Ball collided with {border_side} border at coor x = {ball.x}.")

async def notify_bumper_collision(game_id, bumper, ball):
    collision_info = {
        'type': 'bumper_collision',
        'bumper_x': bumper.x,
        'bumper_y': bumper.y,
        'new_speed_x': ball.speed_x,
        'new_speed_y': ball.speed_y,
    }
    await notify_collision(game_id, collision_info)

    print(f"[collisions.py] Ball collided with bumper at ({bumper.x}, {bumper.y}). New speed: ({ball.speed_x}, {ball.speed_y})")


# --------- END GAME : NOTIFICATIONS -----------

async def notify_game_finished(game_id, winner, looser):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'game_over',
            'winner': winner,
            'looser': looser
        }
    )

# game/game_loop/bumpers_utils.py

import time
from .redis_utils import get_key, set_key, delete_key
from .dimensions_utils import get_terrain_rect
from .broadcast import notify_bumper_spawned, notify_bumper_expired
import random

MAX_ACTIVE_BUMPERS = 3
SPAWN_INTERVAL_BUMPERS = 7
# -------------- BUMPERS --------------------
async def handle_bumpers_spawn(game_id, bumpers, current_time):
    # Initialisation de last_bumper_spawn_time si elle n'est pas déjà définie
    if not hasattr(handle_bumpers_spawn, "last_bumper_spawn_time"):
        handle_bumpers_spawn.last_bumper_spawn_time = current_time  # Initialisation lors du premier appel

    # Utilisation de la variable statique pour vérifier l'intervalle de temps
    if current_time - handle_bumpers_spawn.last_bumper_spawn_time >= SPAWN_INTERVAL_BUMPERS:
        active_bumpers = count_active_bumpers(game_id, bumpers)
        if active_bumpers < MAX_ACTIVE_BUMPERS:
            # S'assurer qu'on ne génère qu'un seul bumper à la fois
            bumper = random.choice(bumpers)
            if not bumper.active:
                terrain = get_terrain_rect(game_id)
                spawned = await spawn_bumper(game_id, bumper, terrain)
                if spawned:
                    # Mettre à jour le temps de spawn du bumper pour éviter les doubles spawns
                    handle_bumpers_spawn.last_bumper_spawn_time = current_time
                    print(f"[game_loop.py] game_id={game_id} - Bumper spawned at ({bumper.x}, {bumper.y}).")


async def spawn_bumper(game_id, bumper, terrain_rect):
    if bumper.spawn(terrain_rect):
        set_bumper_redis(game_id, bumper)
        print(f"[game_loop.py] Bumper spawned at ({bumper.x}, {bumper.y})")
        await notify_bumper_spawned(game_id, bumper)
        return True
    return False

def count_active_bumpers(game_id, bumpers):
    count = 0
    for bumper in bumpers:
        # active = int(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0)
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0
        if active and active.decode('utf-8') == '1':
        # if active :
            count += 1
    print(f"[loop.py] count_active_bumpers ({count})")
    return count

async def handle_bumper_expiration(game_id, bumpers):
    current_time = time.time()
    for bumper in bumpers:
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0
        # active = int(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0)
        if active and active.decode('utf-8') == '1'and current_time - bumper.spawn_time >= bumper.duration:
        # if active and current_time - bumper.spawn_time >= bumper.duration:
            delete_bumper_redis(game_id, bumper)
            print(f"[loop.py] Bumper at ({bumper.x}, {bumper.y}) expired")
            await notify_bumper_expired(game_id, bumper)

# -------------- BUMPERS : UPDATE REDIS DATA --------------------
def set_bumper_redis(game_id, bumper):
    bumper.activate()
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active", 1)
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x", bumper.x)
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y", bumper.y)


def delete_bumper_redis(game_id, bumper):
    bumper.deactivate()
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active")
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x")
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y")# game/game_loop/collisions.py

import math
import time
from asgiref.sync import sync_to_async
from .ball_utils import update_ball_redis
from .powerups_utils import apply_powerup
from .broadcast import notify_paddle_collision, notify_border_collision, notify_bumper_collision, notify_powerup_applied

# Temps de cooldown pour les collisions avec les bumpers (en secondes)
# COOLDOWN_TIME = 0.5

# async def check_collisions(game_id, paddle_left, paddle_right, ball, bumpers, powerup_orbs):
#     # Gérer les collisions avec les raquettes
#     scoring = await handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball)
#     if scoring:
#         return scoring

#     # Gérer les collisions avec les bords
#     await handle_border_collisions(game_id, ball)

#     # Gérer les collisions avec les bumpers
#     await handle_bumper_collision(game_id, ball, bumpers)

#     # Gérer les collisions avec les power-ups
#     await handle_powerup_collision(game_id, ball, powerup_orbs)

#     return None

async def handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball):
    """
    Gère les collisions avec les paddles gauche et droite.
    Retourne 'score_left', 'score_right' ou None.
    """
    # Collision avec la raquette gauche
    if ball.x - ball.size <= paddle_left.x + paddle_left.width:
        if paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height:
            ball.last_player = 'left'  # Mettre à jour le dernier joueur
            await process_paddle_collision(game_id, 'left', paddle_left, ball)
            return None
        else:
            return 'score_right'

    # Collision avec la raquette droite
    if ball.x + ball.size >= paddle_right.x:
        if paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height:
            ball.last_player = 'right'  # Mettre à jour le dernier joueur
            await process_paddle_collision(game_id, 'right', paddle_right, ball)
            return None
        else:
            return 'score_left'

    return None

#ball
async def process_paddle_collision(game_id, paddle_side, paddle, ball):
    """
    Gère la logique de collision entre la balle et une raquette.
    Ajuste la vitesse et la direction de la balle, met à jour Redis et notifie les clients.
    """
    relative_y = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2)
    relative_y = max(-1, min(1, relative_y))  # Limiter à l'intervalle [-1, 1]

    angle = relative_y * (math.pi / 4)  # Max 45 degrés
    speed = math.hypot(ball.speed_x, ball.speed_y) * 1.03  # Augmenter la vitesse

    if paddle_side == 'left':
        ball.speed_x = speed * math.cos(angle)
    else:
        ball.speed_x = -speed * math.cos(angle)

    ball.speed_y = speed * math.sin(angle)

    # Mettre à jour la balle dans Redis
    update_ball_redis(game_id, ball)

    # Notifier la collision via WebSocket
    await notify_paddle_collision(game_id, paddle_side, ball)
    

async def handle_border_collisions(game_id, ball):
    """
    Gère les collisions avec les bords supérieur et inférieur.
    Ajuste la vitesse de la balle en conséquence.
    """
    if ball.y - ball.size <= 50:
        border_side = "up"
        ball.speed_y = abs(ball.speed_y)  # Rebond vers le bas
        update_ball_redis(game_id, ball)
        await notify_border_collision(game_id, border_side, ball)

    elif ball.y + ball.size >= 350:
        border_side = "down"
        ball.speed_y = -abs(ball.speed_y)  # Rebond vers le haut
        update_ball_redis(game_id, ball)
        await notify_border_collision(game_id, border_side, ball)


async def handle_bumper_collision(game_id, ball, bumpers):
    """
    Gère les collisions entre la balle et les bumpers.
    Ajuste la vitesse et la direction de la balle, met à jour Redis et notifie les clients.
    """
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active:
            dist = math.hypot(ball.x - bumper.x, ball.y - bumper.y)
            if dist <= ball.size + bumper.size:
                # if current_time - bumper.last_collision_time >= COOLDOWN_TIME:
                angle = math.atan2(ball.y - bumper.y, ball.x - bumper.x)
                speed = math.hypot(ball.speed_x, ball.speed_y) * 1.05  # Augmentation de la vitesse
                ball.speed_x = speed * math.cos(angle)
                ball.speed_y = speed * math.sin(angle)

                # Mettre à jour la balle dans Redis
                update_ball_redis(game_id, ball)

                # Mettre à jour le temps de la dernière collision
                bumper.last_collision_time = current_time

                # Notifier la collision via WebSocket
                await notify_bumper_collision(game_id, bumper, ball)
                    

async def handle_powerup_collision(game_id, ball, powerup_orbs):
    """
    Vérifie si la balle a ramassé un power-up en dehors des collisions avec les paddles.
    Applique l'effet du power-up au joueur concerné, met à jour Redis et notifie les clients.
    """
    for powerup_orb in powerup_orbs:
        if powerup_orb.active:
            dist = math.hypot(ball.x - powerup_orb.x, ball.y - powerup_orb.y)
            if dist <= ball.size + powerup_orb.size:
                # Associer le power-up au dernier joueur qui a touché la balle
                last_player = ball.last_player
                if last_player:
                    await apply_powerup(game_id, last_player, powerup_orb)
# game/game_loop/dimensions_utils.py
def get_terrain_rect(game_id):
    """
    Retourne les dimensions du terrain. Peut être ajusté pour récupérer les dimensions dynamiquement.
    """
    return {
        'left': 50,
        'top': 50,
        'width': 700,
        'height': 300
    }
# game/game_loop/initialize_game.py

from .redis_utils import set_key
from ..game_objects import Paddle, Ball, PowerUpOrb, Bumper
from .dimensions_utils import get_terrain_rect


FIELD_HEIGHT = 300

#------------- INITIALIZE : CREATE ALL GAME OBJECTS WITH THEIR INITIAL VALUES --------------
def initialize_game_objects(game_id, parameters):
    paddle_size = {1: 30, 2: 60, 3: 90}[parameters.racket_size]
    paddle_speed = 6  # Peut être ajusté si nécessaire
    ball_speed_multiplier = parameters.ball_speed

    # Obtenir les dimensions du terrain
    terrain_rect = get_terrain_rect(game_id)

    # Initialiser les raquettes
    paddle_left = Paddle('left', paddle_size, paddle_speed)
    paddle_right = Paddle('right', paddle_size, paddle_speed)

    # Initialiser la balle
    initial_ball_speed_x = 4 * ball_speed_multiplier
    initial_ball_speed_y = 4 * ball_speed_multiplier
    ball = Ball(
        terrain_rect['left'] + terrain_rect['width'] // 2,
        terrain_rect['top'] + terrain_rect['height'] // 2,
        initial_ball_speed_x,
        initial_ball_speed_y
    )

    # Initialiser les power-ups et bumpers
    powerup_orbs = [
        PowerUpOrb(game_id, 'invert', terrain_rect, color=(255, 105, 180)),  # Rose pour inverser
        PowerUpOrb(game_id, 'shrink', terrain_rect, color=(255, 0, 0)),      # Rouge pour rétrécir
        PowerUpOrb(game_id, 'ice', terrain_rect, color=(0, 255, 255)),       # Cyan pour glace
        PowerUpOrb(game_id, 'speed', terrain_rect, color=(255, 215, 0)),     # Or pour vitesse
        PowerUpOrb(game_id, 'flash', terrain_rect, color=(255, 255, 0)),     # Jaune pour flash
        PowerUpOrb(game_id, 'sticky', terrain_rect, color=(50, 205, 50))     # Vert lime pour collant
    ]

    bumpers = []
    if parameters.bumpers_activation:
        bumpers = [Bumper(game_id, terrain_rect) for _ in range(3)]  # Ajuster le nombre si nécessaire

    return paddle_left, paddle_right, ball, powerup_orbs, bumpers



#------------- INITIALIZE : UPDATE REDIS DATABASE WITH OBJECTS VALUES--------------
def initialize_redis(game_id, paddle_left, paddle_right, ball):
    # Positions initiales des raquettes
    set_key(game_id, "paddle_left_y", paddle_left.y)
    set_key(game_id, "paddle_right_y", paddle_right.y)

    # Vélocités initiales des raquettes (0 => immobiles)
    set_key(game_id, "paddle_left_velocity", 0)
    set_key(game_id, "paddle_right_velocity", 0)

    # Balle
    set_key(game_id, "ball_x", ball.x)
    set_key(game_id, "ball_y", ball.y)
    set_key(game_id, "ball_vx", ball.speed_x)
    set_key(game_id, "ball_vy", ball.speed_y)# game/game_loop/loop.py

import asyncio
from django.conf import settings
from channels.layers import get_channel_layer
from .models_utils import get_gameSession_status, get_gameSession_parameters
from .initialize_game import initialize_game_objects, initialize_redis
from .score_utils import handle_score, winner_detected, finish_game
from .paddles_utils import move_paddles, update_paddles_redis 
from .bumpers_utils import handle_bumpers_spawn, handle_bumper_expiration
from .collisions import handle_scoring_or_paddle_collision, handle_border_collisions, handle_bumper_collision, handle_powerup_collision
from .ball_utils import reset_ball, move_ball, update_ball_redis 
from .powerups_utils import handle_powerups_spawn, handle_powerup_expiration
from .broadcast import broadcast_game_state

from asgiref.sync import sync_to_async
import random
import time

async def game_loop(game_id):
    """
    Boucle principale pour UNE partie identifiée par game_id.
    Tourne ~60 fois/s tant que la partie est "running".
    """
    channel_layer = get_channel_layer()
    dt = 1/60
    print(f"[game_loop.py] Starting loop for game_id={game_id}.")

    try:
        # Récupérer les paramètres du jeu
        parameters = await get_gameSession_parameters(game_id)
        
        # Initialiser les objets de jeu
        paddle_left, paddle_right, ball, powerup_orbs, bumpers = initialize_game_objects(game_id, parameters)
        print(f"[game_loop.py] Game objects initialized for game_id={game_id}.")
        
        # Initialiser les positions et vélocités dans Redis
        initialize_redis(game_id, paddle_left, paddle_right, ball)
        print(f"[game_loop.py] Game objects positions initialized in Redis for game_id={game_id}.")

        while True:
            current_time = time.time()
            # print(f"[game_loop.py] game_id={game_id} - Loop iteration at {current_time}")

            # Vérifier si la partie est encore "running"
            session_status = await get_gameSession_status(game_id)
            # print(f"[game_loop.py] game_id={game_id} - Session status: {session_status}")
            if session_status != 'running':
                print(f"[game_loop.py] game_id={game_id} is not running (status={session_status}), breaking loop.")
                break

            # Mettre à jour les positions des raquettes depuis Redis en fonction de la vélocité
            move_paddles(game_id, paddle_left, paddle_right)
            # Mettre a jour redis avec la nouvelle position des paddles (après le mouvement)
            update_paddles_redis(game_id, paddle_left, paddle_right)
            # print(f"[game_loop.py] game_id={game_id} - Paddles positions updated from Redis.")

            # Mettre à jour la position de la balle (ancienne valeur + increment)
            move_ball(game_id, ball)
            update_ball_redis(game_id, ball)
            # print(f"[game_loop.py] game_id={game_id} - Ball position updated to ({ball.x}, {ball.y})")

            # 3. Vérifier les collisions (et aussi les buts marques)
            await handle_border_collisions(game_id, ball)
            await handle_bumper_collision(game_id, ball, bumpers)
            await handle_powerup_collision(game_id, ball, powerup_orbs)
            scorer = await handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball)
            if scorer in ['score_left', 'score_right']:
                handle_score(game_id, scorer)
                if (winner_detected(game_id)):
                    await finish_game(game_id)
                    break
                else:
                    reset_ball(game_id, ball)

            # 4. Gérer les power-ups
            if parameters.bonus_malus_activation:
                await handle_powerups_spawn(game_id, powerup_orbs, current_time)
                await handle_powerup_expiration(game_id, powerup_orbs)


            # 5. Gérer les bumpers
            if parameters.bumpers_activation:
                await handle_bumpers_spawn(game_id, bumpers, current_time)
                await handle_bumper_expiration(game_id, bumpers)

            # 8. Broadcast l'état actuel du jeu
            await broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers)
            # print(f"[game_loop.py] game_id={game_id} - Broadcasted game state.")

            # Attendre le prochain cycle
            await asyncio.sleep(dt)
    
    except Exception as e:
        print(f"[game_loop.py] game_id={game_id} encountered an exception: {e}")
    
    finally:
        print(f"[game_loop.py] game_id={game_id} loop ended.")# game/game_loop/models_utils.py
from django.apps import apps  # Import retardé pour éviter les conflits d'import
from asgiref.sync import sync_to_async


async def get_gameSession_status(game_id):
    GameSession = apps.get_model('game', 'GameSession')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        return session.status
    except GameSession.DoesNotExist:
        return 'finished'


async def set_gameSession_as_finished(game_id):
    GameSession = apps.get_model('game', 'GameSession')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        session.status = 'finished'
        await sync_to_async(session.save)()
        return session
    except GameSession.DoesNotExist:
        return None


async def get_gameSession_parameters(game_id):
    GameSession = apps.get_model('game', 'GameSession')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        parameters = await sync_to_async(getattr)(session, 'parameters', None)
        return parameters
    except GameSession.DoesNotExist:
        return None


async def create_gameResults(game_id, endgame_infos):
    GameSession = apps.get_model('game', 'GameSession')
    GameResult = apps.get_model('game', 'GameResult')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        await sync_to_async(GameResult.objects.create)(
            game=session,
            winner=endgame_infos['winner'],
            looser=endgame_infos['looser'],
            score_left=endgame_infos['score_left'],
            score_right=endgame_infos['score_right']
        )
    except GameSession.DoesNotExist:
        print(f"[create_gameResults] GameSession {game_id} does not exist.")# game/game_loop/paddles_utils.py
from .redis_utils import get_key, set_key
from .dimensions_utils import get_terrain_rect
# FIELD_HEIGHT = 400

# -------------- PADDLES --------------------
def move_paddles(game_id, paddle_left, paddle_right):
    left_vel = float(get_key(game_id, "paddle_left_velocity") or 0)
    right_vel = float(get_key(game_id, "paddle_right_velocity") or 0)

    terrain_rect = get_terrain_rect(game_id)
    terrain_top = terrain_rect['top']
    terrain_bottom = terrain_top + terrain_rect['height']

    # Appliquer la vélocité
    paddle_left.y += left_vel
    paddle_right.y += right_vel

    # Contraindre le mouvement dans les limites du terrain
    paddle_left.y = max(terrain_top, min(terrain_bottom - paddle_left.height, paddle_left.y))
    paddle_right.y = max(terrain_top, min(terrain_bottom - paddle_right.height, paddle_right.y))

# -------------- PADDLES : UPDATE REDIS--------------------
def update_paddles_redis(game_id, paddle_left, paddle_right):
    set_key(game_id, "paddle_left_y", paddle_left.y)
    set_key(game_id, "paddle_right_y", paddle_right.y)import time
from .redis_utils import get_key
from .dimensions_utils import get_terrain_rect
from .redis_utils import set_key, get_key, delete_key
from .broadcast import notify_powerup_applied, notify_powerup_spawned, notify_powerup_expired
import random

MAX_ACTIVE_POWERUPS = 2
SPAWN_INTERVAL_POWERUPS = 5

# -------------- POWER UP --------------------
async def handle_powerups_spawn(game_id, powerup_orbs, current_time):
    # Initialisation de last_powerup_spawn_time si elle n'est pas déjà définie
    if not hasattr(handle_powerups_spawn, "last_powerup_spawn_time"):
        handle_powerups_spawn.last_powerup_spawn_time = current_time  # Initialisation lors du premier appel

    # Utilisation de la variable statique pour vérifier l'intervalle de temps
    if current_time - handle_powerups_spawn.last_powerup_spawn_time >= SPAWN_INTERVAL_POWERUPS:
        active_powerups = count_active_powerups(game_id, powerup_orbs)
        if active_powerups < MAX_ACTIVE_POWERUPS:
            # S'assurer qu'on ne génère qu'un seul powerup à la fois
            powerup_orb = random.choice(powerup_orbs)
            if not powerup_orb.active:
                terrain = get_terrain_rect(game_id)
                spawned = await spawn_powerup(game_id, powerup_orb, terrain)
                if spawned:
                    # Mettre à jour le temps de spawn du powerup pour éviter les doubles spawns
                    handle_powerups_spawn.last_powerup_spawn_time = current_time
                    print(f"[game_loop.py] game_id={game_id} - PowerUp {powerup_orb.effect_type} spawned.")



async def spawn_powerup(game_id, powerup_orb, terrain_rect):
    # Ne pas faire spawn 2 fois le même powerup sur le terrain
    if powerup_orb.active:
        print(f"[powerups.py] PowerUp {powerup_orb.effect_type} is already active, skipping spawn.")
        return False

    if (powerup_orb.spawn)(terrain_rect):
        set_powerup_redis(game_id, powerup_orb)
        print(f"[powerups.py] PowerUp {powerup_orb.effect_type} spawned at ({powerup_orb.x}, {powerup_orb.y})")
        await notify_powerup_spawned(game_id, powerup_orb)
        return True
    return False

async def apply_powerup(game_id, player, powerup_orb):
    print(f"[powerups.py] Applying power-up {powerup_orb.effect_type} to {player}")
    delete_powerup_redis(game_id, powerup_orb)
    await notify_powerup_applied(game_id, player, powerup_orb.effect_type)

def count_active_powerups(game_id, powerup_orbs):
    count = 0
    for powerup_orb in powerup_orbs:
        active = get_key(game_id, f"powerup_{powerup_orb.effect_type}_active") or 0
        if active and active.decode('utf-8') == '1':
            count += 1
    print(f"[loop.py] count_active_powerups ({count})")
    return count

async def handle_powerup_expiration(game_id, powerup_orbs):
    current_time = time.time()
    for powerup_orb in powerup_orbs:
        if powerup_orb.active and current_time - powerup_orb.spawn_time >= powerup_orb.duration:
            delete_powerup_redis(game_id, powerup_orb)
            print(f"[game_loop.py] PowerUp {powerup_orb.effect_type} expired at ({powerup_orb.x}, {powerup_orb.y})")
            await notify_powerup_expired(game_id, powerup_orb)


# -------------- POWER UP : UPDATE REDIS DATA --------------------
def set_powerup_redis(game_id, powerup_orb):
    powerup_orb.activate()
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_active", 1)
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_x", powerup_orb.x)
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_y", powerup_orb.y)

def delete_powerup_redis(game_id, powerup_orb):
    powerup_orb.deactivate()
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_active")
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_x")
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_y")
# game/game_loop/redis_utils.py

import redis
from django.conf import settings

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

def set_key(game_id, key, value):
    r.set(f"{game_id}:{key}", value)

def get_key(game_id, key):
    return r.get(f"{game_id}:{key}")

def delete_key(game_id, key):
    r.delete(f"{game_id}:{key}")

def scan_and_delete_keys(game_id):
    keys = list(r.scan_iter(f"{game_id}:*"))
    for key in keys:
        r.delete(key)

# game/game_loop/score_utils.py

from channels.layers import get_channel_layer
from asgiref.sync import sync_to_async
from .broadcast import notify_game_finished
from .redis_utils import set_key, get_key, scan_and_delete_keys
from .models_utils import set_gameSession_as_finished, create_gameResults

# transformer en parametre ajustable GameParameters?
WIN_SCORE = 4  

def handle_score(game_id, scorer):
    if scorer == 'score_left':
        score_left = int(get_key(game_id, "score_left") or 0) + 1
        set_key(game_id, "score_left", score_left)
        print(f"[loop.py] Player Left scored. Score: {score_left} - {get_key(game_id, 'score_right')}")            

    else :
        score_right = int(get_key(game_id, "score_right") or 0) + 1
        set_key(game_id, "score_right", score_right)
        print(f"[loop.py] Player Right scored. Score: {get_key(game_id, 'score_left')} - {score_right}")

# async def check_end_conditions(game_id, quitter):
#     if(quitter): 
#         if(quitter == "player_left"): 
#             score_left = 0
#             score_right = WIN_SCORE
#         if(quitter == "player_right"): 
#             score_left = WIN_SCORE
#             score_right = 0
#     else :
#         score_left = int(get_key(game_id, "score_left") or 0)
#         score_right = int(get_key(game_id, "score_right") or 0)

#     if (score_left == WIN_SCORE or score_right == WIN_SCORE):
#         finish_game(game_id)
#         return True
#     return False

def winner_detected(game_id):

    score_left = int(get_key(game_id, "score_left") or 0)
    score_right = int(get_key(game_id, "score_right") or 0)

    if (score_left == WIN_SCORE or score_right == WIN_SCORE):
        return True
    return False

async def finish_game(game_id):
    # Récupérer les scores depuis Redis
    score_left = int(get_key(game_id, "score_left") or 0)
    score_right = int(get_key(game_id, "score_right") or 0)

    # Marquer la session comme terminée et récupérer ses informations
    gameSession = await set_gameSession_as_finished(game_id)
    if not gameSession:
        print(f"[finish_game] GameSession {game_id} does not exist.")
        return

    # Identifier le gagnant et le perdant
    if score_left > score_right:
        winner = gameSession.player_left
        looser = gameSession.player_right
    else:
        winner = gameSession.player_right
        looser = gameSession.player_left

    # Préparer les informations de fin de partie
    endgame_infos = {
        'winner': winner,
        'looser': looser,
        'score_left': score_left,
        'score_right': score_right,
    }

    # Créer un enregistrement des résultats
    await create_gameResults(game_id, endgame_infos)

    # Notifier les utilisateurs via WebSocket
    await notify_game_finished(game_id, winner, looser)

    # Nettoyer les clés Redis
    scan_and_delete_keys(game_id)
    print(f"[loop.py] Redis keys deleted for game_id={game_id}")