//API.js

"use strict";
import { navigateTo } from '../router.js';
import { HTTPError, ContentTypeError, NetworkError } from './apiErrors.js';
import { showStatusMessage } from '../tools/displayInfo.js';

// Ajoutez ici une fonction utilitaire pour forcer la déconnexion
function forceLogout(message) {
  // Effacez les tokens stockés
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
  // Affichez un message d'erreur (facultatif)
  showStatusMessage(message, 'error');
  // Redirigez vers la page de login
  navigateTo('/login');
}

const Api = {
  async request(url, method = 'GET', formData = null, customHeaders = {}) {
    try {
      const headers = { ...this.prepareHeaders(), ...customHeaders };

      // Vérification et renouvellement du token si nécessaire
      const jwtAccessToken = this.getJWTaccessToken();
      if (jwtAccessToken && this.isTokenExpiringSoon(jwtAccessToken)) {
        console.warn("Access token sur le point d'expirer, tentative de renouvellement...");
        const newToken = await this.handleTokenRefresh();
        if (newToken) {
          headers['Authorization'] = `Bearer ${newToken}`;
        } else {
          // Si le token ne peut pas être rafraîchi, forcer la déconnexion
          forceLogout("Votre session a expiré, veuillez vous reconnecter.");
          return; // Arrête l'exécution
        }
      }

      let response = await this.sendRequest(url, method, formData, headers);

      if (response.status === 401) {
        const data = await response.json();
        if (data.error_code === 'not_authenticated') {
          showStatusMessage(data.message, 'error');
          forceLogout(data.message || "Session expirée, reconnectez-vous.");
          return;
        } else {
          response = await this.handleUnauthorized(url, method, formData, customHeaders);
        }
      } else if (response.status === 403) {
        const data = await response.json();
        if (data.error_code === 'auth_partial_required') {
          showStatusMessage(data.message, 'error');
          forceLogout(data.message || "Session incomplète, reconnectez-vous.");
          return;
        } else {
          throw new HTTPError(data.message || 'Erreur inconnue.', response.status);
        }
      }
      return await this.handleResponse(response);
    } catch (error) {
      if (error instanceof TypeError) {
        throw new NetworkError("Échec réseau : " + error.message);
      }
      // Si une erreur HTTP 401 survient, forcer la déconnexion
      if (error instanceof HTTPError && error.status === 401) {
        forceLogout(error.message || "Session expirée, reconnectez-vous.");
      }
      throw error;
    }
  },

  prepareHeaders() {
    const headers = {
      'X-CSRFToken': this.getCSRFToken(),
    };

    const jwtAccessToken = this.getJWTaccessToken();
    if (jwtAccessToken) {
      headers['Authorization'] = `Bearer ${jwtAccessToken}`;
    }

    return headers;
  },

  isTokenExpiringSoon(token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp - currentTime < 300; // Moins de 5 minutes
    } catch (error) {
      console.error("Erreur lors de la vérification de l'expiration du token :", error);
      return true;
    }
  },

  async sendRequest(url, method, formData, headers) {
    return fetch(url, {
      method,
      headers,
      body: method !== 'GET' && formData instanceof FormData ? formData : undefined,
    });
  },

  async handleUnauthorized(url, method, formData, customHeaders) {
    console.warn("Accès non autorisé, tentative de rafraîchissement du token...");
    const newAccessToken = await this.handleTokenRefresh();
    if (newAccessToken) {
      const updatedHeaders = {
        ...this.prepareHeaders(),
        ...customHeaders,
        'Authorization': `Bearer ${newAccessToken}`,
      };

      const response = await this.sendRequest(url, method, formData, updatedHeaders);
      if (!response.ok) {
        throw new HTTPError(
          response.statusText || "Échec après rafraîchissement du token",
          response.status
        );
      }
      return response;
    } else {
      throw new HTTPError("Impossible de rafraîchir le token.", 401);
    }
  },

  async handleTokenRefresh() {
    const jwtRefreshToken = this.getJWTrefreshToken();
    if (!jwtRefreshToken) {
      console.error("Aucun refresh token disponible.");
      return null;
    }
    try {
      const response = await fetch("/accounts/refreshJwt/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": this.getCSRFToken(),
        },
        body: JSON.stringify({ refresh_token: jwtRefreshToken }),
      });
      if (response.ok) {
        const data = await response.json();
        const newAccessToken = data.access_token;
        localStorage.setItem("access_token", newAccessToken);
        return newAccessToken;
      } else {
        console.error("Erreur lors du rafraîchissement du token :", response.statusText);
        return null;
      }
    } catch (error) {
      console.error("Échec du rafraîchissement du token :", error);
      return null;
    }
  },

  async handleResponse(response) {
    const contentType = response.headers.get("Content-Type");
    if (response.ok && contentType && contentType.includes("application/json")) {
      return response.json();
    } else if (!response.ok && contentType && contentType.includes("application/json")) {
      const errorData = await response.json();
      throw new HTTPError(errorData.message || "Erreur inconnue.", response.status);
    } else {
      throw new HTTPError("Réponse inattendue.", response.status);
    }
  },

  getCSRFToken() {
    const cookie = document.cookie
      .split(";")
      .find(c => c.trim().startsWith("csrftoken="));
    return cookie ? cookie.trim().substring("csrftoken=".length) : "";
  },

  getJWTaccessToken() {
    return localStorage.getItem("access_token") || null;
  },

  getJWTrefreshToken() {
    return localStorage.getItem("refresh_token") || null;
  },

  async get(url) {
    return this.request(url, "GET");
  },

  async post(url, formData) {
    return this.request(url, "POST", formData);
  },

  async put(url, formData) {
    return this.request(url, "PUT", formData);
  },

  async delete(url) {
    return this.request(url, "DELETE");
  },
};

export async function requestGet(app, view) {
  const url = `/${app}/${view}/`;
  try {
    return await Api.get(url);
  } catch (error) {
    console.error(`Erreur lors du chargement de ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestPost(app, view, formData) {
  const url = `/${app}/${view}/`;
  console.debug("POST request URL:", url);
  try {
    return await Api.post(url, formData);
  } catch (error) {
    console.error(`Erreur lors du POST vers ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestDelete(app, view, resourceId) {
  const url = `/${app}/${view}/${resourceId}/`;
  try {
    return await Api.delete(url);
  } catch (error) {
    console.error(`Erreur lors de la suppression de ${app}-${view} avec ID ${resourceId} :`, error);
    throw error;
  }
}

export { RequestError, HTTPError, ContentTypeError, NetworkError } from "./apiErrors.js";




//models.py

import secrets
import hashlib
from datetime import timedelta
from pathlib import Path

from django.db import models
from django.conf import settings
from django.contrib.auth.models import AbstractUser
from django.utils import timezone
from django.core.exceptions import ValidationError

class CustomUser(AbstractUser):
    """
    Utilisateur personnalisé avec gestion de la 2FA, d'un avatar et du statut en ligne.
    """
    is_2fa_enabled = models.BooleanField(default=False)
    totp_secret = models.CharField(max_length=32, null=True, blank=True)
    friends = models.ManyToManyField('self', symmetrical=True, blank=True)
    avatar = models.ImageField(
        upload_to='avatars/',
        null=True,
        blank=True,
        default='avatars/default_avatar.png'
    )
    is_online = models.BooleanField(default=False)

    def clean(self):
        """
        Validation customisée :
         - Si la 2FA est activée, le champ totp_secret ne doit pas être vide.
        """
        super().clean()
        if self.is_2fa_enabled and not self.totp_secret:
            raise ValidationError("Le secret TOTP ne peut pas être vide si la 2FA est activée.")

    def __str__(self):
        return self.username


class FriendRequest(models.Model):
    from_user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name='friend_requests_sent',
        on_delete=models.CASCADE
    )
    to_user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name='friend_requests_received',
        on_delete=models.CASCADE
    )
    timestamp = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=10,
        choices=[('pending', 'Pending'), ('accepted', 'Accepted'), ('rejected', 'Rejected')],
        default='pending'
    )

    def __str__(self):
        return f"{self.from_user} to {self.to_user} - {self.status}"


class TwoFactorCode(models.Model):
    """
    Code 2FA associé à un utilisateur.
    Le code est généré de manière sécurisée et expire après 10 minutes.
    """
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    code = models.CharField(max_length=6)
    created_at = models.DateTimeField(auto_now_add=True)

    @classmethod
    def generate_code(cls, user):
        """
        Génère un code 2FA sécurisé à 6 chiffres en utilisant le module secrets,
        supprime les anciens codes de l'utilisateur et crée un nouvel enregistrement.
        """
        cls.objects.filter(user=user).delete()
        code = ''.join(str(secrets.randbelow(10)) for _ in range(6))
        return cls.objects.create(user=user, code=code)

    def is_valid(self):
        """
        Vérifie si le code est encore valide (expiration après 10 minutes).
        Utilise timezone.now() pour assurer la cohérence des fuseaux horaires.
        """
        return timezone.now() - timedelta(minutes=10) <= self.created_at

    def __str__(self):
        return f"TwoFactorCode(user={self.user}, code={self.code})"


class RefreshToken(models.Model):
    """
    Stocke le refresh token d'un utilisateur.
    Pour augmenter la sécurité, le token est stocké sous forme de hash SHA-256.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='refresh_tokens'
    )
    # Stockage du hash SHA-256 (hex digest de 64 caractères) du token
    token = models.CharField(max_length=64, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    is_blacklisted = models.BooleanField(default=False)

    def set_token(self, raw_token):
        """
        Calcule et stocke le hash SHA-256 du token brut.
        """
        self.token = hashlib.sha256(raw_token.encode('utf-8')).hexdigest()

    def check_token(self, raw_token):
        """
        Vérifie si le token brut correspond au hash stocké.
        """
        return self.token == hashlib.sha256(raw_token.encode('utf-8')).hexdigest()

    def is_expired(self):
        """Vérifie si le token a expiré."""
        return timezone.now() > self.expires_at

    def is_valid(self):
        """Le token est valide s'il n'est pas expiré et n'est pas blacklisté."""
        return not self.is_expired() and not self.is_blacklisted

    def __str__(self):
        return f"RefreshToken(user={self.user}, expires_at={self.expires_at})"


// middleware.py

import logging
from django.conf import settings
from django.contrib.auth.models import AnonymousUser
from accounts.models import CustomUser
import jwt

logger = logging.getLogger(__name__)

class JWTAuthenticationMiddleware:
    """
    Middleware d'authentification JWT.
    
    Extrait et décode le token JWT présent dans le header Authorization.
    En cas d'erreur ou d'absence de token, request.user est défini sur AnonymousUser.
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        auth_header = request.headers.get('Authorization', '')
        if auth_header.startswith("Bearer "):
            token = auth_header[7:].strip()  # Extrait le token après "Bearer "
            try:
                # Décode le token JWT en utilisant la clé secrète et l'algorithme HS256
                payload = jwt.decode(token, settings.SECRET_KEY, algorithms=['HS256'])
                user_id = payload.get('user_id')
                if not user_id:
                    raise jwt.InvalidTokenError("Le payload ne contient pas d'ID utilisateur")
                
                try:
                    user = CustomUser.objects.get(id=user_id)
                except CustomUser.DoesNotExist:
                    logger.debug("Utilisateur introuvable pour l'ID : %s", user_id)
                    user = AnonymousUser()
                request.user = user

            except jwt.ExpiredSignatureError:
                logger.warning("Le jeton JWT a expiré.")
                request.user = AnonymousUser()
            except jwt.InvalidTokenError as e:
                logger.warning("Jeton JWT invalide : %s", e)
                request.user = AnonymousUser()
            except Exception as e:
                logger.error("Erreur inattendue lors de l'authentification JWT : %s", e)
                request.user = AnonymousUser()
        else:
            logger.debug("Aucun jeton JWT fourni ou format invalide dans le header Authorization.")
            request.user = AnonymousUser()

        response = self.get_response(request)
        return response



// tokenManaGEMENT.PY

import json
import hashlib
import logging
import jwt
from jwt.exceptions import ExpiredSignatureError, InvalidTokenError
from datetime import timedelta
from django.views import View
from django.http import JsonResponse
from django.conf import settings
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_protect
from accounts.models import RefreshToken, CustomUser
from accounts.utils import generate_jwt_token
from pong_project.decorators import login_required_json

logger = logging.getLogger(__name__)

@method_decorator(csrf_protect, name='dispatch')
@method_decorator(login_required_json, name='dispatch')
class RefreshJwtView(View):
    """
    Vue pour gérer les requêtes de rafraîchissement du token.
    Valide le refresh token (en comparant son hash) et délivre un nouveau access token.
    """

    def post(self, request):
        try:
            # Tentative de décodage du corps JSON
            try:
                body = json.loads(request.body)
            except json.JSONDecodeError:
                logger.warning("Invalid JSON in request body")
                return JsonResponse({'error': 'Invalid JSON'}, status=400)

            refresh_token = body.get('refresh_token')
            if not refresh_token:
                logger.warning("Refresh token not provided in request")
                return JsonResponse({'error': 'Refresh token is required'}, status=400)

            # Décodage du refresh token avec validation de la signature
            payload = jwt.decode(refresh_token, settings.SECRET_KEY, algorithms=['HS256'])
            # Optionnel : ajouter ici la validation d'autres claims (issuer, audience, etc.)

            # Calcul du hash SHA-256 du refresh token fourni
            hashed_token = hashlib.sha256(refresh_token.encode('utf-8')).hexdigest()

            # Vérifie la validité du refresh token dans la base via son hash
            token_obj = RefreshToken.objects.filter(token=hashed_token).first()
            if not token_obj or not token_obj.is_valid():
                logger.warning("Invalid or expired refresh token")
                return JsonResponse({'error': 'Invalid or expired refresh token'}, status=401)

            # Invalider le refresh token après usage pour éviter sa réutilisation
            token_obj.is_blacklisted = True
            token_obj.save()

            # Récupère l'utilisateur depuis le payload
            user_id = payload.get('user_id')
            user = CustomUser.objects.filter(id=user_id).first()
            if not user:
                logger.warning(f"User with ID {user_id} not found")
                return JsonResponse({'error': 'User not found'}, status=404)

            # Génère un nouveau access token (sans générer de nouveau refresh token)
            new_access_token = generate_jwt_token(user, include_refresh=False)['access_token']

            return JsonResponse({'access_token': new_access_token}, status=200)

        except ExpiredSignatureError:
            logger.warning("Refresh token expired")
            return JsonResponse({'error': 'Refresh token expired'}, status=401)
        except InvalidTokenError:
            logger.warning("Invalid refresh token")
            return JsonResponse({'error': 'Invalid refresh token'}, status=401)
        except Exception as e:
            logger.error(f"Unexpected error during token refresh: {str(e)}")
            return JsonResponse({'error': 'An unexpected error occurred'}, status=500)


// Login et logout .py

import logging

from django.views import View
from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_POST, require_GET
from django.template.loader import render_to_string
from django.contrib.auth import authenticate, login

from accounts.utils import generate_jwt_token
from accounts.forms import LoginForm
from pong_project.decorators import user_not_authenticated

logger = logging.getLogger(__name__)


@method_decorator(user_not_authenticated, name='dispatch')
@method_decorator(csrf_protect, name='dispatch')
class LoginView(View):
    """
    Vue pour gérer la connexion utilisateur.
    - GET  : Retourne le formulaire de connexion.
    - POST : Traite la soumission du formulaire et authentifie l'utilisateur.
    """
    @method_decorator(require_GET)
    def get(self, request):
        """
        Affiche le formulaire de connexion.
        Retourne un JSON contenant le HTML du formulaire.
        """
        form = LoginForm()
        rendered_form = render_to_string('accounts/login.html', {'form': form})
        return JsonResponse({
            'status': 'success',
            'html': rendered_form,
        }, status=200)

    @method_decorator(require_POST)
    def post(self, request):
        logger.debug("Début de la méthode POST de LoginView")
        form = LoginForm(request.POST)

        if not form.is_valid():
            return JsonResponse(
                {'status': 'error', 'errors': form.errors},
                status=400
            )

        username = form.cleaned_data.get('username')
        password = form.cleaned_data.get('password')

        user = authenticate(request, username=username, password=password)

        # Message d'erreur générique pour éviter l'énumération d'utilisateurs
        error_message = "Nom d'utilisateur ou mot de passe invalide"

        # Vérification de l'existence et de l'activité du compte
        if user is None or not user.is_active:
            logger.warning("Tentative d'authentification échouée pour l'utilisateur: %s", username)
            return JsonResponse(
                {'status': 'error', 'message': error_message},
                status=401
            )

        try:
            # Gestion de la 2FA
            if getattr(user, 'is_2fa_enabled', False):
                request.session['auth_partial'] = True
                return JsonResponse(
                    {'status': 'success', 'requires_2fa': True},
                    status=200
                )

            # Génération des tokens JWT (access et refresh)
            token_jwt = generate_jwt_token(user)

            # Mise à jour du statut de l'utilisateur et authentification
            user.is_online = True
            user.save()
            login(request, user)

            response_data = {
                'status': 'success',
                'access_token': token_jwt.get('access_token'),
                'refresh_token': token_jwt.get('refresh_token'),
                'requires_2fa': False,
                'is_authenticated': True
            }
            return JsonResponse(response_data, status=200)
        except Exception as e:
            logger.exception("Erreur lors de l'authentification pour l'utilisateur: %s", username)
            return JsonResponse(
                {'status': 'error', 'message': "Erreur interne du serveur"},
                status=500
            )




			# ---- Imports standard ----
			import logging
			
			# ---- Imports tiers ----
			from django.views import View
			from django.http import JsonResponse
			from django.utils.decorators import method_decorator
			from django.views.decorators.csrf import csrf_protect
			from django.contrib.auth import logout
			from accounts.models import RefreshToken
			from pong_project.decorators import login_required_json
			# ---- Configuration ----
			logger = logging.getLogger(__name__)
			
			
			@method_decorator(csrf_protect, name='dispatch')  # Applique la protection CSRF à toutes les méthodes de la classe
			@method_decorator(login_required_json, name='dispatch')  # Restreint l'accès à la vue aux utilisateurs connectés
			class LogoutView(View):
				"""
				Class-Based View (CBV) pour gérer la déconnexion utilisateur.
				- POST : Déconnecte l'utilisateur en mettant à jour son état et en supprimant sa session.
				"""
			
				def post(self, request):
					try:
						logger.debug("Début de la déconnexion")
						refresh_token = request.POST.get('refresh_token')
						if not refresh_token:
							logger.error("Aucun refresh token fourni")
							return JsonResponse({'error': 'Refresh token is required'}, status=400)
			
						token = RefreshToken.objects.filter(token=refresh_token).first()
						if token:
							logger.debug("Token trouvé, suppression...")
							token.delete()
						else:
							logger.error("Refresh token invalide")
							return JsonResponse({'error': 'Invalid refresh token'}, status=401)
			
						logout(request)
						logger.debug("Utilisateur déconnecté")
						return JsonResponse({'status': 'success', 'message': 'Déconnexion réussie.'})
			
					except Exception as e:
						logger.error(f"Erreur lors de la déconnexion : {str(e)}")
						return JsonResponse({'error': str(e)}, status=500)

						

	
