===== ./accountManagement/events.js =====
import { requestPost } from '../api/api.js';
import { handleDeleteAccount } from '../auth/index.js';
import { navigateTo } from '../router.js';

async function handleLanguageChange(language) {
    const formData = new FormData();
    console.log(language);
    formData.append('language', language); // Ajoute la paire clé-valeur "language=fr"
    const data = await  requestPost('accounts', 'set_language', formData);
    if (data.status === 'success') {
        location.reload(); // Recharge la page pour appliquer la langue
    }
}

export function attachProfileEvents() {
    // Bouton Activer 2FA
    const enable2FABtn = document.querySelector('#enable-2fa-btn');
    if (enable2FABtn && !enable2FABtn.dataset.bound) {
        enable2FABtn.addEventListener('click', () => {
            navigateTo('/enable-2fa');
        });
        enable2FABtn.dataset.bound = true;
    }

    // Bouton Désactiver 2FA
    const disable2FABtn = document.querySelector('#disable-2fa-btn');
    if (disable2FABtn && !disable2FABtn.dataset.bound) {
        disable2FABtn.addEventListener('click', () => {
            navigateTo('/disable-2fa');
        });
        disable2FABtn.dataset.bound = true;
    }

    // Bouton Supprimer le compte
    const deleteAccountBtn = document.querySelector('#delete-account-btn');
    if (deleteAccountBtn && !deleteAccountBtn.dataset.bound) {
        deleteAccountBtn.addEventListener('click', handleDeleteAccount);
        deleteAccountBtn.dataset.bound = true;
    }

    // Sélectionne tous les boutons de langue
    const languageButtons = document.querySelectorAll('button[data-lang]');
    // Ajoute un gestionnaire d'événements à chaque bouton
    languageButtons.forEach(button => {
        if (!button.dataset.bound) { // Empêche les doublons
            button.addEventListener('click', event => {
                event.preventDefault(); // Empêche le comportement par défaut (soumission du formulaire)
                handleLanguageChange(button.dataset.lang); // Récupère la valeur
            });
        button.dataset.bound = true;
        }
    });
}

===== ./accountManagement/handleLanguage.js =====

===== ./accountManagement/index.js =====
// profile/index.js
export { attachProfileEvents } from './events.js';
export { handleAccountsManagement } from './accountsManagement.js';
export { initializeaccountsManagementFormHandlers } from './formHandler.js';
===== ./accountManagement/accountsManagement.js =====
import { requestGet } from "../api/index.js";
import { updateHtmlContent, displayErrorMessage } from "../tools/index.js";
import { initializeaccountsManagementFormHandlers } from "./index.js";
import { showStatusMessage } from "../tools/index.js";
async function loadAccountsManagement() {
    try {
        const response = await requestGet('accounts', 'gestion_profil');
        if (!response) {
            return;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html);
        }
        else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue de gestion de profil.');
        }
        return true;
    } catch (error) {
        console.error('Erreur chargement gestion profil:', error);
        showStatusMessage(error.message || 'Erreur lors du chargement de la vue de gestion de profil.', 'errors');
    }
}

export async function handleAccountsManagement() {
    let accountsManagementLoaded;
    try {
        accountsManagementLoaded = await loadAccountsManagement();
        if (!accountsManagementLoaded) {
            return;
        }
        // Si votre backend renvoie directement du HTML, utilisez-le tel quel.
        // Sinon, adaptez en fonction de ce qui est renvoyé.
        initializeaccountsManagementFormHandlers();
    } catch (error) {
        console.error('Erreur chargement gestion profil:', error);
        showStatusMessage(error.message || 'Erreur lors du chargement de la vue de gestion de profil.', 'errors');
    }
}

===== ./accountManagement/formHandler.js =====
import { requestPost } from '../api/index.js';
import { navigateTo } from '../router.js';
import { showStatusMessage } from '../tools/displayInfo.js';
import { attachProfileEvents } from './events.js';
import { handleNavbar } from '../navbar/index.js';
import { handleLogout } from '../auth/index.js';

// Fonction pour gérer la soumission des formulaires
async function handleFormSubmit(form, app, view, successMessage, successSelector) {
    const formData = new FormData(form);
    try {
        const response = await requestPost(app, view, formData);
        if (response.status === 'success') {
            const successElem = document.querySelector(successSelector);
            if (successElem) {
                successElem.textContent = successMessage;
                successElem.style.display = 'block';
                setTimeout(() => successElem.style.display = 'none', 3000);
            }
            form.reset();
            if (successSelector === '#change-avatar-success') {
                await handleNavbar(); 
            }
            else if (successSelector === '#change-username-success') {
                await handleLogout();
            }
            navigateTo('/account')
           
        } else {
            showStatusMessage(response.message, "error");
        }
    } catch (error) {
        console.error(`Erreur lors de la requête vers ${app}/${view}:`, error);
        showStatusMessage(response.message, "error");
    }
}

// Initialise les gestionnaires pour les formulaires
export function initializeaccountsManagementFormHandlers() {
    document.querySelectorAll('form').forEach((form) => {
        if (!form.hasAttribute('data-handled')) {
            form.addEventListener('submit', async function(e) {
                e.preventDefault();

                switch (form.id) {
                    case 'change-username-form':
                        await handleFormSubmit(form, 'accounts', 'profile/update', 'Pseudo mis à jour!', '#change-username-success');
                        break;
                    case 'change-password-form':
                        await handleFormSubmit(form, 'accounts', 'profile/change_password', 'Mot de passe mis à jour!', '#change-password-success');
                        break;
                    case 'change-avatar-form':
                        await handleFormSubmit(form, 'accounts', 'profile/update_avatar', 'Avatar mis à jour!', '#change-avatar-success');
                        break;
                    case 'delete-account-form':
                        break;
                    default:
                        console.warn('Formulaire non reconnu:', form.id);
                }
            });
            form.setAttribute('data-handled', 'true');
        }
    });

    // Attache les événements spécifiques aux boutons du profil
    attachProfileEvents();
}
    
===== ./api/apiErrors.js =====
//api/apiErrors.js

// Classe de base pour les erreurs spécifiques à la requête
export class RequestError extends Error {
    constructor(message, status = null) {
        super(message);
        this.name = "RequestError";
        this.status = status; // Le code HTTP, si disponible
    }
}

// Erreur pour les réponses HTTP non réussies
export class HTTPError extends RequestError {
    constructor(message, status) {
        super(message, status);
        this.name = "HTTPError";
    }
}

// Erreur pour un problème de format inattendu dans la réponse
export class ContentTypeError extends RequestError {
    constructor(message) {
        super(message);
        this.name = "ContentTypeError";
    }
}

// Erreur pour un problème réseau (fetch lui-même échoue)
export class NetworkError extends RequestError {
    constructor(message) {
        super(message);
        this.name = "NetworkError";
    }
}
===== ./api/index.js =====
// api/index.js
// contient uniquement les fonctions que l' on souhaite appeler depuis d'autres fichiers

export { requestGet, requestPost , requestDelete} from './api.js';
export { RequestError, HTTPError, ContentTypeError, NetworkError } from './apiErrors.js';

===== ./api/api.js =====
import { navigateTo } from '../router.js';
import { HTTPError, ContentTypeError, NetworkError } from './apiErrors.js';
import { showStatusMessage } from '../tools/displayInfo.js';

const Api = {
  /**
   * Effectue une requête HTTP avec fetch en utilisant FormData.
   * @param {string} url - L'URL complète de la ressource.
   * @param {string} method - La méthode HTTP (GET, POST, PUT, DELETE).
   * @param {FormData|null} formData - Les données à envoyer dans le corps de la requête.
   * @param {Object} customHeaders - Headers supplémentaires à ajouter.
   * @returns {Promise} - Une promesse résolue avec les données JSON ou rejetée en cas d'erreur.
   */
  async request(url, method = 'GET', formData = null, customHeaders = {}) {
    try {
      // Prépare et fusionne les en-têtes (CSRF et JWT)
      const headers = { ...this.prepareHeaders(), ...customHeaders };

      // Vérification et renouvellement du token si nécessaire
      const jwtAccessToken = this.getJWTaccessToken();
      if (jwtAccessToken && this.isTokenExpiringSoon(jwtAccessToken)) {
        console.warn('Access token sur le point d\'expirer, tentative de renouvellement...');
        const newToken = await this.handleTokenRefresh();
        if (newToken) {
          headers['Authorization'] = `Bearer ${newToken}`;
        }
      }

      // Envoi de la requête
      let response = await this.sendRequest(url, method, formData, headers);

       // Si la réponse est un 401, on lit le JSON pour distinguer le type d'erreur
       // Gestion des erreurs d'authentification
       if (response.status === 401) {
        const data = await response.json(); // lecture unique
        if (data.error_code === 'not_authenticated') {
          showStatusMessage(data.message, 'error');
          navigateTo(data.redirect);
          return; // On arrête ici
        } else {
          response = await this.handleUnauthorized(url, method, formData, customHeaders);
        }
      } else if (response.status === 403) {
        const data = await response.json(); // lecture unique
        if (data.error_code === 'auth_partial_required') {
          showStatusMessage(data.message, 'error');
          navigateTo(data.redirect);
          return; // On arrête ici
        } else {
          throw new HTTPError(data.message || 'Erreur inconnue.', response.status, data.error_code);
        }
      }
      return await this.handleResponse(response);
    } catch (error) {
      if (error instanceof TypeError) {
        throw new NetworkError('Échec réseau : ' + error.message);
      }
      throw error;
    }
  },

  /**
   * Prépare les en-têtes de la requête avec CSRF et JWT.
   * @returns {Object} - Les en-têtes préparés.
   */
  prepareHeaders() {
    const headers = {
      'X-CSRFToken': this.getCSRFToken(),
    };

    const jwtAccessToken = this.getJWTaccessToken();
    if (jwtAccessToken) {
      headers['Authorization'] = `Bearer ${jwtAccessToken}`;
    }

    return headers;
  },

  /**
   * Vérifie si le token expire dans moins de 5 minutes.
   * @param {string} token - Le token JWT.
   * @returns {boolean} - True si le token expire bientôt.
   */
  isTokenExpiringSoon(token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp - currentTime < 300; // Moins de 5 minutes
    } catch (error) {
      console.error('Erreur lors de la vérification de l\'expiration du token :', error);
      return true;
    }
  },

  /**
   * Envoie une requête fetch avec les paramètres fournis.
   */
  async sendRequest(url, method, formData, headers) {
    return fetch(url, {
      method,
      headers,
      body: method !== 'GET' && formData instanceof FormData ? formData : undefined,
    });
  },

  /**
   * Gère le cas d'une réponse 401 en essayant de rafraîchir le token.
   */
  async handleUnauthorized(url, method, formData, customHeaders) {
    console.warn('Accès non autorisé, tentative de rafraîchissement du token...');
    const newAccessToken = await this.handleTokenRefresh();

    if (newAccessToken) {
      // Mise à jour des en-têtes avec le nouveau token
      const updatedHeaders = {
        ...this.prepareHeaders(),
        ...customHeaders,
        'Authorization': `Bearer ${newAccessToken}`,
      };

      const response = await this.sendRequest(url, method, formData, updatedHeaders);
      if (!response.ok) {
        throw new HTTPError(
          response.statusText || 'Échec après rafraîchissement du token',
          response.status
        );
      }
      return response;
    } else {
      throw new HTTPError('Impossible de rafraîchir le token.', 401);
    }
  },

  /**
   * Rafraîchit le token d'accès en utilisant le refresh token.
   */
  async handleTokenRefresh() {
    const jwtRefreshToken = this.getJWTrefreshToken();
    if (!jwtRefreshToken) {
      console.error('Aucun refresh token disponible.');
      return null;
    }

    try {
      const response = await fetch('/accounts/refreshJwt/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': this.getCSRFToken(),
        },
        body: JSON.stringify({ refresh_token: jwtRefreshToken }),
      });

      if (response.ok) {
        const data = await response.json();
        const newAccessToken = data.access_token;
        localStorage.setItem('access_token', newAccessToken);
        return newAccessToken;
      } else {
        console.error('Erreur lors du rafraîchissement du token :', response.statusText);
        return null;
      }
    } catch (error) {
      console.error('Échec du rafraîchissement du token :', error);
      return null;
    }
  },

  /**
   * Gère la réponse fetch en fonction du type de contenu.
   */
  async handleResponse(response) {
    const contentType = response.headers.get('Content-Type');

    if (response.ok && contentType && contentType.includes('application/json')) {
      return response.json();
    } else if (!response.ok && contentType && contentType.includes('application/json'))
    {

        if (response.status === 302) {
            console.warn('Redirection détectée :', response.url);
            navigateTo(response.url);
            return; // On ne retourne pas de donnée
          }
          console.log("response", response);
        const errorData = await response.json();
        throw new HTTPError(errorData.message || 'Erreur inconnue.', response.status);
    } else {
      console.log("response", response);
      throw new HTTPError('Réponse inattendue.', response.status);
    }
  },

  // --- Fonctions utilitaires pour la gestion des tokens ---

  getCSRFToken() {
    const cookie = document.cookie.split(';').find(c => c.trim().startsWith('csrftoken='));
    return cookie ? cookie.trim().substring('csrftoken='.length) : '';
  },

  getJWTaccessToken() {
    return localStorage.getItem('access_token') || null;
  },

  getJWTrefreshToken() {
    return localStorage.getItem('refresh_token') || null;
  },

  // --- Méthodes pour les requêtes HTTP spécifiques ---

  async get(url) {
    return this.request(url, 'GET');
  },

  async post(url, formData) {
    return this.request(url, 'POST', formData);
  },

  async put(url, formData) {
    return this.request(url, 'PUT', formData);
  },

  async delete(url) {
    return this.request(url, 'DELETE');
  }
};

// --- Fonctions exportées pour simplifier les appels dans d'autres fichiers ---

export async function requestGet(app, view) {
  const url = `/${app}/${view}/`;
  try {
    return await Api.get(url);
  } catch (error) {
    console.error(`Erreur lors du chargement de ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestPost(app, view, formData) {
  const url = `/${app}/${view}/`;
  console.log('POST request URL:', url);
  try {
    return await Api.post(url, formData);
  } catch (error) {
    console.error(`Erreur lors du chargement de ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestDelete(app, view, ressourceId) {
  const url = `/${app}/${view}/${ressourceId}/`;
  try {
    return await Api.delete(url);
  } catch (error) {
    console.error(`Erreur lors de la suppression de ${app}-${view} avec ID ${ressourceId} :`, error);
    throw error;
  }
}

===== ./auth/2fa/2faDisable.js =====
import { requestGet, requestPost } from '/static/js/api/index.js';
import { updateHtmlContent, showStatusMessage } from '/static/js/tools/index.js';
import { navigateTo } from '/static/js/router.js';



// Fonction pour charger la vue de désactivation de la 2FA
async function loadDisable2FAView() {
    console.log('Chargement de la vue de désactivation de la 2FA...');
    try {
        const response = await requestGet('accounts', '2fa/disable');
        if (!response) {
            return false;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html);
            attachDisable2FAEvent(); // Attache l'événement de soumission
        } else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue de désactivation de la 2FA.');
        }
    } catch (error) {
        console.error('Erreur dans loadDisable2FAView:', error);
        showStatusMessage('Impossible de charger la vue de désactivation de la 2FA.', 'error');
        throw error; // Propagation de l'erreur pour gestion dans handleDisable2FA
    }
}

// Fonction pour attacher l'événement de soumission au formulaire
function attachDisable2FAEvent() {
    const disable2FAForm = document.querySelector('#disable-2fa-form');
    if (disable2FAForm) {
        disable2FAForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                await submitDisable2FA(disable2FAForm);
            } catch (error) {
                console.error('Erreur dans submitDisable2FA:', error);
                showStatusMessage('Une erreur est survenue lors de la soumission. Veuillez réessayer.', 'error');
            }
        });
    } else {
        console.error('Formulaire de désactivation 2FA introuvable.');
        showStatusMessage('Formulaire de désactivation introuvable. Veuillez réessayer.', 'error');
    }
}

// Fonction pour soumettre le formulaire de désactivation de la 2FA
async function submitDisable2FA(form) {
    const formData = new FormData(form);
    console.log('Soumission du formulaire de désactivation de la 2FA...');
    try {
        const response = await requestPost('accounts', '2fa/disable', formData);
        if (response.status === 'success') {
            showStatusMessage('La 2FA a été désactivée avec succès.', 'success');
             // 🔥 Ajout de la redirection après désactivation réussie
             setTimeout(() => {
                console.log('setTimeout exécuté, on appelle navigateTo("/account")');
                navigateTo('/account'); // Redirige après 2 secondes
            }, 2000);
        } else {
            throw new Error(response.message || 'Échec de la désactivation de la 2FA.');
        }
    } catch (error) {
        console.error('Erreur dans submitDisable2FA:', error);
        showStatusMessage('Une erreur est survenue lors de la désactivation de la 2FA.', 'error');
        throw error;
    }
}

// Gestionnaire principal pour désactiver la 2FA
export async function handleDisable2FA() {
    console.log('Désactivation de la 2FA...');
    let disable2fa;
    try {
        // Charge la vue de désactivation de la 2FA
        disable2fa = await loadDisable2FAView();
    } catch (error) {
        console.error('Erreur dans handleDisable2FA:', error);
        showStatusMessage('Erreur lors de la désactivation de la 2FA.', 'error');
    }
    if (!disable2fa) {
        return;
    }
}

===== ./auth/2fa/2faEnable.js =====
import { navigateTo } from '/static/js/router.js';
import { requestGet, requestPost } from '/static/js/api/index.js';
import { updateHtmlContent, showStatusMessage } from '/static/js/tools/index.js';

// Gestionnaire principal pour activer la 2FA
export async function handleEnable2FA() {
    console.log('Activation de la 2FA...');
    let enable2FALoaded;
    try {
        enable2FALoaded = await loadEnable2FAView(); // Charge la vue d'activation de la 2FA
    } catch (error) {
        console.error('Erreur dans handleEnable2FA:', error);
        showStatusMessage('Erreur lors de l\'activation de la 2FA.', 'error');
    }

    if (!enable2FALoaded) {
        return;
    }
}

// Fonction pour charger la vue d'activation de la 2FA
async function loadEnable2FAView() {
    try {
        const response = await requestGet('accounts', '2fa/enable');
        if (!response) {
            return false;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html); // Met à jour la vue

            // Attache l'événement de vérification
            attach2FAVerificationEvent();
        } else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue 2FA.');
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la vue 2FA:', error);
        showStatusMessage('Impossible de charger la vue d\'activation de la 2FA.', 'error');
        throw error;
    }
}

// Fonction pour gérer la soumission du formulaire de vérification 2FA
async function verification2FA(event) {
    event.preventDefault(); // Empêche le comportement par défaut

    console.log('Soumission du formulaire de vérification 2FA...');
    const form = event.target;
    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', '2fa/check', formData);
        if (response.status === 'success') {
            showStatusMessage('2FA activée avec succès.', 'success');
             // 🔥 Ajout de la redirection après activation réussie
             setTimeout(() => {
                console.log('setTimeout exécuté, on appelle navigateTo("/account")');
                navigateTo('/account'); // Redirige après 2 secondes (pour voir le message)
            }, 2000);
        } else {
            throw new Error(response.message || 'Code 2FA incorrect.');
        }
    } catch (error) {
        console.error('Erreur lors de la vérification 2FA:', error);
        showStatusMessage('Une erreur est survenue lors de la vérification 2FA.', 'error');
        throw error;
    }
}

// Fonction pour attacher l'événement de vérification
function attach2FAVerificationEvent() {
    const verifyForm = document.querySelector('#verify-2fa-form');
    if (verifyForm) {
        verifyForm.addEventListener('submit', async (event) => {
            try {
                await verification2FA(event); // Gère la soumission du formulaire
            } catch (error) {
                console.error('Erreur lors de la vérification 2FA dans attach2FAVerificationEvent:', error);
                showStatusMessage('Une erreur est survenue lors de la vérification 2FA.', 'error');
            }
        });
        console.log('Événement de vérification 2FA attaché.');
    } else {
        console.error('Formulaire de vérification 2FA introuvable.');
        showStatusMessage('Formulaire de vérification introuvable. Veuillez réessayer.', 'error');
    }
}

===== ./auth/2fa/2faLogin.js =====
import { requestPost, requestGet } from '../../api/index.js';
import { handleNavbar } from '../../navbar/index.js'; // Adjust the import path as necessary
import { updateHtmlContent, showStatusMessage } from '../../tools/index.js'; // Adjust the import path as necessary
import { navigateTo } from '../../router.js';

// Soumission du formulaire de connexion 2FA
async function submitLogin2FA(form) {
    const formData = new FormData(form);
    try {
        const response = await requestPost('accounts', '2fa/login2fa', formData);
        if (response.status === 'success') {
            console.log("2FA activée avec succès");
            localStorage.setItem('access_token', response.access_token);
            localStorage.setItem('refresh_token', response.refresh_token);

            setTimeout(async () => {
                window.isAuthenticated = true;
                await handleNavbar();
                navigateTo('/home');
            }, 500);
            showStatusMessage('Connexion 2FA réussie.', 'success');
        } else {
            throw new Error(response.message || 'Code 2FA incorrect.');
        }
    } catch (error) {
        console.error('Erreur lors de la soumission 2FA:', error);
        showStatusMessage(error.message || 'Une erreur est survenue lors de la connexion 2FA.', 'error');
    }
}

// Initialisation de la vue de connexion 2FA
export async function initializeLogin2FAView() {

    try {
        const data = await requestGet('accounts', '2fa/login2fa');
        if (!data) {
            return;
        }
        updateHtmlContent('#content', data.html);
    } catch (error) {
        console.error('Erreur lors de la requête API initializeLogin2FAView:', error);
        showStatusMessage('Impossible de charger la vue de connexion 2FA.', 'error');
        return;
    }

    document.addEventListener('submit', function (e) {
        if (e.target && e.target.id === 'login-2fa-form') {
            e.preventDefault();
            submitLogin2FA(e.target);
        }
    });
}

===== ./auth/index.js =====
// auth/index.js

// Fonctions de déconnexion et suppression de compte
// Appelle une fonction générique pour nettoyer la session utilisateur
export { handleLogout} from './logout.js';
export { handleDeleteAccount } from './deleteAccount.js';

export { handleLogin } from './login.js';
export { initializeRegisterView } from './register.js';


// Export des vues 2FA
export { handleEnable2FA} from './2fa//2faEnable.js';
export { initializeLogin2FAView } from './2fa/2faLogin.js';
export { handleDisable2FA } from './2fa/2faDisable.js';

===== ./auth/deleteAccount.js =====
import { requestPost } from '../api/index.js';
import { clearSessionAndUI, showStatusMessage} from '../tools/index.js';

// Charge et affiche la modale de suppression
async function loadDeleteAccountView() {
    console.log('Chargement de la vue de suppression...');
    try {
        const modal = document.getElementById('delete-account-modal');
        if (!modal) {
            throw new Error('La modale de suppression du compte est introuvable.');
        }
        modal.style.display = 'flex'; // Affiche la modale
    } catch (error) {
        console.error('Erreur dans loadDeleteAccountView:', error);
        showStatusMessage('Impossible de charger la vue de suppression. Veuillez réessayer.', 'error');
        throw error;
    }
}

// Attache les événements nécessaires à la modale de suppression
async function attachDeleteAccountEvents() {
    console.log('Attachement des événements pour la suppression du compte...');
    try {
        const modal = document.getElementById('delete-account-modal');
        const closeBtn = modal.querySelector('.close-btn');
        const deleteAccountForm = document.getElementById('delete-account-form');

        // Fermer la modale via le bouton de fermeture
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
        }

        // Fermer la modale en cliquant en dehors de son contenu
        window.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Gestion de la soumission du formulaire de suppression
        if (deleteAccountForm) {
            deleteAccountForm.addEventListener('submit', async (event) => {
                event.preventDefault(); // Empêche le comportement par défaut
                await submitDeleteAccount(deleteAccountForm);
            });
        }
    } catch (error) {
        console.error('Erreur dans attachDeleteAccountEvents:', error);
        showStatusMessage('Erreur lors de l\'attachement des événements de suppression.', 'error');
        throw error;
    }
}

// Soumet la requête de suppression de compte
async function submitDeleteAccount(form) {
    const formData = new FormData(form);
    console.log('Soumission du formulaire de suppression de compte...');

    try {
        const response = await requestPost('accounts', 'profile/delete_account', formData);

        if (response.status !== 'success') {
            console.error('Erreur serveur :', response.message);
            showStatusMessage(response.message || 'Erreur lors de la suppression du compte.', 'error');
            return;
        }

        showStatusMessage('Votre compte a été supprimé avec succès.', 'success');

        setTimeout(() => {
            clearSessionAndUI();
        }, 1500);
    } catch (error) {
        console.error('Erreur lors de la soumission de la suppression du compte :', error);
        showStatusMessage('Une erreur est survenue. Veuillez réessayer.', 'error');
    }
}

// Gestionnaire principal pour la suppression de compte
export async function handleDeleteAccount() {
    console.log('Suppression du compte...');
    try {
        await loadDeleteAccountView(); // Charge et affiche la modale de suppression
        await attachDeleteAccountEvents();
    } catch (error) {
        console.error('Erreur dans handleDeleteAccount:', error);
        showStatusMessage('Erreur lors de la tentative de suppression du compte.', 'error');
    }
}

===== ./auth/logout.js =====
import { clearSessionAndUI, showStatusMessage } from '../tools/index.js';
import { requestPost } from '../api/index.js';

async function logoutUser() {
    try {
        const formData = new FormData();
        const refreshToken = localStorage.getItem('refresh_token');
        if (!refreshToken) {
            throw new Error('Aucun refresh token trouvé.');
        }
        formData.append('refresh_token', refreshToken);
        const response = await requestPost('accounts', 'logout', formData);

        if (response.status !== 'success') {
            throw new Error('La déconnexion a échoué côté serveur.');
        }
        return response;
    } catch (error) {
        console.error('Erreur lors de logoutUser :', error);
        throw error;
    }
}

export async function handleLogout() {
    console.log('Déconnexion en cours...');
    try {
        await logoutUser();
        showStatusMessage('Votre compte a été déconnecté avec succès.', 'success');
        setTimeout(() => {
            clearSessionAndUI();
        }, 1500);
        console.log('Déconnexion réussie.');
    } catch (error) {
        console.error('Erreur lors de la déconnexion :', error);
        showStatusMessage('La déconnexion a échoué. Veuillez réessayer.', 'error');
    }
}

===== ./auth/register.js =====
// auth/register.js
import { requestPost, requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

function handleRegisterResponse(response) {
    if (response.status === 'success') {
        showStatusMessage(response.message, 'success');
        navigateTo('/login');
    } else {
        showStatusMessage(response.message, 'error');
    }
}

async function submitRegistration(form) {
    const submitBtn = document.querySelector('#submit-btn');
    submitBtn.disabled = true;
    submitBtn.textContent = 'Inscription en cours...';

    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', 'submit_register', formData);
        console.log('Réponse de la requête POST submit_register :', response);
        handleRegisterResponse(response);
        
    } catch (error) {
        console.error('Erreur lors de l\'inscription :', error);
        showStatusMessage('Une erreur est survenue lors de l\'inscription. Veuillez réessayer.', 'error');
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'S\'inscrire';
    }
}

// MAIN FUNCTION
export async function initializeRegisterView() {
    console.log('initializeRegisterView');

    try {
        const data = await requestGet('accounts', 'register');
        updateHtmlContent('#content', data.html);

        const form = document.querySelector('#register-form');
        if (form) {
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                submitRegistration(form);
            });
        }
    } catch (error) {
        console.error('Erreur lors de la requête API initializeRegisterView :', error);
        showStatusMessage('Impossible de charger la vue d\'inscription. Veuillez réessayer.', 'error');
    }
}

===== ./auth/login.js =====
import { requestGet, requestPost } from '../api/index.js';
import { handleNavbar } from '../navbar/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer


async function handleLoginResponse(response) {
    console.log('handleLoginResponse');
    if (response.status === 'success') {
        if (response.requires_2fa) {
            navigateTo('/login-2fa');
        } else {
            console.log("Access token = ", response.access_token);
            localStorage.setItem('access_token', response.access_token);
            localStorage.setItem('refresh_token', response.refresh_token);

            setTimeout(async () => {
                window.isAuthenticated = true;
                console.log("handleloginResponse isauthenticated = :", window.isAuthenticated)
                await handleNavbar();
                navigateTo('/home');
            }, 500);
        }
    } else {
        showStatusMessage(response.message, 'error');
    }
}

async function submitLogin(form) {
    console.log('submitLogin');
    const validateBtn = document.querySelector('#validate-btn');
    validateBtn.disabled = true;
    validateBtn.textContent = 'Connexion...';

    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', 'submit_login', formData);
        console.log('Réponse de la requête POST submit_login :', response);
        return response;
    } catch (error) {
        console.error('Erreur lors de la connexion :', error);
        showStatusMessage('Une erreur est survenue. Veuillez réessayer.', 'error');
        return null;
    } finally {
        validateBtn.disabled = false;
        validateBtn.textContent = 'Valider';
    }
}

async function initializeLoginForm() {
    try {
        const data = await requestGet('accounts', 'login');
        updateHtmlContent('#content', data.html);

        const form = document.querySelector('#login-form');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('Soumission du formulaire de connexion');
                const response = await submitLogin(form);
                if (response) {
                    await handleLoginResponse(response);
                }
            });
        }
    } catch (error) {
        console.error('Erreur lors de l\'initialisation du formulaire :', error);
        showStatusMessage('Impossible de charger la vue de connexion. Veuillez réessayer.', 'error');
    }
}

export async function handleLogin() {
    
    try {
        console.log('Initialisation de la vue de connexion');
        await initializeLoginForm();
        console.log('Vue de connexion initialisée avec succès');
    } catch (error) {
        console.error('Erreur dans handleLogin :', error);
        showStatusMessage('Erreur lors de l\'initialisation de la connexion.', 'error');
    }
}

===== ./burgerMenu/events.js =====


import { 
    showFriendPopup, 
    closePopupOnClickOutside, 
    handleOptionPopup,  
    handleAddFriend, 
    handleFriendInvitation  
} from '../friends/index.js';

import { handleStatusChange } from './index.js';
import { handleLogout } from '../auth/index.js';
import { navigateTo } from '../router.js';
import { acceptGameInvitation } from '../game/index.js';
import { declineGameInvitation } from '../game/onlineGame.js';

/**
 * Gestionnaire principal des événements pour le menu burger via event delegation.
 * - Attache un seul listener "click" sur #burger-menu-container.
 * - Gère aussi le "submit" du formulaire d'ajout d'amis.
 */
export function eventsHandlerBurgerMenu() {
    console.log('Initialisation des gestionnaires d\'événements (event delegation)...');

    // 1. Récupérer le conteneur principal du burger menu
    const container = document.getElementById('burger-menu-container');
    if (!container) {
        console.warn("Impossible de trouver #burger-menu-container, annulation des events burger.");
        return;
    }

    // 2. Attacher UN SEUL listener "click" si pas déjà fait
    if (!container.dataset.bound) {
        container.addEventListener('click', handleBurgerMenuClick);
        container.dataset.bound = 'true';
        console.log("Listener 'click' sur #burger-menu-container initialisé.");
    }

    // 3. Gérer la soumission du formulaire d'ajout d'amis (événement "submit" distinct)
    const addFriendForm = document.querySelector('#add-friend-form');
    if (addFriendForm && !addFriendForm.dataset.bound) {
        addFriendForm.addEventListener('submit', handleAddFriend);
        addFriendForm.dataset.bound = 'true';
        console.log("Event 'submit' pour #add-friend-form attaché.");
    }

    // 4. Gérer la fermeture du popup d'ami au clic en dehors (hors du container burger)
    //    Ici, on peut écouter sur document ou sur un autre élément.
    const popup = document.getElementById('friendPopup');
    if (popup && !popup.dataset.bound) {
        document.addEventListener('click', closePopupOnClickOutside);
        popup.dataset.bound = 'true';
        console.log("Listener 'click' pour fermer le friendPopup en dehors.");
    }

    console.log('Event delegation pour le burger menu : terminé.');
}

/**
 * Fonction centrale qui gère tous les clics à l'intérieur de #burger-menu-container.
 */
function handleBurgerMenuClick(e) {
    // 1. Changement de statut (en ligne/hors ligne)
    //    Les boutons ont la classe .status-selector et un data-status
    if (e.target.matches('.status-selector button[data-status]')) {
        const status = e.target.dataset.status;
        if (status) handleStatusChange(status);
        return;
    }

    // 2. Bouton "Voir le profil" (#profile-btn)
    if (e.target.matches('#profile-btn')) {
        e.preventDefault();
        console.log('Profil bouton cliqué');
        navigateTo('/profile');
        return;
    }

    // 3. Navigation : Jouer (#play-btn), Tournoi (#tournament-link), Paramètres (#settings-link)
    if (e.target.matches('#play-btn')) {
        e.preventDefault();
        navigateTo('/game-options');
        return;
    }
    if (e.target.matches('#settings-link')) {
        e.preventDefault();
        navigateTo('/account');
        return;
    }

    // 4. Liste d'amis -> .friend-btn
    //    e.target.closest('.friend-btn') => ouvre un popup
    const friendButton = e.target.closest('.friend-btn');
    if (friendButton) {
        showFriendPopup(e, friendButton.innerText.trim());
        return;
    }

    // 5. Invitations d'amis (#friend-requests-list-container) -> bouton[data-request-id]
    //    on récupère l'ID et l'action (accepter/refuser)
    const friendRequestButton = e.target.closest('#friend-requests-list-container button[data-request-id]');
    if (friendRequestButton) {
        const requestId = friendRequestButton.getAttribute('data-request-id');
        const action = friendRequestButton.getAttribute('data-action');
        if (requestId) {
            handleFriendInvitation(requestId, action);
        }
        return;
    }

    // 6. Invitations de jeu (#game-invitations-list-container) -> bouton[data-invitation-id]
    const gameInvitationButton = e.target.closest('#game-invitations-list-container button[data-invitation-id]');
    if (gameInvitationButton) {
        const invitationId = gameInvitationButton.getAttribute('data-invitation-id');
        const action = gameInvitationButton.getAttribute('data-action');
        if (invitationId && action === 'accept') {
            acceptGameInvitation(invitationId, action);
        }
        else {
            declineGameInvitation(invitationId);
        }
        return;
    }

    // 7. Boutons du popup d'ami (voir profil, inviter à jouer, supprimer) => #view-profile-btn, #invite-to-play-btn, #remove-friend-btn
    if (e.target.matches('#view-profile-btn')) {
        handleOptionPopup('Voir le profil');
        return;
    }
    if (e.target.matches('#invite-to-play-btn')) {
        handleOptionPopup('Inviter à jouer');
        return;
    }
    if (e.target.matches('#remove-friend-btn')) {
        handleOptionPopup('Supprimer');
        return;
    }

    // 8. Bouton de déconnexion (#logout-btn)
    if (e.target.matches('#logout-btn')) {
        e.preventDefault();
        handleLogout();
        return;
    }

    // Si aucun des cas ci-dessus n'est matché, on ne fait rien de particulier.
    // console.log("Clic dans burger-menu-container, mais cible non gérée:", e.target);
}

===== ./burgerMenu/index.js =====
export { eventsHandlerBurgerMenu } from "./events.js";
export { handleStatusChange } from "./setupStatus.js";

===== ./burgerMenu/setupStatus.js =====
import { requestPost } from '../api/index.js';
import { refreshBurgerMenu } from '../navbar/loadNavbar.js';
import { showStatusMessage } from '../tools/index.js';

async function updateUserStatus(status) {
    console.log('Mise à jour du statut utilisateur :', status);

    const formData = new FormData();
    formData.append('status', status);

    try {
        const response = await requestPost('accounts', 'burgerMenu/update-status', formData);
        if (response.status !== 'success') {
            throw new Error(response.message || 'Erreur inconnue lors de la mise à jour du statut.');
        }
        console.log(`Statut mis à jour avec succès : ${status}`);
        return response; // Retourne la réponse pour une éventuelle utilisation
    } catch (error) {
        console.error('Erreur dans updateUserStatus :', error);
        throw error; // Relance l'erreur pour la gérer ailleurs
    }
}

// Improve ajouter un refresh burger menu
export async function handleStatusChange(status) {
    try {
        await updateUserStatus(status);
        showStatusMessage('Statut mis à jour avec succès.', 'success');
        console.log('Statut mis à jour avec succès dans l\'interface utilisateur.');
    } catch (error) {
        console.error('Erreur lors de la mise à jour du statut :', error);
        showStatusMessage('Impossible de mettre à jour le statut. Veuillez réessayer.', 'error');
    }
    await refreshBurgerMenu();//added
}

===== ./friends/friendsAction/friendsInvitations.js =====
import { requestPost } from '../../api/index.js';
import {showStatusMessage} from '../../tools/index.js';

async function friendInvitation(requestId, action) {
    console.log(`handleFriendRequestAction: Demande d'ami ID ${requestId}, action : ${action}`);

    const formData = new FormData();
    formData.append('request_id', requestId);
    formData.append('action', action);

    try {
        const response = await requestPost('accounts', 'friends/handle-request', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors du traitement de la demande d\'ami.';
            console.error('Erreur dans friendInvitation:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Erreur dans friendInvitation:', error);
        throw error;
    }
}

export async function handleFriendInvitation(requestId, action) {
    console.log(`Gestionnaire: handleFriendRequest - ID : ${requestId}, action : ${action}`);
    try {
        const response = await friendInvitation(requestId, action);
        showStatusMessage(response.message || 'Demande d\'ami traitée avec succès.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Erreur lors du traitement de la demande d\'ami.';
        console.error('Erreur dans handleFriendInvitation:', error);
        showStatusMessage(errorMessage, 'error');
    }
}
===== ./friends/friendsAction/friendProfile.js =====
import { requestGet } from '../../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../../tools/index.js';


async function FriendProfile(friendName) {
    try {
        console.log(`Chargement du profil de l'ami : ${friendName}`);
        const response = await requestGet('accounts', `friend/${friendName}`);

        if (!response) {
            return;
        }
        if (response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors de la récupération du profil.';
            console.error('Erreur dans FriendProfile :', errorMessage);
            throw new Error(errorMessage);
        }

        updateHtmlContent('#content', response.html);
        return response.message;
    } catch (error) {
        console.error('Erreur dans FriendProfile :', error);
        throw error;
    }
}

export async function handleFriendProfile(friendName) {
    console.log(`Gestionnaire: Affichage du profil de l'ami ${friendName}`);

    try {
        const response = await FriendProfile(friendName);
        if (!response) {
            return;
        }
        showStatusMessage(response || 'Profil de l\'ami chargé avec succès.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Erreur lors de la récupération du profil.';
        console.error('Erreur dans handleFriendProfile :', error);
        showStatusMessage(errorMessage, 'error');
    }
}

===== ./friends/friendsAction/addFriend.js =====
import { requestPost } from '../../api/index.js';
import { showStatusMessage } from '../../tools/index.js';

async function addFriend(friendUsername) {
    console.log('addFriend:', friendUsername);

    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    try {
        const response = await requestPost('accounts', 'friends/add', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur inconnue lors de l\'ajout de l\'ami.';
            console.error('Erreur dans addFriend:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Exception dans addFriend:', error);
        throw error; // Relance l'erreur pour qu'elle soit gérée ailleurs
    }
}

export async function handleAddFriend(e) {
    e.preventDefault();
    console.log('Gestionnaire: handleAddFriend - Ajout d\'un ami');
    const friendUsernameInput = document.querySelector('#friend-username');
    const addFriendButton = document.querySelector('#add-friend-button'); // Sélectionnez le bouton d'ajout d'ami

    if (!friendUsernameInput || !addFriendButton) {
        showStatusMessage('Champ utilisateur ou bouton introuvable.', 'error');
        return;
    }

    const friendUsername = friendUsernameInput.value.trim();

    if (!friendUsername) {
        showStatusMessage('Le nom d\'utilisateur ne peut pas être vide.', 'error');
        return;
    }

    console.log('Gestionnaire: handleAddFriend - Ajout d\'un ami:', friendUsername);

    try {
        addFriendButton.disabled = true; // Désactivez le bouton pendant la soumission
        await addFriend(friendUsername);
        showStatusMessage('Demande d\'ami envoyée avec succès.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Une erreur inattendue est survenue.';
        console.error('Erreur dans handleAddFriend:', error);
        showStatusMessage(errorMessage, 'error');
    } finally {
        addFriendButton.disabled = false; // Réactivez le bouton après la soumission
    }
}

===== ./friends/friendsAction/removeFriend.js =====
import { requestPost } from '../../api/index.js';
import {showStatusMessage} from '../../tools/index.js';

async function removeFriend(friendName) {
    console.log(`removeFriend: Suppression de l'ami ${friendName}`);

    const formData = new FormData();
    formData.append('friend_username', friendName);

    try {
        const response = await requestPost('accounts', 'friends/remove', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors de la suppression de l\'ami.';
            console.error('Erreur dans removeFriend:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Erreur dans removeFriend:', error);
        throw error;
    }
}

// export async function handleRemoveFriend(friendName) {
//     console.log(`Gestionnaire: handleRemoveFriend - Suppression de l'ami : ${friendName}`);
//     try {
//         const response = await removeFriend(friendName);
//         document.querySelector(`.friend-btn:contains('${friendName}')`)?.closest('.friend-item')?.remove();
//         showStatusMessage(response.message || 'Ami supprimé avec succès.', 'success');
//     } catch (error) {
//         const errorMessage = error?.message || 'Une erreur est survenue lors de la suppression de l\'ami.';
//         console.error('Erreur dans handleRemoveFriend:', error);
//         showStatusMessage(errorMessage, 'error');
//     }
// }
export async function handleRemoveFriend(friendName) {
    console.log(`Gestionnaire: handleRemoveFriend - Suppression de l'ami : ${friendName}`);
    try {
        const response = await removeFriend(friendName);
        
        // Select all elements with class '.friend-btn'
        const friendButtons = document.querySelectorAll('.friend-btn');
        
        // Loop through each friend button to find and remove the correct one
        friendButtons.forEach(button => {
            if (button.textContent.includes(friendName)) {
                button.closest('.friend-item').remove();
            }
        });
        
        showStatusMessage(response.message || 'Ami supprimé avec succès.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Une erreur est survenue lors de la suppression de l\'ami.';
        console.error('Erreur dans handleRemoveFriend:', error);
        showStatusMessage(errorMessage, 'error');
    }
}
===== ./friends/index.js =====

// Fonction qui permet de gérer les actions liées aux amis
export { handleAddFriend } from "./friendsAction/addFriend.js";
export { handleFriendProfile } from "./friendsAction/friendProfile.js";
export { handleFriendInvitation } from "./friendsAction/friendsInvitations.js";
export { handleRemoveFriend } from "./friendsAction/removeFriend.js";

// Fonction qui permet de gérer les événements liés au popup de la liste d'amis
export { handleOptionPopup } from "./popupFriend/handlePopupOption.js";

// Fonction qui permet de gérer la mécanique du popup de la liste d'amis
export { showFriendPopup, closePopupOnClickOutside  } from "./popupFriend/popupMechanics.js";



===== ./friends/popupFriend/handlePopupOption.js =====
import {  handleRemoveFriend } from '../index.js';
import { navigateTo } from '../../router.js';

export function handleOptionPopup(option) {
    console.log('Option popup cliquée' + option);
    const friendName = document.getElementById('popupFriendName').innerText.trim();
    console.log(`Option: ${option}, Friend: ${friendName}`); // Ajout de log

    if (option === 'Voir le profil') {
        const encodedName = encodeURIComponent(friendName);
        console.log(`Encoded friendName: ${encodedName}`);
        navigateTo(`/profile/${encodedName}`);
    } 
    else if (option === 'Inviter à jouer') {

        console.log(`Option sélectionnée : ${option}`);
    }
    else if (option === 'Supprimer') {
        handleRemoveFriend(friendName);
    }
    else {
        console.error(`Option inconnue : ${option}`);
    }
}

===== ./friends/popupFriend/popupMechanics.js =====
// Gère la mécanique du popup d'ami

export function showFriendPopup(event, friendName) {
    event.stopPropagation();
    const popup = document.getElementById('friendPopup');
    document.getElementById('popupFriendName').innerText = friendName;

    popup.classList.remove('d-none');
    const popupWidth = popup.offsetWidth;
    const popupHeight = popup.offsetHeight;

    const menu = document.getElementById('burger-menu');

    let top, left;

	const menuRect = menu.getBoundingClientRect();
	const mouseX = event.clientX - menuRect.left + menu.scrollLeft;
	const mouseY = event.clientY - menuRect.top + menu.scrollTop;


	if (mouseX >= 240 && event.clientY <= 250) {
		top = mouseY + popupHeight;
		left = mouseX - (popupWidth / 2);
	} else if (mouseX <= 240 && event.clientY <= 250) {
		top = mouseY + popupHeight;
		left = mouseX + (popupWidth / 2);
	} else if (mouseX <= 240 && event.clientY >= 250) {
		top = mouseY;
		left = mouseX + (popupWidth / 2);
	} else {
		top = mouseY;
		left = mouseX - (popupWidth / 2);
	}
	
    popup.style.top = `${top}px`;
    popup.style.left = `${left}px`;
}

export function closePopupOnClickOutside(event) {
    const popup = document.getElementById('friendPopup');
    if (!popup.contains(event.target) && !event.target.closest('.friend-item')) {
        popup.classList.add('d-none');
    }
}


===== ./game/controls.js =====
// game/controls.js


export function initializeGameControls(controlType) {
    const player = document.querySelector('.player');
    const gameContainer = document.querySelector('.game-container');
    const tutorialBox = document.querySelector('.tutorial-box');
    let containerWidth = gameContainer.offsetWidth;
    let containerHeight = gameContainer.offsetHeight - 50;
    const collectibleCount = 9;
    const collectibles = [];
    let direction = { x: 1, y: 0 }; // Par défaut, déplacement vers la droite
    const playerSpeed = 3;
    let playerX = 0;
    let playerY = containerHeight / 2 - 15; // Milieu vertical
    const keysPressed = {}; // Stocke les touches enfoncées
    let lastDiagonalDirection = null; // Stocke la dernière direction diagonale
    let touchStartX = null; // Stocke la position X du toucher initial
    let touchStartY = null; // Stocke la position Y du toucher initial

    // Calcul des dimensions de la box
    const tutorialRect = {
        left: 0,
        top: 0,
        right: tutorialBox.offsetWidth,
        bottom: tutorialBox.offsetHeight,
    };

    // Initialisation de la position du joueur
    player.style.left = `${playerX}px`;
    player.style.top = `${playerY}px`;

    // Fonction pour éviter que les collectibles ne sortent du conteneur pendant un redimensionnement
	function updateContainerDimensions() {
		containerWidth = gameContainer.offsetWidth;
		containerHeight = gameContainer.offsetHeight - 50;
	
		// Mettre à jour les dimensions dynamiques de la tutorial-box
		tutorialRect.left = tutorialBox.offsetLeft;
		tutorialRect.top = tutorialBox.offsetTop;
		tutorialRect.right = tutorialBox.offsetLeft + tutorialBox.offsetWidth;
		tutorialRect.bottom = tutorialBox.offsetTop + tutorialBox.offsetHeight;
	
		// Réajuster les collectibles pour rester dans les limites du conteneur
		collectibles.forEach((collectible) => {
			let collectibleX = parseFloat(collectible.style.left);
			let collectibleY = parseFloat(collectible.style.top);
	
			// Si le collectible est hors des nouvelles limites, repositionner
			if (collectibleX + 30 > containerWidth) {
				collectibleX = containerWidth - 30;
			}
			if (collectibleY + 30 > containerHeight) {
				collectibleY = containerHeight - 30;
			}
	
			// Si le collectible est dans la zone de la tutorial-box
			if (
				collectibleX + 30 > tutorialRect.left &&
				collectibleX < tutorialRect.right &&
				collectibleY + 30 > tutorialRect.top &&
				collectibleY < tutorialRect.bottom
			) {
				// Répositionner autour de la tutorial-box en fonction de l’espace disponible
				const spaceLeft = tutorialRect.left;
				const spaceRight = containerWidth - tutorialRect.right;
				const spaceTop = tutorialRect.top;
				const spaceBottom = containerHeight - tutorialRect.bottom;
	
				if (spaceRight >= 30) {
					// Place le collectible à droite
					collectibleX = tutorialRect.right + 1;
					collectibleY = Math.random() * (containerHeight - 30);
					collectibleY = Math.max(
						Math.min(collectibleY, containerHeight - 30),
						0
					);
				} else if (spaceLeft >= 30) {
					// Place le collectible à gauche
					collectibleX = tutorialRect.left - 30 - 1;
					collectibleY = Math.random() * (containerHeight - 30);
					collectibleY = Math.max(
						Math.min(collectibleY, containerHeight - 30),
						0
					);
				} else if (spaceBottom >= 30) {
					// Place le collectible en bas
					collectibleY = tutorialRect.bottom + 1;
					collectibleX = Math.random() * (containerWidth - 30);
					collectibleX = Math.max(
						Math.min(collectibleX, containerWidth - 30),
						0
					);
				} else if (spaceTop >= 30) {
					// Place le collectible en haut
					collectibleY = tutorialRect.top - 30 - 1;
					collectibleX = Math.random() * (containerWidth - 30);
					collectibleX = Math.max(
						Math.min(collectibleX, containerWidth - 30),
						0
					);
				} else {
					// Si aucune place n'est disponible, masquer le collectible
					collectible.style.display = 'none';
					return;
				}
			}
	
			// Vérifier que le collectible reste dans les limites visibles du conteneur
			collectibleX = Math.min(
				Math.max(collectibleX, 0),
				containerWidth - 30
			);
			collectibleY = Math.min(
				Math.max(collectibleY, 0),
				containerHeight - 30
			);
	
			// Appliquer les nouvelles positions
			collectible.style.left = `${collectibleX}px`;
			collectible.style.top = `${collectibleY}px`;
	
			// Si l'écran est tellement réduit que seule la tutorial-box est visible
			if (
				containerWidth <= tutorialRect.right &&
				containerHeight <= tutorialRect.bottom
			) {
				collectible.style.display = 'none'; // Cacher les collectibles
			} else {
				collectible.style.display = ''; // Réafficher normalement sinon
			}
		});
	
		// Maintenir le joueur dans les limites du conteneur
		if (playerX + player.offsetWidth > containerWidth) {
			playerX = containerWidth - player.offsetWidth;
		}
		if (playerY + player.offsetHeight > containerHeight) {
			playerY = containerHeight - player.offsetHeight;
		}
		if (playerX < 0) {
			playerX = 0;
		}
		if (playerY < 0) {
			playerY = 0;
		}
	
		player.style.left = `${playerX}px`;
		player.style.top = `${playerY}px`;
	}
	

    function createCollectibles() {
        collectibles.forEach((col) => col.remove()); // Supprime les collectibles existants
        collectibles.length = 0;

        for (let i = 0; i < collectibleCount; i++) {
            let collectible;
            let isValidPosition = false;

            while (!isValidPosition) {
                collectible = document.createElement('div');
                collectible.className = 'collectible';
                const randomX = Math.random() * (containerWidth - 30);
                const randomY = Math.random() * (containerHeight - 30);

                // Vérifie que le collectible n'est pas dans la zone de la tutorial-box
                if (
                    !(
                        randomX >= tutorialRect.left &&
                        randomX <= tutorialRect.right &&
                        randomY >= tutorialRect.top &&
                        randomY <= tutorialRect.bottom
                    )
                ) {
                    isValidPosition = true;
                    collectible.style.left = `${randomX}px`;
                    collectible.style.top = `${randomY}px`;
                    gameContainer.appendChild(collectible);
                    collectibles.push(collectible);
                }
            }
        }
    }

    function movePlayer() {
        const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
        const normalizedDirection = {
            x: (direction.x / length) * playerSpeed,
            y: (direction.y / length) * playerSpeed,
        };

        playerX += normalizedDirection.x;
        playerY += normalizedDirection.y;

        if (playerX < 0) {
            playerX = containerWidth - player.offsetWidth;
        } else if (playerX > containerWidth - player.offsetWidth) {
            playerX = 0;
        }

        if (playerY < 0) {
            playerY = containerHeight - player.offsetHeight;
        } else if (playerY > containerHeight - player.offsetHeight) {
            playerY = 0;
        }

        // Empêcher le joueur d'entrer dans la zone de la tutorial-box
        if (
            playerX + player.offsetWidth >= tutorialRect.left &&
            playerX <= tutorialRect.right &&
            playerY + player.offsetHeight >= tutorialRect.top &&
            playerY <= tutorialRect.bottom
        ) {
            // Vérifier la direction pour rebondir correctement
            if (direction.x > 0) {
                playerX = tutorialRect.right; // Sortir par la droite
            } else if (direction.x < 0) {
                playerX = tutorialRect.left - player.offsetWidth; // Sortir par la gauche
            }

            if (direction.y > 0) {
                playerY = tutorialRect.bottom; // Sortir par le bas
            } else if (direction.y < 0) {
                playerY = tutorialRect.top - player.offsetHeight; // Sortir par le haut
            }
        }

        player.style.left = `${playerX}px`;
        player.style.top = `${playerY}px`;

        collectibles.forEach((collectible, index) => {
            const collectibleRect = collectible.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();

            if (
                playerRect.left < collectibleRect.right &&
                playerRect.right > collectibleRect.left &&
                playerRect.top < collectibleRect.bottom &&
                playerRect.bottom > collectibleRect.top
            ) {
                collectible.remove();
                collectibles.splice(index, 1);

                if (collectibles.length === 0) {
                    setTimeout(createCollectibles, 500);
                }
            }
        });
    }

    // Gestion des contrôles clavier
    function updateDirection() {
        if (keysPressed['ArrowUp'] && keysPressed['ArrowLeft']) {
            direction = { x: -1, y: -1 };
            lastDiagonalDirection = { x: -1, y: -1 };
        } else if (keysPressed['ArrowUp'] && keysPressed['ArrowRight']) {
            direction = { x: 1, y: -1 };
            lastDiagonalDirection = { x: 1, y: -1 };
        } else if (keysPressed['ArrowDown'] && keysPressed['ArrowLeft']) {
            direction = { x: -1, y: 1 };
            lastDiagonalDirection = { x: -1, y: 1 };
        } else if (keysPressed['ArrowDown'] && keysPressed['ArrowRight']) {
            direction = { x: 1, y: 1 };
            lastDiagonalDirection = { x: 1, y: 1 };
        } else if (keysPressed['ArrowUp']) {
            direction = { x: 0, y: -1 };
        } else if (keysPressed['ArrowDown']) {
            direction = { x: 0, y: 1 };
        } else if (keysPressed['ArrowLeft']) {
            direction = { x: -1, y: 0 };
        } else if (keysPressed['ArrowRight']) {
            direction = { x: 1, y: 0 };
        } else if (lastDiagonalDirection) {
            direction = lastDiagonalDirection;
        }
        lastDiagonalDirection = direction;
    }

    function handleTouchStart(event) {
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
    }

    function handleTouchMove(event) {
        if (!touchStartX || !touchStartY) return;

        const touchEndX = event.touches[0].clientX;
        const touchEndY = event.touches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;

        const threshold = 5;

        if (Math.abs(diffX) > Math.abs(diffY)) {
            direction = { x: diffX > 0 ? 1 : -1, y: 0 };
        } else {
            direction = { x: 0, y: diffY > 0 ? 1 : -1 };
        }

        touchStartX = touchEndX;
        touchStartY = touchEndY;
    }

    if (controlType === 'keyboard') {
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
            updateDirection();
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });
    }

    function gameLoop() {
        movePlayer();
        requestAnimationFrame(gameLoop);
    }

    if (controlType === 'touch') {
        gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
    }

    window.addEventListener('resize', () => {
        updateContainerDimensions();
    });

    updateContainerDimensions();
    createCollectibles();
    gameLoop();
}

// export function initializeGameControls(controlType) {
//     const player = document.querySelector('.player');
//     const gameContainer = document.querySelector('.game-container');
//     if (!player || !gameContainer) return;

//     let containerWidth = gameContainer.offsetWidth;
//     let containerHeight = gameContainer.offsetHeight;
//     const collectibleCount = 9;
//     const collectibles = [];
//     let direction = { x: 1, y: 0 };
//     const playerSpeed = 3;
//     let playerX = 0;
//     let playerY = containerHeight / 2 - 15;
//     const keysPressed = {};
//     let lastDiagonalDirection = null;
//     let touchStartX = null;
//     let touchStartY = null;

//     function updateContainerDimensions() {
//         containerWidth = gameContainer.offsetWidth;
//         containerHeight = gameContainer.offsetHeight - 50;
//         collectibles.forEach(collectible => {
//             let cX = parseFloat(collectible.style.left);
//             let cY = parseFloat(collectible.style.top);
//             if (cX + 30 > containerWidth) {
//                 collectible.style.left = `${containerWidth - 30}px`;
//             }
//             if (cY + 30 > containerHeight) {
//                 collectible.style.top = `${containerHeight - 30}px`;
//             }
//         });
//     }

//     function createCollectibles() {
//         collectibles.forEach(col => col.remove());
//         collectibles.length = 0;
//         for (let i = 0; i < collectibleCount; i++) {
//             const collectible = document.createElement('div');
//             collectible.className = 'collectible';
//             collectible.style.left = `${Math.random() * (containerWidth - 30)}px`;
//             collectible.style.top = `${Math.random() * (containerHeight - 30)}px`;
//             gameContainer.appendChild(collectible);
//             collectibles.push(collectible);
//         }
//     }

//     function movePlayer() {
//         const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
//         const normalized = { x: (direction.x / length) * playerSpeed, y: (direction.y / length) * playerSpeed };
//         playerX += normalized.x;
//         playerY += normalized.y;

//         if (playerX < 0) playerX = containerWidth - player.offsetWidth;
//         else if (playerX > containerWidth - player.offsetWidth) playerX = 0;

//         if (playerY < 0) playerY = containerHeight - player.offsetHeight;
//         else if (playerY > containerHeight - player.offsetHeight) playerY = 0;

//         player.style.left = `${playerX}px`;
//         player.style.top = `${playerY}px`;

//         collectibles.forEach((c, i) => {
//             const cRect = c.getBoundingClientRect();
//             const pRect = player.getBoundingClientRect();
//             if (pRect.left < cRect.right && pRect.right > cRect.left && pRect.top < cRect.bottom && pRect.bottom > cRect.top) {
//                 c.remove();
//                 collectibles.splice(i, 1);
//                 if (collectibles.length === 0) {
//                     setTimeout(createCollectibles, 500);
//                 }
//             }
//         });
//     }

//     function updateDirection() {
//         if (keysPressed['ArrowUp'] && keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: -1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowUp'] && keysPressed['ArrowRight']) {
//             direction = { x: 1, y: -1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowDown'] && keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: 1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowDown'] && keysPressed['ArrowRight']) {
//             direction = { x: 1, y: 1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowUp']) {
//             direction = { x: 0, y: -1 };
//         } else if (keysPressed['ArrowDown']) {
//             direction = { x: 0, y: 1 };
//         } else if (keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: 0 };
//         } else if (keysPressed['ArrowRight']) {
//             direction = { x: 1, y: 0 };
//         } else if (lastDiagonalDirection) {
//             direction = lastDiagonalDirection;
//         }
//     }

//     if (controlType === 'keyboard') {
//         document.addEventListener('keydown', (e) => {
//             keysPressed[e.key] = true;
//             updateDirection();
//         });
//         document.addEventListener('keyup', (e) => {
//             keysPressed[e.key] = false;
//             if (!keysPressed['ArrowUp'] && !keysPressed['ArrowDown'] && !keysPressed['ArrowLeft'] && !keysPressed['ArrowRight']) {
//                 if (lastDiagonalDirection) direction = lastDiagonalDirection;
//             }
//         });
//     }

//     if (controlType === 'touch') {
//         gameContainer.addEventListener('touchstart', e => {
//             const touch = e.touches[0];
//             touchStartX = touch.clientX;
//             touchStartY = touch.clientY;
//         }, { passive: false });

//         gameContainer.addEventListener('touchmove', e => {
//             if (!touchStartX || !touchStartY) return;
//             const touchEndX = e.touches[0].clientX;
//             const touchEndY = e.touches[0].clientY;
//             const diffX = touchEndX - touchStartX;
//             const diffY = touchEndY - touchStartY;
//             const threshold = 5;
//             if (Math.abs(diffX) > Math.abs(diffY)) {
//                 if (Math.abs(diffY) > threshold) {
//                     direction = { x: diffX > 0 ? 1 : -1, y: diffY > 0 ? 1 : -1 };
//                 } else {
//                     direction = { x: diffX > 0 ? 1 : -1, y: 0 };
//                 }
//             } else {
//                 if (Math.abs(diffX) > threshold) {
//                     direction = { x: diffX > 0 ? 1 : -1, y: diffY > 0 ? 1 : -1 };
//                 } else {
//                     direction = { x: 0, y: diffY > 0 ? 1 : -1 };
//                 }
//             }
//             touchStartX = touchEndX;
//             touchStartY = touchEndY;
//         }, { passive: false });
//     }

//     function gameLoop() {
//         movePlayer();
//         requestAnimationFrame(gameLoop);
//     }

//     window.addEventListener('resize', () => updateContainerDimensions());
//     updateContainerDimensions();
//     createCollectibles();
//     gameLoop();
// }

===== ./game/display.js =====
// game/display.js
import { requestGet }  from '../api/index.js';
import { resetScrollPosition } from '../tools/index.js';


//[IMPROVE] Voir quoi afficher avec le get
export async function displayGame() {
    try {
        const response = await requestGet('game', 'game');
        document.querySelector('#home').innerHTML = response.html || response;
        resetScrollPosition();
    } catch (error) {
        console.log('Erreur chargement jeu:', error);
    }
}

export async function displayTournamentBracket(participantCount) {
    const url = participantCount === 4 ? 'bracket_4.html' : 'bracket_8.html';
    try {
        const response = await Api.get(url);
        document.querySelector('#home').innerHTML = response.html || response;
        resetScrollPosition();
    } catch (error) {
        console.log('Erreur chargement bracket:', error);
    }
}

===== ./game/index.js =====
// game/index.js
// contient uniquement les fonctions que l'on souhaite appeler depuis d'autres fichiers

export { handleInviteGame, handleGameInvitationBurgerMenu } from './handleInvitationGame.js';
//export { startLoading } from './loading.js';
export { displayGame, displayTournamentBracket } from './display.js';
export { initializeGameControls } from './controls.js';
export { initializeGameHomeView } from './home.js';
export { handleGameMenu } from './gameMenu.js';
export { startLoading } from './loading.js';
export { acceptGameInvitation, createGameOnline } from './onlineGame.js'
===== ./game/live_game_svg.js =====
// ========== Fonctions génériques pour créer SVG powerups / bumpers ==========

// -- Gestion PowerUp SVG / Bumper SVG (extraits de ton code)
export function createPowerupSVG(type) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 50 50");
    svg.setAttribute("width", "30");
    svg.setAttribute("height", "30");
    
    const powerupStyles = {
        'invert': {
            colors: {main: '#FF69B4', glow: '#FF1493'},
            icon: 'M25 15 A10 10 0 1 1 25 35 M25 35 L20 30 M25 35 L30 30'
        },
        'shrink': {
            colors: {main: '#FF0000', glow: '#8B0000'},
            icon: 'M25 25 L35 15 M33 15 L35 15 L35 17 M25 25 L15 15 M17 15 L15 15 L15 17 M25 25 L35 35 M33 35 L35 35 L35 33 M25 25 L15 35 M17 35 L15 35 L15 33'
        },
        'ice': {
            colors: {main: '#00FFFF', glow: '#00CED1'},
            paths: [
                {d: 'M25 10 L25 40 M18 14 L32 36 M32 14 L18 36 M20 25 L30 25', 
                fill: 'none', stroke: 'white', width: 3},
                {d: 'M25 25 m-3,0 a3,3 0 1,0 6,0 a3,3 0 1,0 -6,0', 
                fill: 'white', stroke: 'none', width: 0}
            ]
        },
        'speed': {
            colors: {main: '#FFD700', glow: '#FFA500'},
            icon: 'M30 10 L20 25 L27 25 L17 40 L32 25 L25 25 L35 10',
            fill: 'white'
        },
        'flash': {
            colors: {main: '#FFFF00', glow: '#FFD700'},
            paths: [
                {d: 'M25 10 m-8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0', 
                fill: 'white', stroke: 'none', width: 0},
                {d: 'M25 10 L25 17 M25 33 L25 40 M35 25 L42 25 M8 25 L15 25 M32 18 L37 13 M13 37 L18 32 M32 32 L37 37 M13 13 L18 18',
                fill: 'none', stroke: 'white', width: 3}
            ]
        },
        'sticky': {
            colors: {main: '#32CD32', glow: '#228B22'},
            icon: 'M25 10 C15 10 15 20 25 20 C35 20 35 10 25 10 M17 20 C17 40 33 40 33 20',
            fill: 'white'
        }
    };
    
    const style = powerupStyles[type] || powerupStyles['speed'];
    
    // Create gradient
    const gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradient.id = `${type}Glow`;
    
    const stops = [
        {offset: '0%', color: style.colors.main, opacity: '1'},
        {offset: '100%', color: style.colors.glow, opacity: '0.6'}
    ];
    
    stops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        gradient.appendChild(stopEl);
    });
    
    svg.appendChild(gradient);
    
    // Create base circle
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", "25");
    circle.setAttribute("cy", "25");
    circle.setAttribute("r", "20");
    circle.setAttribute("fill", `url(#${type}Glow)`);
    svg.appendChild(circle);
    
    // Add icon(s)
    if (style.paths) {
        // For complex icons with multiple paths
        style.paths.forEach(pathData => {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", pathData.d);
            path.setAttribute("stroke", pathData.stroke);
            path.setAttribute("stroke-width", pathData.width);
            path.setAttribute("fill", pathData.fill);
            svg.appendChild(path);
        });
    } else {
        // For single path icons
        const icon = document.createElementNS("http://www.w3.org/2000/svg", "path");
        icon.setAttribute("d", style.icon);
        icon.setAttribute("stroke", "white");
        icon.setAttribute("stroke-width", "3");
        icon.setAttribute("fill", style.fill || "none");
        svg.appendChild(icon);
    }
    
    return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
}

export function createBumperSVG() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 100 100");

    // Create white orb gradient
    const whiteGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    whiteGradient.id = "whiteOrbGradient";
    whiteGradient.setAttribute("cx", "40%");
    whiteGradient.setAttribute("cy", "40%");
    whiteGradient.setAttribute("r", "60%");

    const whiteStops = [
        {offset: '0%', color: 'white', opacity: '1'},
        {offset: '90%', color: '#e0e0e0', opacity: '1'}
    ];

    whiteStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        whiteGradient.appendChild(stopEl);
    });

    // Create blue ring gradient
    const blueGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    blueGradient.id = "blueRingGradient";
    blueGradient.setAttribute("cx", "50%");
    blueGradient.setAttribute("cy", "50%");
    blueGradient.setAttribute("r", "50%");

    const blueStops = [
        {offset: '0%', color: '#4169E1', opacity: '1'},
        {offset: '100%', color: '#1E90FF', opacity: '1'}
    ];

    blueStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        blueGradient.appendChild(stopEl);
    });

    // Add gradients to defs
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    defs.appendChild(whiteGradient);
    defs.appendChild(blueGradient);
    svg.appendChild(defs);

    // Blue exterior ring
    const ringCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    ringCircle.setAttribute("cx", "50");
    ringCircle.setAttribute("cy", "50");
    ringCircle.setAttribute("r", "45");
    ringCircle.setAttribute("fill", "none");
    ringCircle.setAttribute("stroke", "url(#blueRingGradient)");
    ringCircle.setAttribute("stroke-width", "8");

    // White orb center
    const whiteOrb = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    whiteOrb.setAttribute("cx", "50");
    whiteOrb.setAttribute("cy", "50");
    whiteOrb.setAttribute("r", "35");
    whiteOrb.setAttribute("fill", "url(#whiteOrbGradient)");

    // Highlight for 3D effect
    const highlight = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    highlight.setAttribute("cx", "35");
    highlight.setAttribute("cy", "35");
    highlight.setAttribute("r", "15");
    highlight.setAttribute("fill", "white");
    highlight.setAttribute("opacity", "0.3");

    svg.appendChild(ringCircle);
    svg.appendChild(whiteOrb);
    svg.appendChild(highlight);

    return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
    }
===== ./game/loading.js =====
// game/loading.js
import { requestGet }  from '../api/index.js';


// [IMPROVE] verifeir import
//import Animations from '../modules/animations.js';
import { isTouchDevice } from '../tools/utility.js';
import { updateHtmlContent } from '../tools/domHandler.js';
import { initializeGameControls } from './controls.js';
import { displayGame, displayTournamentBracket } from './display.js';

export async function startLoading(participantCount) {
    try {
        const response = await requestGet('game', 'loading');
        updateHtmlContent('#content', response.html);
        //Animations.animateLoadingText();
        if (isTouchDevice()) {
            initializeGameControls('touch');
        } else {
            initializeGameControls('keyboard');
        }

        // setTimeout(() => {
        //     if (participantCount === 1) {
        //         displayGame();
        //     } else {
        //         displayTournamentBracket(participantCount);
        //     }
        // }, 20000);
    } catch (error) {
        console.log('Erreur chargement page loading:', error);
    }
}

===== ./game/gameResults.js =====
import { requestGet} from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";


export async function showResults(gameId) {
	try {
		const response = await requestGet('game', `game_results/${gameId}` );
		if (response.status === 'success')
		{
			showStatusMessage(`Partie terminée ! \nwinner : ${response.winner}  looser : ${response.looser}\n${response.score_left} - ${response.score_right}`, 'success');
			updateHtmlContent('#content', response.html);
			
			// IMPROVE : adapter l' ui de en modifiant le dom pour afficher winner
		}
		else{
			// alert(response.message);
			showStatusMessage(response.message, 'error');
		}
	} catch (err) {
		// console.error('Erreur lors de la création de la partie :', err);
		showStatusMessage('Impossible d\'obtenir les resultats', 'error');
	}
}
===== ./game/home.js =====
import { updateHtmlContent } from '../tools/index.js';
import { requestGet } from '../api/index.js';
import { navigateTo } from '../router.js';
import { showStatusMessage } from '../tools/index.js';

/**
 * Initialise la vue de la page d'accueil du jeu.
 * Redirige vers la page de jeu si l'utilisateur est authentifié.
 */
export async function initializeGameHomeView() {
    console.log('initializeGameHomeView démarré');

    try {
        const data = await requestGet('game', 'home');
        if (!data) {
            return;
        }

        if (data && data.html) {
            updateHtmlContent('#content', data.html);
        } else {
            showStatusMessage('Les données HTML de la page d\'accueil sont manquantes ou invalides.', 'error');
        }
    } catch (error) {
        showStatusMessage('Erreur lors du chargement de la page d\'accueil du jeu.', 'error');
        console.error('Erreur lors de la requête API initializeGameHomeView :', error);
        return;
    }

    const playBtn = document.querySelector('#play-btn-home');
    if (!playBtn) {
        showStatusMessage('Le bouton "Jouer" est introuvable dans la vue actuelle.', 'error');
        return;
    }
    
    if (!playBtn.dataset.bound) {
        playBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('Bouton "Jouer" cliqué. Redirection vers /game-options.');
            navigateTo('/game-options');
        });
        playBtn.dataset.bound = true; // Empêche de lier plusieurs fois l'événement
    }

    console.log('initializeGameHomeView terminé.');
}
===== ./game/localGame.js =====
import { requestGet, requestPost } from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";
import { launchLiveGameWithOptions } from "./live_game.js";
import { showResults } from "./gameResults.js";

export async function handleLocalGame(parametersForm) {
    // Poster vers ton endpoint
	try {
		const response = await requestPost('game', 'create_local_game', parametersForm);
		if (response.status === 'success')
		{
			showStatusMessage(`Partie créée avec succès : ID = ${response.game_id}`, 'success');
			updateHtmlContent('#content', response.html);
			const gameId = response.game_id;
			await launchLiveGameWithOptions(gameId, 'both', `start_local_game/${gameId}`);
			// Attendre quelques secondes (par exemple, 3 secondes)
			await showResults(gameId);
			//IMPROVE afficher une page présentant le winner et looser une fois la game terminee
		}
		else{
			// alert(response.message);
			showStatusMessage(response.message, 'error');

		}
	} catch (err) {
		console.error('Error local game', err);
		showStatusMessage('Error local game', 'error');
	}
}

===== ./game/gameMenu.js =====
import { requestGet, requestPost } from '../api/index.js'; 
import { updateHtmlContent } from '../tools/index.js'; 
// import { handleInviteGame } from './handleInvitationGame.js'; // Suppose qu'on gère l'invitation en ligne ici
// import { launchLiveGameWithOptions } from './live_game.js';
import { handleLocalGame } from './localGame.js'
import { createGameOnline } from './onlineGame.js'

import { navigateTo } from '../router.js';

function attachGameMenuEvents() {
    const sections = ['local', 'online', 'tournament'];

    sections.forEach((section) => {
        // Bouton de sélection
        document.getElementById(`${section}-game-btn`)?.addEventListener('click', () => {
            sections.forEach((s) => {
                document.getElementById(`customization-${s}`).classList.add('d-none');
            });
            document.getElementById(`customization-${section}`).classList.remove('d-none');
        });

        // Bouton Voir Tuto
        document.getElementById(`tutorial-btn-${section}`)?.addEventListener('click', () => {
            const tutorialContent = document.getElementById(`tutorial-content-${section}`);
            tutorialContent.classList.toggle('collapse');
        });

        // Gestion de la vitesse de la balle
        document.getElementById(`ballSpeed${section.charAt(0).toUpperCase() + section.slice(1)}`)?.addEventListener('input', (event) => {
            console.log(`Vitesse de balle (${section}):`, event.target.value);
        });

        // Bouton principal (Lancer Partie, Inviter un ami, Lancer Tournoi)
        const startGameButton = document.getElementById(`start-game-btn-${section}`);
        const inviteGameButton = document.getElementById(`invite-game-btn-${section}`);
        const inviteTournamentButton = document.getElementById(`invite-tournament-btn-${section}`);
        const test = document.getElementById(`${section}-game-btn`); 

        // Définir un comportement différent selon le bouton
        if (startGameButton && section === 'local') {
            startGameButton.addEventListener('click', async () => {
                const parametersForm = new FormData();
                parametersForm.append('game_type', section);

                // Récupérer les éléments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                // Vérifier s’ils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }
                    
                console.log(`Vitesse de balle (${section}):`, ballSpeedElement.value);
                console.log(`Taille de raquette (${section}):`, paddleSizeElement.value);
                console.log(`Bonus activé (${section}):`, bonusCheckbox?.checked);
                console.log(`Obstacles activés (${section}):`, obstacleCheckbox?.checked);
                // Lire les valeurs
                parametersForm.append('ball_speed', ballSpeedElement.value);
                parametersForm.append('paddle_size', paddleSizeElement.value);
                parametersForm.append('bonus_enabled', bonusCheckbox?.checked ?? false);
                parametersForm.append('obstacles_enabled', obstacleCheckbox?.checked ?? false);

                await handleLocalGame(parametersForm)
            });
        }

        if (startGameButton && section === 'online') {
            startGameButton.addEventListener('click', async () => {
                try {
                    // Récupère les éléments
                    const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                    const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                    const bonusCheckbox = document.getElementById(`bonus${section}`);
                    const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                    if (!ballSpeedElement || !paddleSizeElement) {
                        console.error(`Impossible de trouver les champs pour la section "${section}".`);
                        return;
                    }
                    
                    // Stockage en mémoire JS
                    const onlineParams = {
                        ball_speed: ballSpeedElement.value,
                        paddle_size: paddleSizeElement.value,
                        bonus_enabled: bonusCheckbox?.checked ?? false,
                        obstacles_enabled: obstacleCheckbox?.checked ?? false,
                    };
                    sessionStorage.setItem('params', JSON.stringify(onlineParams));
                    console.log('Paramètres de la partie online:', onlineParams);

                    // Maintenant on va charger la page "invite_game.html"
                    // et injecter le HTML dans #content (ou autre conteneur).
                    navigateTo('/online');

                } catch (err) {
                    console.error('Erreur lors de la phase d\'invitation :', err);
                    alert('Impossible d\'inviter un ami.');
                }
            });
        }

        if (startGameButton && section === 'tournament') {
            startGameButton.addEventListener('click', async () => {
                

                // Récupérer les éléments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);
                
                // Vérifier s’ils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }

                 // Stockage en mémoire JS
                const tournamentparams = {
                    ball_speed: ballSpeedElement.value,
                    paddle_size: paddleSizeElement.value,
                    bonus_enabled: bonusCheckbox?.checked ?? false,
                    obstacles_enabled: obstacleCheckbox?.checked ?? false,
                };

                sessionStorage.setItem('params', JSON.stringify(tournamentparams));
                navigateTo(`/tournament`);
            });
        }
    });
}



export async function handleGameMenu() {
    console.log('Chargement du menu du jeu...');
    try {
        // 1) On va chercher le HTML du menu
        const response = await requestGet('game', 'menu');
        if (!response) {
            return;
        }
        // 2) On injecte ce HTML dans la div #content
        updateHtmlContent('#content', response.html);
        // 3) On attache les événements
        attachGameMenuEvents();
    } catch (error) {
        console.error('Erreur dans handleGameMenu:', error);
    }
}

===== ./game/onlineGame.js =====
import { requestGet, requestPost } from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";
import { isTouchDevice } from "../tools/utility.js";
import { initializeGameControls } from "./controls.js";
import { launchLiveGameWithOptions } from "./live_game.js";
import { HTTPError } from "../api/index.js";
import { showResults } from "./gameResults.js";
import { navigateTo } from "../router.js";

export async function createGameOnline() {
    
    console.log('createGameOnline');
    if (typeof localStorage !== "undefined" && !localStorage.getItem('access_token')) {
		navigateTo('/');
		return;
	}
    let onlineParams = sessionStorage.getItem('params');
	if (onlineParams === null)
	{
		showStatusMessage("Paramètres online invalides.", 'error');
		navigateTo('/game-options');
		return;
	}
	try {
		onlineParams = JSON.parse(onlineParams);
	} catch (e) {
		showStatusMessage("Erreur lors de la recuperation des Paramètres.", 'error'); //[IMPROVE]
		return;
	}

    const formData = new FormData();
    if (onlineParams) {
        formData.append('ball_speed',               onlineParams.ball_speed);
        formData.append('paddle_size',             onlineParams.paddle_size);
        formData.append('bonus_enabled',  onlineParams.bonus_enabled);
        formData.append('obstacles_enabled',      onlineParams.obstacles_enabled);
    } else {
        console.warn('Aucun paramètre.');
    }
    try {
        console.log('Avant le try');
        const response = await requestPost('game', 'create_game_online', formData);
        console.log('requestPost effectué'); 
        if (response.status === 'error') {
            console.log('requestPost error'); 

            showStatusMessage(response.message, 'error');
        } else {
            updateHtmlContent('#content', response.html);
            initializeFriendInvitationBtn(response.game_id);
        }
    } catch (error) {
            showStatusMessage('Une erreur est survenue.', 'error');
            console.error('Erreur createGameOnline :', error);
    }
}


async function sendInvitation(button, game_id) {
    console.log('[sendInvitation] Envoi de l\'invitation...');
    const friendUsername = button.closest('li')?.getAttribute('data-username');
    if (!friendUsername) {
        console.error('Nom d\'utilisateur introuvable.');
        return;
    }

    const formData = new FormData();
    formData.append('friend_username', friendUsername);
    formData.append('session_id', game_id);

    try {
        const response = await requestPost('game', 'send_gameSession_invitation', formData);
        if (response.status === 'success') {
            checkGameInvitationStatus(response);
        } else {
            throw new Error(response.message || 'Erreur inconnue');
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi :', error);
        button.textContent = 'Erreur';
        button.classList.add('error');
        setTimeout(() => {
            button.innerHTML = 'Inviter <span class="cancel-icon d-none">&times;</span>';
            button.classList.remove('error');
        }, 3000);
    }
}

// Lancée pour le joueur left après qu'il ait fait sendInvitation()
// Check le statut de l'invitation envoyée toutes les 3 secondes 
// Pendant que le joueur est sur la page loading.html
// redirige vers joinOnlineGameAsLeft() quand l'autre joueur a accepté l'invitation
async function checkGameInvitationStatus(response) {
    // 1) On met à jour le contenu HTML et on initialise les contrôles (comme tu le fais déjà)
    updateHtmlContent('#content', response.html);

    if (isTouchDevice()) {
        initializeGameControls('touch');
    } else {
        initializeGameControls('keyboard');
    }

    // 2) On récupère l'ID de l'invitation depuis la réponse 
    //    (assure-toi que ton backend t'envoie bien `invitation_id` dans `response`)
    const invitationId = response.invitation_id;  

    // 3) On définit l'interval pour faire un GET sur CheckGameInvitationStatusView
    const intervalDelay = 3000; // en ms, par ex. toutes les 3 secondes
    let pollInterval = setInterval(async () => {
        try {
            const data = await requestGet('game', `check_invitation_status/${invitationId}`);
            // Gérer la réponse
            if (data.status === 'success') {
                
              // Vérifier data.status (succès) et data.invitation_status (pending, accepted, etc.)
                if (data.status === 'success') {
                    // data.invitation_status => 'pending', 'accepted', 'rejected', 'expired'
                    switch (data.invitation_status) {
                        case 'pending':
                            // On ne fait rien, on attend le prochain interval
                            console.log("Invitation toujours en attente...");
                            break;

                        case 'accepted':
                            console.log("Invitation acceptée !");
                            // 1) Arrêter le polling
                            clearInterval(pollInterval);

                            // 2) Rediriger vers la page de jeu
                            joinOnlineGameAsLeft(data.session_id);
                            break;

                        case 'rejected':
                            clearInterval(pollInterval);
                            showStatusMessage('Invitation refusée.', 'error');
                            createGameOnline();
                            break;
                        case 'expired':
                            clearInterval(pollInterval);
                            showStatusMessage('Invitation expirée.', 'error');
                            createGameOnline();
                            break;
                        default:
                            console.warn("Statut inconnu :", data.invitation_status);
                            break;
                    }
                } else {
                    // Gérer data.status = 'error'
                    console.error("Erreur lors de la vérification :", data.message);
                    clearInterval(pollInterval);
                }
            } else {
                // Statut HTTP non 200 => on arrête tout
                console.error("Échec de la requête GET sur check_invitation_status :", statusResponse.status);
                clearInterval(pollInterval);
            }
        } catch (err) {
            console.error("Erreur réseau/JS pendant le polling:", err);
            clearInterval(pollInterval);
        }
    }, intervalDelay); 
}


function initializeFriendInvitationBtn(game_id) {
    document.addEventListener('click', async (event) => {
        const btn = event.target.closest('.invite-button');
        if (!btn) return;

        if (event.target.classList.contains('cancel-icon')) {
            event.stopPropagation();
            await cancelInvitation(btn);
            return;
        }

        // Si pas déjà envoyé
        if (!btn.classList.contains('sent')) {
            await sendInvitation(btn, game_id);
        }
    });
}


// cette fonction est lancée par la fonction checkGameInvitation status quand le joueur right a accepté l'invitation
// elle redirige le joueur left (celui qui a envoyé l'invitation) vers la page de jeu
// sur la page de jeu le joueur pourra cliquer sur un bouton qui lancera le jeu en arrière plan (cf.live_online_game_left.js)
async function joinOnlineGameAsLeft(game_id) {
    try {
        const tactile = isTouchDevice();
        console.log('tactile :', tactile);
        
        // Créez un FormData et ajoutez le paramètre is_touch
        const formData = new FormData();
        formData.append('is_touch', tactile);

        // Construit l'URL sans query string
        const url = `join_online_game_as_left/${game_id}`;  // Assurez-vous d'avoir le slash final si nécessaire
        
        // Utilisez requestPost pour envoyer la requête avec le FormData
        const response = await requestPost('game', url, formData);
        
        if (response.status === 'success') {
            // Afficher le HTML renvoyé par le back-end
            updateHtmlContent('#content', response.html);
            // Lancer le jeu côté front pour le joueur left
            await launchLiveGameWithOptions(game_id, 'left', `start_online_game/${game_id}`);
            await showResults(game_id);
        } else {
            showStatusMessage(response.message, 'error');
        }
    } catch (error) {
        if (error instanceof HTTPError) {
            showStatusMessage(error.message, 'error');
        } else {
            showStatusMessage('Une erreur est survenue.', 'error');
        }
        console.error('Erreur joinOnlineGameAsLeft :', error);
    }
}


// IMPROVE : creer une fonction manageGameInvitation() qui gere les cas accept et decline
// lancée par handleGameInvitationBurgerMenu() lorsque le joueur clique sur accepter l'invitation
// fait disparaitre l'item d'invitation
// redirige le joueur ayant accepté l'invit vers la page de jeu avec joinOnlineGameAsRight()
export async function acceptGameInvitation(invitationId, action) {
    try {
        if (action === 'accept') {
            const url = `accept_game_invitation/${invitationId}`;
            const response = await requestPost('game', url, null);

            if (response.status === 'success') {
                console.log('Invitation acceptée => session créée :', response);

                // Supprime l'invitation de l'UI
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();

                // Rejoindre le jeu en tant que joueur RIGHT
                joinOnlineGameAsRight(response.session.id);
            } else {
                console.error('Erreur à l\'acceptation :', response.message);
            }
        } else if (action === 'decline') {
            await declineGameInvitation(invitationId);
        }
    } catch (error) {
        console.error('Erreur réseau lors du traitement de l\'invitation :', error);
    }
}

// lancee par acceptGameInvitation() 
// rediriger le joueur ayant accepté l'invitation vers la page de jeu
async function joinOnlineGameAsRight(sessionId) {
    try {
        const tactile = isTouchDevice();
        console.log('tactile :', tactile);
        
        // Créez un FormData et ajoutez le paramètre is_touch
        const formData = new FormData();
        formData.append('is_touch', tactile);

        // Construit l'URL sans query string
        const url = `join_online_game_as_left/${sessionId}`;  // Assurez-vous d'avoir le slash final si nécessaire
        
        // Utilisez requestPost pour envoyer la requête avec le FormData
        const response = await requestPost('game', url, formData);

        // Gestion des erreurs renvoyées par le serveur
        if (response.status === 'error') {
            console.error("Erreur lors de la tentative de rejoindre le jeu :", response.message);
            showStatusMessage(response.message, 'error');
            return;
        }
        // Si succès, afficher la page de jeu 
        updateHtmlContent('#content', response.html);
        await launchLiveGameWithOptions(response.game_id, 'right', `start_online_game/${response.game_id}`);
        await showResults(response.game_id);


    } catch (error) {
        console.error('Erreur réseau lors de la connexion au jeu en tant que joueur Right:', error);
        showStatusMessage('Une erreur réseau est survenue. Veuillez réessayer.', 'error');
    }
}

export async function declineGameInvitation(invitationId) {
    try {
        const formData = new FormData();
        formData.append('invitation_id', invitationId);
        formData.append('action', 'decline');

        const url = `reject_game_invitation/${invitationId}`;
        const response = await requestPost('game', url, formData);

        if (response.status === 'success') {
            console.log('Invitation refusée :', response);
            document.querySelector(`[data-invitation-id="${invitationId}"]`)
                ?.closest('.invitation-item')
                ?.remove();
        } else {
            console.error('Erreur lors du refus :', response.message);
        }
    } catch (error) {
        console.error('Erreur lors du refus de l\'invitation :', error);
    }
}
===== ./game/tournament.js =====
import { requestGet, requestPost } from "../api/index.js";
import { showStatusMessage, updateHtmlContent } from "../tools/index.js";
import { launchLiveGameWithOptions } from './live_game.js';
import { TournamentNextMatch } from './tournament_utils.js';
import { showResults } from "./gameResults.js";
import { navigateTo } from "../router.js";


// Fonction principale appelée quand on clique sur "Lancer Tournoi" dans le menu
export async function handleTournament() {

	if (typeof localStorage !== "undefined" && !localStorage.getItem('access_token')) {
		navigateTo('/');
		return;
	}

	let tournamentParam = sessionStorage.getItem('params');
	if (tournamentParam === null)
	{
		showStatusMessage("Paramètres de tournoi invalides.", 'error');
		navigateTo('/game-options');
		return;
	}
	try {
		tournamentParam = JSON.parse(tournamentParam);
	} catch (e) {
		showStatusMessage("Erreur lors de la recuperation des Paramètres.", 'error'); //[IMPROVE]
		return;
	}
	
		console.log("Tournament param est égale a :", tournamentParam);
		// 1) Récupère le formulaire (GET)
	const formHtml = await getTournamentForm();
	if (!formHtml)
		return;
	updateHtmlContent('#content', formHtml);

	// 2) Sélection du form dans le DOM
	const form = document.querySelector('#content form');
	if (!form) {
		console.error("Formulaire introuvable dans le HTML injecté.");
		return;
	}

	// 3) Au submit => POST de création du tournoi
	form.addEventListener("submit", async (event) => {
		event.preventDefault();

		// Récupération des champs du form
		const formData = new FormData(form);

		// Si vous avez d’autres paramètres passés depuis un menu (tournamentParam),
		// on peut forcer/écraser ici dans le formData :
		if (tournamentParam) {
		formData.set('ball_speed', tournamentParam.ball_speed);
		formData.set('paddle_size', tournamentParam.paddle_size);
		formData.set('bonus_enabled', tournamentParam.bonus_enabled);
		formData.set('obstacles_enabled', tournamentParam.obstacles_enabled);
		}

		try {
		const response = await createTournament(formData);
		if (response.status === 'success') {
			alert(`Tournoi créé : ID = ${response.tournament_id}`);
			// Lance la suite (loop + affichage bracket + next match etc.)
			await runTournamentFlow(response.tournament_id);
		} else {
			alert("Erreur : " + response.message);
		}
		} catch (error) {
		console.error("Erreur lors de la création du tournoi :", error);
		alert("Une erreur est survenue lors de la création du tournoi.");
		}
	});
}

// -- Petites fonctions factorielles pour clarifier --

async function getTournamentForm() {
  const responseGet = await requestGet('game', 'create_tournament');
  if (!responseGet)
	  return false;
  if (responseGet.status === 'success') {
    return responseGet.html;
  } 
  else if (responseGet.status === 'error') {
	showStatusMessage("Erreur lors de la récupération du formulaire du tournoi :", 'error');
	navigateTo('/game-options');
  }
}

async function createTournament(formData) {
  // Appel POST vers /game/create_tournament
  return await requestPost('game', 'create_tournament', formData);
}

// -- Le “flow” du tournoi (récup bracket, next match, etc.) --

async function runTournamentFlow(tournamentId) {
  while (true) {
    // 1) Afficher le bracket
    const bracketResp = await requestGet('game', `tournament_bracket/${tournamentId}`);
    if (!bracketResp || bracketResp.status !== "success") {
      console.error("Impossible de récupérer le bracket du tournoi.");
      break;
    }

    console.log(bracketResp);
    updateHtmlContent("#content", bracketResp.html);
	console.log("BRACKET UPDATED\n");
    updateBracketUI(bracketResp)
    await delay(3000);  // Pause de 4s (si vraiment nécessaire)
    
    // TODO : si le backend renvoie un champ indiquant “finished”, sortir de la boucle
    // Exemple si bracketResp renvoie un `tournament_finished: true` ou
    // un champ `tournament_status = "finished"`.
    if (bracketResp.tournament_status === "finished") {
      console.log("Tournoi terminé (d’après bracket).");
      break;
    }
    // 2) Récupérer les joueurs du prochain match
    const nextResp = await requestGet('game', `tournament_next_game/${tournamentId}`);
    if (!nextResp || nextResp.status !== "success") {
      console.error("Impossible de récupérer le prochain match.");
      break;
    }

    if (nextResp.next_match_type === "finished") {
      console.log("Tournoi terminé (d’après next_game).");
      break;
    }

    updateHtmlContent("#content", nextResp.html);
	updateNextGameUI(bracketResp, nextResp);
	TournamentNextMatch();
    await delay(3000);

    // 3) Créer la gameSession de match (semi1, semi2, finale…) en POST
    const gameId = await createTournamentGameSession(tournamentId, nextResp.next_match_type);
    if (!gameId) {
      console.error("Erreur lors de la création de la session de match.");
      break;
    }

    // 4) Lancer le liveGame 
    await launchLiveGameWithOptions(gameId, 'both', `start_tournament_game_session/${gameId}`);
  }

  sessionStorage.removeItem('tournamentparams');
  console.log("Fin du flux tournoi");
}


function updateNextGameUI(bracketResp, nextResp) {
	// Récupère le type de match prochain (ex. "semifinal1", "semifinal2" ou "final")
	const matchType = nextResp.next_match_type;
	
	// Variables pour le joueur de gauche (avatar1) et celui de droite (avatar2)
	let leftPlayerName = "";
	let rightPlayerName = "";
	let leftPlayerAvatar = "";
	let rightPlayerAvatar = "";
	
	// Récupère le dictionnaire des avatars envoyé par le serveur
	const avatars = bracketResp.player_avatars;
	
	// Adaptation du switch aux valeurs renvoyées par la vue
	switch(matchType) {
	  case "semifinal1":
		leftPlayerName = bracketResp.player1;
		rightPlayerName = bracketResp.player2;
		leftPlayerAvatar = avatars[bracketResp.player1];
		rightPlayerAvatar = avatars[bracketResp.player2];
		break;
	  case "semifinal2":
		leftPlayerName = bracketResp.player3;
		rightPlayerName = bracketResp.player4;
		leftPlayerAvatar = avatars[bracketResp.player3];
		rightPlayerAvatar = avatars[bracketResp.player4];
		break;
	  case "final":
		// Pour le final, on utilise les gagnants des demi-finales
		leftPlayerName = bracketResp.winner_semifinal_1;
		rightPlayerName = bracketResp.winner_semifinal_2;
		leftPlayerAvatar = avatars[bracketResp.winner_semifinal_1] || "/static/svg/default_avatar.svg";
		rightPlayerAvatar = avatars[bracketResp.winner_semifinal_2] || "/static/svg/default_avatar.svg";
		break;
	  default:
		console.error("Type de match inconnu :", matchType);
		return;
	}
	
	// Mise à jour des éléments du DOM :
	// avatar1 correspond au joueur de gauche et avatar2 au joueur de droite.
	const leftAvatarImg = document.querySelector(".avatar1 img.avatar");
	const leftNameElem = document.querySelector(".avatar1 .player-name");
	const rightAvatarImg = document.querySelector(".avatar2 img.avatar");
	const rightNameElem = document.querySelector(".avatar2 .player-name");
	
	if (leftAvatarImg) {
	  leftAvatarImg.src = leftPlayerAvatar;
	}
	if (leftNameElem) {
	  leftNameElem.textContent = leftPlayerName;
	}
	if (rightAvatarImg) {
	  rightAvatarImg.src = rightPlayerAvatar;
	}
	if (rightNameElem) {
	  rightNameElem.textContent = rightPlayerName;
	}
	
	console.log("Next match type:", matchType);
	console.log("Gauche :", leftPlayerName, leftPlayerAvatar);
	console.log("Droite :", rightPlayerName, rightPlayerAvatar);
  }



// Met à jour le bracket en fonction de l'état du tournoi
// Improve remplacer par des balises django dans le front ??
function updateBracketUI(bracketResp) {
	const status = bracketResp.tournament_status;
	const name = bracketResp.tournament_name;
	const winnerSemi1 = bracketResp.winner_semifinal_1;
	const winnerSemi2 = bracketResp.winner_semifinal_2;
	const winnerFinal = bracketResp.winner_final;

	console.log("updateBracketUI status:", status, "winnerSemi1:", winnerSemi1, "winnerSemi2:", winnerSemi2, "winnerFinal:", winnerFinal);
	console.log("updateBracketUI status: eclair ? ",document.querySelector('.eclair.match-1'));
	// Récupère le dictionnaire des avatars depuis le JSON
	const playerAvatars = bracketResp.player_avatars;
	
	// Mettez à jour le titre avec le nom du tournoi
    document.querySelector('.title-choosen').textContent = name

	// Masque tous les paragraphes d'état
	document.querySelectorAll('.tournament-title p').forEach(p => p.classList.add('d-none'));
	
	// Mise à jour des avatars et noms pour chaque joueur
	document.querySelector('[data-player-id="1"] .avatar').src = playerAvatars[bracketResp.player1];
	document.querySelector('[data-player-id="2"] .avatar').src = playerAvatars[bracketResp.player2];
	document.querySelector('[data-player-id="3"] .avatar').src = playerAvatars[bracketResp.player3];
	document.querySelector('[data-player-id="4"] .avatar').src = playerAvatars[bracketResp.player4];
	
	document.querySelector('[data-player-id="1"] .player-name').textContent = bracketResp.player1;
	document.querySelector('[data-player-id="2"] .player-name').textContent = bracketResp.player2;
	document.querySelector('[data-player-id="3"] .player-name').textContent = bracketResp.player3;
	document.querySelector('[data-player-id="4"] .player-name').textContent = bracketResp.player4;
	
	// Affichage contextuel selon l'état du tournoi
	if (status === "pending") {
	  document.querySelector('.tournament-title p:nth-child(2)').classList.remove('d-none'); 
	  document.querySelector('.eclair.match-1').classList.remove('d-none');
	} else if (status === "semifinal1_done") {
	  document.querySelector('.tournament-title p:nth-child(3)').classList.remove('d-none');
	  document.querySelector('.eclair.match-2').classList.remove('d-none');
	} else if (status === "semifinal2_done") {
	  document.querySelector('.tournament-title p:nth-child(4)').classList.remove('d-none');
	  document.querySelector('.eclair.match-3').classList.remove('d-none');
	} else if (status === "finished") {
	  document.querySelector('.tournament-title p:nth-child(5)').classList.remove('d-none');
	}
	
	// Affichage des gagnants des demi-finales
	if (winnerSemi1) {
	  document.querySelector(".winner1").classList.remove("d-none");
	  document.querySelector(".winner1 .avatar").src = playerAvatars[winnerSemi1];
	  document.querySelector(".winner1 .player-name").textContent = winnerSemi1;
	}
	
	if (winnerSemi2) {
	  document.querySelector(".winner2").classList.remove("d-none");
	  document.querySelector(".winner2 .avatar").src = playerAvatars[winnerSemi2];
	  document.querySelector(".winner2 .player-name").textContent = winnerSemi2;
	}
	
	// Affichage du final
	if (winnerFinal) {
	  const finalWinnerElem = document.querySelector(".winner3");
	  finalWinnerElem.classList.remove("d-none");
  
	  let finalAvatar = playerAvatars[winnerFinal];
	  if (!finalAvatar) {
		console.error("Avatar introuvable pour le final winner:", winnerFinal);
		finalAvatar = "/static/svg/default_avatar.svg"; // Avatar par défaut
	  } else {
		console.log("Final winner:", winnerFinal, "Avatar URL:", finalAvatar);
	  }
	  
	  document.querySelector(".winner3 .avatar").src = finalAvatar;
	  document.querySelector(".winner3 .winner-name").textContent = winnerFinal;
	}
  }
// Création de la session (POST vers /game/create_tournament_game_session/<tournament_id>)
async function createTournamentGameSession(tournamentId, nextMatchType) {
  try {
    const formData = new FormData();
    formData.set('next_match_type', nextMatchType);

    const response = await requestPost(
      'game',
      `create_tournament_game_session/${tournamentId}`,
      formData
    );
    if (response.status === 'success') {
      updateHtmlContent("#content", response.html);
      return response.game_id; // On retourne juste l’ID
    } else {
      console.error("createTournamentGameSession error:", response.message);
      return null;
    }
  } catch (err) {
    console.error("createTournamentGameSession exception:", err);
    return null;
  }
}


// Petit utilitaire de pause asynchrone
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

===== ./game/tournament_utils.js =====
function updateSvgViewBox(mediaQuery) {
    const svg = document.getElementById('eclair-svg');
    if (!svg) {
        console.warn("L'élément 'eclair-svg' est introuvable dans le DOM.");
        return; // Arrête la fonction si l'élément n'existe pas
    }
    
    console.log("svg passe !");
    if (mediaQuery.matches) {
        svg.setAttribute('viewBox', '150 -50 400 1350'); // Pour petit écran
    } else {
        svg.setAttribute('viewBox', '40 -20 650 1300'); // ViewBox originale
    }
}
// Fonction pour changer la taille (width et height) du SVG
 // Fonction pour changer la taille (width et height) du SVG
 function updateSvgSize(mediaQuery) {
	const svg = document.getElementById('eclair-svg');
	if (!svg) {
		console.warn("L'élément 'eclair-svg' est introuvable dans le DOM.");
		return;
	}
	if (mediaQuery.matches) {
		svg.setAttribute('width', '30vh'); // Ajustée pour petit écran
		svg.setAttribute('height', '100vw');
	} else {
		svg.setAttribute('width', '30vw'); // Taille originale
		svg.setAttribute('height', '90vh');
	}
}

// Créez une media query
const mediaQuery = window.matchMedia("(max-aspect-ratio: 3/3)");

// Fonction principale pour mettre à jour le SVG
function updateSvg(mediaQuery) {
updateSvgViewBox(mediaQuery); // Mise à jour de la viewBox
updateSvgSize(mediaQuery);    // Mise à jour des dimensions
}

export async function TournamentNextMatch(){
// Ajoutez un écouteur d'événements pour les changements de media query
mediaQuery.addEventListener('change', () => updateSvg(mediaQuery));

// Appelez la fonction pour initialiser la bonne viewBox et taille
updateSvg(mediaQuery);

}


===== ./game/handleInvitationGame.js =====
// game/invitations.js
import { requestPost, requestGet }  from '../api/index.js';
import { showStatusMessage, updateHtmlContent } from '../tools/index.js';
import { HTTPError } from '../api/index.js';
import { navigateTo } from '../router.js';

///////////////////////////////
//  PARTIE BURGER MENU
///////////////////////////////
export async function handleGameInvitationBurgerMenu(invitationId, action) {
    try {
        if (action === 'accept') {
            // On appelle AcceptGameInvitationView
            const url = `accept_invitation/${invitationId}`;
            const formData = new FormData();

            const response = await requestPost('game', url, formData);
            if (response.status === 'success') {
                console.log('Invitation acceptée => session créée :', response);
                // Supprime l'invitation de l'UI
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();

                // Rediriger l'utilisateur (B) vers loading (SPA => adapter URL si besoin)
                navigateTo(`/game-loading`);
                //window.location.href = `/game/loading/${response.session.id}`;
            } else {
                console.error('Erreur à l\'acceptation :', response.message);
            }
        } 
        else if (action === 'decline') {
            // On appelle RespondToInvitationView
            const formData = new FormData();
            formData.append('invitation_id', invitationId);
            formData.append('action', 'decline');

            const response = await requestPost('game', 'respond_to_invitation', formData);
            if (response.status === 'success') {
                console.log('Invitation refusée :', response);
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();
            } else {
                console.error('Erreur lors du refus :', response.message);
            }
        }
    } catch (error) {
        console.error('Erreur réseau lors du traitement de l\'invitation :', error);
    }
}


///////////////////////////////
//  PARTIE INVITATION ONLINE
///////////////////////////////
let cachedOnlineParams = null;

/**
 * Fonction appelée quand on clique sur "Inviter un ami" dans la section "online".
 * On reçoit les paramètres (ball_speed, paddle_size, etc.), on affiche la liste d'amis.
 */
export async function handleInviteGame(onlineParams) {
    console.log('[handleInviteGame] Paramètres online = ', onlineParams);

    
    try {
        const response = await requestGet('game', 'invite_game');
        if (!response) {
            return;
        }
        cachedOnlineParams = onlineParams;
        if (response.status === 'error') {
            showStatusMessage(response.message, 'error');
        } else {
            updateHtmlContent('#content', response.html);
            // Optionnel : si tu veux lancer le polling direct
                    // (pour que A voie en temps quasi-réel l'acceptation)
            startWaitingRoomPolling();
            initializeFriendInvitationBtn();
        }
    } catch (error) {
        if (error instanceof HTTPError) {
            showStatusMessage(error.message, 'error');
        } else {
            showStatusMessage('Une erreur est survenue.', 'error');
        }
        console.error('Erreur handleInviteGame :', error);
    }
}

function initializeFriendInvitationBtn() {
    document.addEventListener('click', async (event) => {
        const btn = event.target.closest('.invite-button');
        if (!btn) return;

        if (event.target.classList.contains('cancel-icon')) {
            event.stopPropagation();
            await cancelInvitation(btn);
            return;
        }

        // Si pas déjà envoyé
        if (!btn.classList.contains('sent')) {
            await sendInvitation(btn);
        }
    });
}

async function sendInvitation(button) {
    console.log('[sendInvitation] Envoi de l\'invitation...');
    const friendUsername = button.closest('li')?.getAttribute('data-username');
    if (!friendUsername) {
        console.error('Nom d\'utilisateur introuvable.');
        return;
    }

    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    // On inclut les params récupérés en "cachedOnlineParams"
    if (cachedOnlineParams) {
        formData.append('ball_speed', cachedOnlineParams.ball_speed);
        formData.append('paddle_size', cachedOnlineParams.paddle_size);
        formData.append('bonus_enabled', cachedOnlineParams.bonus_enabled);
        formData.append('obstacles_enabled', cachedOnlineParams.obstacles_enabled);
    } else {
        console.warn('Aucun paramètre en cache.');
    }

    try {
        // Désactiver le bouton pendant l'envoi
        button.disabled = true;

        const response = await requestPost('game', 'send_invitation', formData);
        if (response.status === 'success') {
            button.innerHTML = 'Envoyé <span class="cancel-icon">&times;</span>';
            button.classList.add('sent');
        } else {
            throw new Error(response.message || 'Erreur inconnue');
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi :', error);
        button.textContent = 'Erreur';
        button.classList.add('error');
        setTimeout(() => {
            button.innerHTML = 'Inviter <span class="cancel-icon d-none">&times;</span>';
            button.classList.remove('error');
        }, 3000);
    } finally {
        // Réactiver le bouton après la requête
        button.disabled = false;
    }
}

async function cancelInvitation(button) {
    const friendBtn = button.parentElement.querySelector('.friend-btn');
    const friendUsername = friendBtn ? friendBtn.textContent : null;
    if (!friendUsername) return;

    console.log('[cancelInvitation] Annulation invitation à', friendUsername);
    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    try {
        const response = await requestPost('game', 'cancel_invitation', formData);
        if (response.status === 'success') {
            button.innerHTML = 'Inviter';
            button.classList.remove('sent');
        }
    } catch (error) {
        console.error('Erreur annulation invitation:', error);
    }
}


///////////////////////////////
//  POLLING OPTIONNEL
///////////////////////////////
let pollInterval = null;

export function startWaitingRoomPolling() {
    if (pollInterval) return; // Déjà en cours ?

    pollInterval = setInterval(pollInvitations, 3000);
}

async function pollInvitations() {
    try {
        const response = await requestGet('game', 'list_invitations');
        if (response.status === 'success') {
            const sent = response.data.sent_invitations;
            // Chercher si une invitation est accepted + a un session_id
            const accepted = sent.find(inv => inv.status === 'accepted' && inv.session_id != null);

            if (accepted) {
                clearInterval(pollInterval);
                pollInterval = null;

                // Redirige vers /game/loading/<session_id>
                navigateTo(`/game-loading`);
                //window.location.href = `/game/loading/${accepted.session_id}`;
            }
        }
    } catch (error) {
        console.error('Erreur polling invitations:', error);
    }
}

===== ./game/live_game_utils.js =====
// export function isTouchDevice() {
//   return (('ontouchstart' in window) || 
//           (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || 
//           (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0));
// }

  



function handleResize() {
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    const margin = 12; // Marge interne utilisée pour le positionnement
    const container = document.querySelector('.game-container');
	const containerHeight = container.clientHeight;
    if (!container) return;

    // Dimensions du conteneur et de la fenêtre
    const containerWidth = container.clientWidth;
    const windowHeight = window.innerHeight;

    // Calcul du scale en fonction de l'espace disponible
    let scale = Math.min(containerWidth / ORIGINAL_WIDTH, windowHeight * 0.7 / ORIGINAL_HEIGHT);

    // Appliquer le scale sur le canvas (dimension affichée)
    canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
    canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';

    // Garder la résolution logique du canvas inchangée
    canvas.width = ORIGINAL_WIDTH;
    canvas.height = ORIGINAL_HEIGHT;
    
    // Ajuster dynamiquement la hauteur du game-container (en fonction de la largeur)
    container.style.height = Math.min(windowHeight * 0.8, containerWidth / 2) + 'px';

    ctx.imageSmoothingEnabled = false;

    // Utilisation du facteur d'échelle pour d'autres ajustements
    const s = scale;

    // Positionnement absolu de score-display par rapport à game-container
    // On considère que :
    //   - Le canvas est positionné en absolute dans le game-container (déjà défini dans votre CSS).
    //   - Le canvas est décalé d'une marge (margin) par rapport au bord supérieur et gauche du container.
    // On positionne alors le score-display pour qu'il soit centré horizontalement sur le bord supérieur du canvas.
    const scoreDisplay = document.getElementById("score-display");
    if (scoreDisplay) {
        // Assurez-vous que le game-container est en position relative (pour que le positionnement absolu se fasse par rapport à lui)
        container.style.position = "relative";
        // Le canvas devrait être positionné en absolute (vérifiez votre CSS)
        // Récupérer la position du canvas par rapport au container (offsetLeft et offsetTop fonctionnent si le container est en position relative)
        const canvasLeft = canvas.offsetLeft;
        const canvasTop = canvas.offsetTop;
        // Calculer la largeur affichée du canvas (en pixels)
        const canvasDisplayWidth = ORIGINAL_WIDTH * s;

        // Placer le score-display centré sur le bord supérieur du canvas.
        // On fixe sa position verticale à la même valeur que canvasTop (souvent égale à la marge appliquée)
        // et sa position horizontale au centre du canvas.
        scoreDisplay.style.position = "absolute";
        scoreDisplay.style.left = (canvasLeft + canvasDisplayWidth / 2) + "px";
        scoreDisplay.style.top = (canvasTop + 2) + "px";
        // Pour centrer le score-display par rapport à son point de positionnement, on décale de 50% de sa largeur.
        scoreDisplay.style.transform = "translate(-50%, 0)";
        scoreDisplay.style.transformOrigin = "center top";

        // On fixe la taille de la police en pixels pour éviter les fluctuations liées aux unités rem
        scoreDisplay.style.fontSize = (30 * s) + "px";
    }
}

window.addEventListener('resize', handleResize);
handleResize(); // Appel initial


function updateScoreDisplay() {
	const scoreEl = document.getElementById("score-nb");
	if (scoreEl) {
	  // Ici, on suppose que les noms sont déjà injectés via Django dans le HTML.
	  // Par exemple, on pourrait avoir utilisé des attributs data pour conserver ces noms.
	  // Si ce n'est pas le cas, vous pouvez également définir des variables globales injectées par Django.
	  // Ici, nous allons lire le texte initial et remplacer uniquement la partie numérique.
	  // Pour plus de flexibilité, vous pouvez modifier cette fonction selon vos besoins.
	  // Exemple avec des attributs data (optionnel) :
	  scoreEl.innerText = ` ${gameState.score_left} - ${gameState.score_right} `;
	}
  }

  updateScoreDisplay();
===== ./game/live_game.js =====
/* live_game.js
 *
 * Centralise les fonctions communes pour :
 * dessiner le canvas, les bumpers et les powerups
 * lancer le jeu en co-routine avec le bouton startGame 
 * recevoir les notifications (envoyées par broadcast.py > consumers.py > websocket)
 *    detecter la position de tous les elements de jeu (gameState)
 *    afficher des animations aux lieux d'impacts de la balle /lieux d'apparition des bumpers et powerups 
 * 
 */

import { requestPost } from '../api/index.js';
import { createPowerupSVG, createBumperSVG } from './live_game_svg.js';
import { isTouchDevice } from "../tools/index.js";


export async function launchLiveGameWithOptions(gameId, userRole, urlStartButton) {
  const protocol = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws/pong/${gameId}/`;

  let startGameSelector = null;
  let onStartGame = null;
  
  console.log(`userRole = ${userRole}`);
  if (urlStartButton) {
    // Sélectionner l'élément DOM correspondant au bouton de démarrage
    startGameSelector = document.querySelector("#startGameBtn");
    // Vérifier que l'élément a bien été trouvé
    if (!startGameSelector) {
      console.error("L'élément avec le sélecteur '#startGameBtn' n'a pas été trouvé.");
    }
    
    onStartGame = async (gameId) => {
      // Assurez-vous que startGameSelector est bien un élément DOM avant d'accéder à classList
      if (startGameSelector) {
        startGameSelector.classList.add('d-none');
      }
      const url = urlStartButton;
      const formData = new FormData();
      formData.append('game_id', gameId);
      formData.append('userRole', userRole);
  
      const response = await requestPost('game', url, formData);
      if (response.status !== 'success') {
        alert("Erreur lors du démarrage : " + response.message);
      }
    };
  }

  // fonction qui gere toute la logique de jeu à partir de notre config
  return initLiveGame({
    gameId,
    userRole,
    wsUrl,
    startGameSelector,
    onStartGame
  });
}


  // ========== initPowerupImages ==========
  
  function initPowerupImages(powerupImages) {
    // Initialise la map de type => Image()
    Object.keys(powerupImages).forEach(type => {
      powerupImages[type].src = createPowerupSVG(type);
    });
  }
  
  // ========== applyFlashEffect ==========
  
  function applyFlashEffect(gameState, duration = 300) {
    gameState.flash_effect = true;
    setTimeout(() => {
      gameState.flash_effect = false;
    }, duration);
  }



// ========== La grosse fonction initLiveGame ==========

/**
 * Initialise un "live game" (local ou online) dans le canvas.
 * @param {Object} config 
 *    config.gameId  : string
 *    config.userRole: "left" | "right" | "both"   // ex: "both" = local, "left" ou "right" = online
 *    config.wsUrl   : URL du WebSocket
 *    config.startGameSelector?: ID du bouton (ex: "#startGameBtn")
 *    config.onStartGame?: Function de callback pour lancer la partie 
 *                         (ex: faire un POST sur /start_online_game/ ou /start_local_game/)
   */
function initLiveGame(config) {
  return new Promise((resolve) => {
    // 1) Préparer les éléments HTML
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startGameBtn = config.startGameSelector;
    console.log("Appareil tactile ?", isTouchDevice());
    cleanupGamePage();
    setupGamePage();
    // 2) Gérer le bouton "Start" (optionnel)
    if (startGameBtn && config.onStartGame) {
      // Débloquer le bouton après 3s (optionnel)
  //     setTimeout(() => { 
	// 	startGameBtn.style.opacity = "0.7";
  //       startGameBtn.disabled = false;
	    startGameBtn.classList.add("active");
	
	// }, 3000);
  
      // Clic => on appelle la callback onStartGame
      startGameBtn.addEventListener('click', async () => {
        await config.onStartGame()
        // await startGameWithCountdown(startGameBtn, config.onStartGame, config.gameId);
      });
    }



	// Draw visual effects / added
	function drawCollisionEffects() {
		collisionEffects.forEach(effect => {
			const age = effect.type.includes('spawn') ?
			  Date.now() - effect.startTime :
			  Date.now() - effect.startTime;
			const duration = effect.type.includes('spawn') ?
			  SPAWN_EFFECT_DURATION :
			  EXPIRE_EFFECT_DURATION;
			const progress = age / duration;
  
			ctx.save();
			ctx.globalAlpha = 1 - progress;
  
			switch(effect.type) {
				case 'paddle_collision':
					// Ripple effect
					const rippleSize = 20 + (progress * 40);
					ctx.strokeStyle = 'white';
					ctx.lineWidth = 3 * (1 - progress);
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, rippleSize, 0, Math.PI * 2);
					ctx.stroke();
					break;
  
				// case 'border_collision':
				//     // Simple glow effect at collision point
				//     const glowSize = 20 * (1 - progress);
				//     ctx.shadowColor = 'white';
				//     ctx.shadowBlur = 15 * (1 - progress);
					
				//     ctx.beginPath();
				//     ctx.arc(effect.x, effect.border_side === 'up' ? 50 : 350, glowSize, 0, Math.PI * 2);
				//     ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - progress) + ')';
				//     ctx.fill();
				//     break;
  
				case 'bumper_collision':
					// Explosion effect
					const numParticles = 8;
					const radius = 30 * progress;
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 3 * (1 - progress);
					
					for (let i = 0; i < numParticles; i++) {
						const angle = (i / numParticles) * Math.PI * 2;
						const startX = effect.x + Math.cos(angle) * 10;
						const startY = effect.y + Math.sin(angle) * 10;
						const endX = effect.x + Math.cos(angle) * radius;
						const endY = effect.y + Math.sin(angle) * radius;
						
						ctx.beginPath();
						ctx.moveTo(startX, startY);
						ctx.lineTo(endX, endY);
						ctx.stroke();
					}
					break;
				case 'powerup_spawn':
					// Expanding circles with powerup color
					const circles = 3;
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2;
					
					for (let i = 0; i < circles; i++) {
						const circleProgress = (progress + (i / circles)) % 1;
						const radius = circleProgress * 40;
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
						ctx.stroke();
					}
  
					// Add sparkles
					const sparkles = 8;
					for (let i = 0; i < sparkles; i++) {
						const angle = (i / sparkles) * Math.PI * 2;
						const sparkleDistance = 20 + (progress * 20);
						const x = effect.x + Math.cos(angle) * sparkleDistance;
						const y = effect.y + Math.sin(angle) * sparkleDistance;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fillStyle = effect.color;
						ctx.fill();
					}
					break;
  
				case 'powerup_expire':
					// Imploding effect
					const fadeRadius = 20 * (1 - progress);
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2 * (1 - progress);
					
					// Shrinking circle
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, fadeRadius, 0, Math.PI * 2);
					ctx.stroke();
					
					// Particles moving inward
					const particles = 6;
					for (let i = 0; i < particles; i++) {
						const angle = (i / particles) * Math.PI * 2;
						const distance = fadeRadius * 2;
						const x = effect.x + Math.cos(angle) * distance * progress;
						const y = effect.y + Math.sin(angle) * distance * progress;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fill();
					}
					break;
  
				case 'bumper_spawn':
					// Expanding diamond pattern
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2;
					const size = 40 * progress;
					const rotation = progress * Math.PI;
					
					ctx.translate(effect.x, effect.y);
					ctx.rotate(rotation);
					
					// Inner diamond
					ctx.beginPath();
					ctx.moveTo(0, -size);
					ctx.lineTo(size, 0);
					ctx.lineTo(0, size);
					ctx.lineTo(-size, 0);
					ctx.closePath();
					ctx.stroke();
					
					// Outer diamond
					ctx.beginPath();
					ctx.moveTo(0, -size * 1.5);
					ctx.lineTo(size * 1.5, 0);
					ctx.lineTo(0, size * 1.5);
					ctx.lineTo(-size * 1.5, 0);
					ctx.closePath();
					ctx.stroke();
					break;
  
				case 'bumper_expire':
					// Dissolving rings effect
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2 * (1 - progress);
					
					const rings = 3;
					for (let i = 0; i < rings; i++) {
						const ringProgress = (progress + (i / rings)) % 1;
						const ringRadius = 20 * ringProgress;
						
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, ringRadius, 0, Math.PI * 2);
						ctx.stroke();
						
						// Add dissolving particles
						const particleCount = 8;
						for (let j = 0; j < particleCount; j++) {
							const particleAngle = (j / particleCount) * Math.PI * 2;
							const distance = ringRadius * (1 + progress);
							const px = effect.x + Math.cos(particleAngle) * distance;
							const py = effect.y + Math.sin(particleAngle) * distance;
							
							ctx.fillStyle = '#4169E1';
							ctx.fillRect(px - 1, py - 1, 2, 2);
						}
					}
					break;
			}
			ctx.restore();
		});
	}


	function drawCountdown() {
    if (typeof gameState.countdown !== 'undefined') {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
  
      ctx.fillStyle = 'white';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillText(gameState.countdown, canvas.width / 2, canvas.height / 3);
      ctx.restore();
    }
	}
  
    // 3) Mise en place du redimensionnement du canvas
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    let scale = 1;

	    // Const for visual effects on notifications / added
		const collisionEffects = [];
		const EFFECT_DURATION = 300;
		const SPAWN_EFFECT_DURATION = 500;
		const EXPIRE_EFFECT_DURATION = 300;
	  
		// spawn visual effect / added
		function createSpawnEffect(type, x, y, effectType, color) {
		  const effect = {
			  type,
			  x,
			  y,
			  effectType,
			  color: color || '#FFFFFF',
			  startTime: Date.now(),
			  alpha: 1
		  };
		  collisionEffects.push(effect);
		  
		  setTimeout(() => {
			  const index = collisionEffects.indexOf(effect);
			  if (index > -1) {
				  collisionEffects.splice(index, 1);
			  }
		  }, type.includes('spawn') ? SPAWN_EFFECT_DURATION : EXPIRE_EFFECT_DURATION);
	  }
	
	  // collision visual effects / added
	  function createCollisionEffect(type, x, y, color) {
		const effect = {
			type,
			x,
			y,
			color,
			startTime: Date.now(),
			alpha: 1
		};
		collisionEffects.push(effect);
		
		// Remove effect after duration
		setTimeout(() => {
			const index = collisionEffects.indexOf(effect);
			if (index > -1) {
				collisionEffects.splice(index, 1);
			}
		}, EFFECT_DURATION);
	  }

    
      // --- Pour gérer l'orientation sur mobile tactile ---
    function onOrientationChange() {
      // Petit délai si besoin pour que la taille soit bien mise à jour
      setTimeout(handleresizeTactile, 200);
    }

    // --- Setup de la page de jeu ---
   async function setupGamePage() {
      if (isTouchDevice()) {
        console.log("Mode tactile activé");
        window.addEventListener('resize', handleresizeTactile);
        window.addEventListener('orientationchange', onOrientationChange);
        handleresizeTactile();
      } else {
        console.log("Mode non tactile activé");
        window.addEventListener('resize', handleResize);
        handleResize();
      }
    }

    // --- Cleanup de la page de jeu ---
    function cleanupGamePage() {
      if (isTouchDevice()) {
        window.removeEventListener('resize', handleresizeTactile);
        window.removeEventListener('orientationchange', onOrientationChange);
      } else {
        window.removeEventListener('resize', handleResize);
      }
    }
      
    function handleResize() {
      const ORIGINAL_WIDTH = 800;
      const ORIGINAL_HEIGHT = 400;
      const margin = 12; // Marge interne utilisée pour le positionnement
      const container = document.querySelector('.game-container');
      if (!container) return;
  
      // Dimensions du conteneur et de la fenêtre
      const containerWidth = container.clientWidth;
      const windowHeight = window.innerHeight;
  
      // Calcul du scale en fonction de l'espace disponible
      let scale = Math.min(containerWidth / ORIGINAL_WIDTH, windowHeight * 0.7 / ORIGINAL_HEIGHT);
  
      // Appliquer le scale sur le canvas (dimension affichée)
      canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
      canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';
  
      // Garder la résolution logique du canvas inchangée
      canvas.width = ORIGINAL_WIDTH;
      canvas.height = ORIGINAL_HEIGHT;
      
      // Ajuster dynamiquement la hauteur du game-container (en fonction de la largeur)
      container.style.height = Math.min(windowHeight * 0.8, containerWidth / 2) + 'px';
  
      ctx.imageSmoothingEnabled = false;
  
      // Utilisation du facteur d'échelle pour d'autres ajustements
      const s = scale;
  
      // Positionnement absolu de score-display par rapport à game-container
      // On considère que :
      //   - Le canvas est positionné en absolute dans le game-container (déjà défini dans votre CSS).
      //   - Le canvas est décalé d'une marge (margin) par rapport au bord supérieur et gauche du container.
      // On positionne alors le score-display pour qu'il soit centré horizontalement sur le bord supérieur du canvas.
      const scoreDisplay = document.getElementById("score-display");
      if (scoreDisplay) {
          // Assurez-vous que le game-container est en position relative (pour que le positionnement absolu se fasse par rapport à lui)
          container.style.position = "relative";
          // Le canvas devrait être positionné en absolute (vérifiez votre CSS)
          // Récupérer la position du canvas par rapport au container (offsetLeft et offsetTop fonctionnent si le container est en position relative)
          const canvasLeft = canvas.offsetLeft;
          const canvasTop = canvas.offsetTop;
          // Calculer la largeur affichée du canvas (en pixels)
          const canvasDisplayWidth = ORIGINAL_WIDTH * s;
  
          // Placer le score-display centré sur le bord supérieur du canvas.
          // On fixe sa position verticale à la même valeur que canvasTop (souvent égale à la marge appliquée)
          // et sa position horizontale au centre du canvas.
          scoreDisplay.style.position = "absolute";
          scoreDisplay.style.left = (canvasLeft + canvasDisplayWidth / 2) + "px";
          scoreDisplay.style.top = (canvasTop + 2) + "px";
          // Pour centrer le score-display par rapport à son point de positionnement, on décale de 50% de sa largeur.
          scoreDisplay.style.transform = "translate(-50%, 0)";
          scoreDisplay.style.transformOrigin = "center top";
  
          // On fixe la taille de la police en pixels pour éviter les fluctuations liées aux unités rem
          scoreDisplay.style.fontSize = (30 * s) + "px";
      }
  }


  function handleresizeTactile() {
    // Dimensions internes du canvas (logique du jeu inchangée)
    const ORIGINAL_WIDTH = 800;   // Utilisé pour la hauteur du terrain (après rotation)
    const ORIGINAL_HEIGHT = 400;  // Utilisé pour la largeur du terrain (après rotation)
    const margin = 20;            // Marge interne dans la game-container
    const horizontalExtra = 2 * margin; // 40px au total
    const baseControlHeight = 100; // Hauteur de base des boutons pour s = 1

    // Pour le calcul vertical total, on tient compte de :
    // - La hauteur affichée du terrain : ORIGINAL_WIDTH * s + horizontalExtra
    // - La hauteur du conteneur des boutons : baseControlHeight * s
    // - Le padding vertical du conteneur principal (#livegame) : 20 top + 20 bottom = 40
    // - Une marge fixe entre terrain et boutons : 5px
    // Total vertical = 800*s + 40 + 100*s + 45 = 900*s + 85
    const verticalExtra = 85;

    // Pour le calcul horizontal, nous utilisons la largeur disponible dans la colonne Bootstrap.
    const parentCol = document.getElementById('game-col');
    const availableWidth = parentCol ? parentCol.clientWidth : window.innerWidth;

    // Calcul de l'échelle horizontal : la largeur affichée du terrain sera ORIGINAL_HEIGHT * s + horizontalExtra
    const s_h = (availableWidth - horizontalExtra) / ORIGINAL_HEIGHT;

    // Calcul de l'échelle vertical : l'espace total requis verticalement est 900*s + 85, qui doit tenir dans window.innerHeight.
    const s_v = (window.innerHeight - verticalExtra) / 900;

    // On prend le facteur le plus contraignant
    const computedS = Math.min(s_h, s_v);

    // Calcul de l'échelle minimale pour que le terrain ait au moins 100px de largeur et 200px de hauteur.
    const sMinWidth = (100 - horizontalExtra) / ORIGINAL_HEIGHT;   // (100 - 40)/400 = 0.15
    const sMinHeight = (200 - horizontalExtra) / ORIGINAL_WIDTH;    // (200 - 40)/800 = 0.2
    const sMin = Math.max(sMinWidth, sMinHeight); // ici sMin = 0.2

    // On s'assure que l'échelle ne descend pas en dessous de sMin.
    const s = Math.max(computedS, sMin);

    // Mise à jour des dimensions du game-container (terrain)
    const gameContainer = document.querySelector('.game-container');
    if (!gameContainer) {
      console.error("L'élément '.game-container' est introuvable dans le DOM.");
      return;
    }
    gameContainer.style.width = (ORIGINAL_HEIGHT * s + horizontalExtra) + "px"; // 400*s + 40
    gameContainer.style.height = (ORIGINAL_WIDTH * s + horizontalExtra) + "px";  // 800*s + 40

    // Transformation du canvas pour le rendre vertical :
    const canvas = document.getElementById('gameCanvas');
    canvas.style.transform =
      `translate(${margin}px, ${margin}px) translateY(${ORIGINAL_WIDTH * s}px) rotate(-90deg) scale(${s})`;

    // Mise à jour de la hauteur du conteneur des boutons (touch-controls) en fonction de l'échelle.
    const controls = document.getElementById('left_player');
    const controlHeight = baseControlHeight * s;
    if (controls) {
      controls.style.height = controlHeight + "px";
    }

    // Transmet l'échelle aux boutons via la variable CSS --btn-scale pour qu'ils se redimensionnent proportionnellement.
    document.documentElement.style.setProperty('--btn-scale', s);

    // Mise à jour de la position de la zone de score pour l'accrocher entre le bord du game-container et celui du canvas (sans rotation)
const scoreDisplay = document.getElementById("score-display");
if (scoreDisplay) {
    // On souhaite que le score soit positionné de sorte que son centre soit à mi-distance
    // entre le bord gauche du game-container (0) et le bord gauche du canvas (qui est à "margin" pixels)
    const posX = margin / 2;  // Ceci correspond au point milieu horizontal
    // Pour le centrage vertical, on se base sur la hauteur actuelle du game-container.
    const posY = gameContainer.clientHeight / 2;
    
    // Positionnement absolu dans le game-container :
    scoreDisplay.style.left = posX + "px";
    scoreDisplay.style.top = posY + "px";
    
    // Appliquer un translate(-50%, -50%) pour que le centre de la zone corresponde à ce point,
    // sans aucune rotation (le texte reste dans son orientation normale)
    scoreDisplay.style.transform = "translate(-50%, -50%)";
    scoreDisplay.style.transformOrigin = "center";
    
    // Adaptez la taille de la police en fonction du scale, pour qu'elle reste proportionnelle
    scoreDisplay.style.fontSize = (1.5 * s) + "rem";
}

}
  
    // 4) Initialiser WebSocket
    const socket = new WebSocket(config.wsUrl);
    
    socket.onopen = () => {
      console.log("[live_game_utils] WebSocket connection opened:", config.wsUrl);
      initializeTouchControls(config.userRole, socket);
    };
    socket.onclose = () => {
      console.log("[live_game_utils] WebSocket connection closed.");
    };
  
    // 5) Gérer l'état du jeu local
    const activeEffects = { left: new Set(), right: new Set() };
    const effectTimers = {};
    let gameState = {
      type: 'game_state',
      ball_x: 400, 
      ball_y: 200,
      ball_size: 7,
      ball_speed_x: 4,
      ball_speed_y: 4,
      paddle_left_y: 170,
      paddle_right_y: 170,
      paddle_width: 10,
      paddle_left_height: 60,
      paddle_right_height: 60,
      score_left: 0, 
      score_right: 0,
      powerups: [],
      bumpers: [],
      flash_effect: false
    };
	// let showCountdown = false;
    // let countdownNumber = 3;
  
    // 6) Gérer la réception de messages WebSocket
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
  
      if (data.type === 'game_state') {
        // Mémoriser les effets actifs avant maj
        const prevLeft = new Set(activeEffects.left);
        const prevRight = new Set(activeEffects.right);
        gameState = data;
        // Réinjecter
        activeEffects.left = prevLeft;
        activeEffects.right = prevRight;
      }  else if (data.type === 'powerup_spawned') {
		const powerupColor = {
			'invert': '#FF69B4',
			'shrink': '#FF0000',
			'ice': '#00FFFF',
			'speed': '#FFD700',
			'flash': '#FFFF00',
			'sticky': '#32CD32'
		}[data.powerup.type] || '#FFFFFF';
		
		createSpawnEffect('powerup_spawn', 
			data.powerup.x, 
			data.powerup.y, 
			data.powerup.type,
			powerupColor);
	  } else if (data.type === 'powerup_expired') {
		createSpawnEffect('powerup_expire',
			data.powerup.x,
			data.powerup.y,
			data.powerup.type);
		} else if (data.type === 'bumper_spawned') {
			createSpawnEffect('bumper_spawn',
				data.bumper.x,
				data.bumper.y);
			
		} else if (data.type === 'bumper_expired') {
			createSpawnEffect('bumper_expire',
				data.bumper.x,
				data.bumper.y);
    } else if (data.type === 'countdown') {
      // Stocker le compte à rebours dans le gameState
      gameState.countdown = data.countdown_nb;
      // drawCountdown(data.countdown_nb);
		} else if (data.type === 'collision_event') {
			const collision = data.collision;
			switch(collision.type) {
				case 'paddle_collision':
					createCollisionEffect('paddle_collision', 
						collision.paddle_side === 'left' ? 60 : canvas.width - 60, 
						gameState.ball_y);
					break;
					
				case 'border_collision':
					createCollisionEffect('border_collision',
						collision.coor_x_collision,
						collision.border_side === 'up' ? 50 : 350);
					break;
					
				case 'bumper_collision':
					createCollisionEffect('bumper_collision',
						collision.bumper_x,
						collision.bumper_y);
					break;
			}
		}
		else if (data.type === 'game_over') {
        console.log("[live_game_utils] Game over detected");
        // alert("Game Over! Winner = " + data.winner);
        socket.close();
        resolve();  // 🔹 Signale à `runTournamentFlow()` que la partie est terminée
      }
      else if (data.type === 'powerup_applied') {
        // console.log(`[live_game_utils] Power-up applied to ${data.player}: ${data.effect}`);
        if (data.effect === 'flash') {
          applyFlashEffect(gameState);
          return;
        }
        let displaySide = data.player;
        if (!['speed','sticky'].includes(data.effect)) {
          // Les autres s'appliquent à l'adversaire
          displaySide = (data.player === 'left') ? 'right' : 'left';
        }
        activeEffects[displaySide].add(data.effect);
  
        // Timer pour retirer l'effet
        if (effectTimers[`${displaySide}_${data.effect}`]) {
          clearTimeout(effectTimers[`${displaySide}_${data.effect}`]);
        }
        effectTimers[`${displaySide}_${data.effect}`] = setTimeout(() => {
          console.log(`[live_game_utils] Removing effect ${data.effect} for ${displaySide}`);
          activeEffects[displaySide].delete(data.effect);
        }, data.duration * 1000);
      }
    };
  
    // 7) Gérer le clavier et les touches tactiles
    function initializeTouchControls(userRole, socket) {
      // On active les contrôles tactiles uniquement si on est en mode tactile
      if (!isTouchDevice()) return; // Si pas tactile, on ne fait rien ici.
    
      // Gestion globale du double tap pour empêcher le zoom
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
          // Si deux touchend se succèdent rapidement, on annule l'action par défaut
          e.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
    
      // Sélectionnez les boutons par leur id
      const btnUp = document.getElementById("touch1");
      const btnDown = document.getElementById("touch2");
    
      // Vérifiez que les boutons existent
      if (!btnUp || !btnDown) {
        console.error("Les boutons tactiles ne sont pas définis dans le DOM.");
        return;
      }
    
      // Pour le bouton "up"
      btnUp.addEventListener('touchstart', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "up"
        }));
      });
      btnUp.addEventListener('touchend', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "stop_move",
          player: userRole
        }));
      });
      // Optionnel pour le clic (au cas où)
      btnUp.addEventListener('click', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "up"
        }));
        setTimeout(() => {
          socket.send(JSON.stringify({
            action: "stop_move",
            player: userRole
          }));
        }, 200);
      });
    
      // Pour le bouton "down"
      btnDown.addEventListener('touchstart', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "down"
        }));
      });
      btnDown.addEventListener('touchend', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "stop_move",
          player: userRole
        }));
      });
      btnDown.addEventListener('click', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "down"
        }));
        setTimeout(() => {
          socket.send(JSON.stringify({
            action: "stop_move",
            player: userRole
          }));
        }, 200);
      });
    }    

    if (!isTouchDevice()) {
    const keysPressed = {};
  
    document.addEventListener('keydown', (evt) => {
      if (evt.repeat) return;
      let action = "start_move";
      let player = null, direction = null;
  

      if (config.userRole === 'both') {
        switch(evt.key) {
          case 'w':
          case 'W':
            player = 'left';
            direction = 'up';
            break;
          case 's':
          case 'S':
            player = 'left';
            direction = 'down';
            break;
          case 'ArrowUp':
            player = 'right';
            direction = 'up';
            break;
          case 'ArrowDown':
            player = 'right';
            direction = 'down';
            break;
        }
      }
	  else if (config.userRole === 'right') {
        switch(evt.key) {
			case 'ArrowUp':
			  player = 'right';
			  direction = 'up';
			  break;
			case 'ArrowDown':
			  player = 'right';
			  direction = 'down';
			  break;
		  }
      }
      else if (config.userRole === 'left') {
        switch(evt.key) {
          case 'ArrowUp':
            player = 'left';
            direction = 'up';
            break;
          case 'ArrowDown':
            player = 'left';
            direction = 'down';
            break;
        }
      }
  
      if (player && direction && !keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player, direction }));
        }
        keysPressed[evt.key] = true;
        // console.log(`[live_game_utils] start_move: ${player}, ${direction}`);
      }
    });
  
    document.addEventListener('keyup', (evt) => {
      let action = "stop_move";
      let player = null;
  
      if (config.userRole === 'both') {
        if (['w','W','s','S'].includes(evt.key)) {
          player = 'left';
        }
      }
      
      if ((config.userRole === 'both' || config.userRole === 'right' || config.userRole === 'left') && !player) {
        if (['ArrowUp','ArrowDown'].includes(evt.key)) {
          if(config.userRole === 'both' || config.userRole === 'right')
		  	player = 'right';
		  else if(config.userRole === 'left')
		  	player = 'left';
        }
      }
  
      if (player && keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player}));
        }
        keysPressed[evt.key] = false;
        // console.log(`[live_game_utils] stop_move: ${player}`);
      }
    });
  }


    
  
    // 8) Préparer les images powerups/bumper
    const powerupImages = {
      'invert': new Image(),
      'shrink': new Image(),
      'ice': new Image(),
      'speed': new Image(),
      'flash': new Image(),
      'sticky': new Image()
    };
    initPowerupImages(powerupImages);
  
    const bumperImage = new Image();
    bumperImage.src = createBumperSVG();


	// // -- Fonction pour démarrer la partie
  //   async function startGameWithCountdown(startGameBtn, onStartGame, gameId) {
	// 	showCountdown = true;
	// 	startGameBtn.classList.add('d-none');
		
	// 	// Start countdown animation
	// 	let count = 3;
		
	// 	// Function to update the countdown
  //   const updateCount = async () => {
	// 		countdownNumber = count;
	// 		count--;
			
	// 		if (count < 0) {
	// 			clearInterval(countdownInterval);
	// 			showCountdown = false;
	// 			// onStartGame && await onStartGame(gameId);
	// 		}
	// 	};
	
	// 	// Show first number immediately
	// 	updateCount();
		
	// 	// Then update every second
	// 	const countdownInterval = setInterval(updateCount, 1000);
	// }

  // async function displayCountdownNumber(countdown_nb, startGameBtn) {
	// 	showCountdown = true;
    
	// 	drawCountdown(countdown_nb)
		// Start countdown animation
		// let count = 3;
		
		// // Function to update the countdown
    // const updateCount = async () => {
		// 	countdownNumber = count;
		// 	count--;
			
		// 	if (count < 0) {
		// 		clearInterval(countdownInterval);
		// 		showCountdown = false;
		// 		// onStartGame && await onStartGame(gameId);
		// 	}
		// };
	
		// // Show first number immediately
		// updateCount();
		
		// // Then update every second
		// const countdownInterval = setInterval(updateCount, 1000);
	// }
  
    // 9) La boucle de dessin
    function draw() {
      if (gameState.flash_effect) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#101A32';
        ctx.fillRect(0,0,canvas.width, canvas.height);
  
        // Zone de jeu
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(50,50, canvas.width-100, canvas.height-100);
  
        // Dessin raquettes
        ['left','right'].forEach(side => {
          ctx.save();
          if (activeEffects[side].size > 0) {
            activeEffects[side].forEach(effect => {
              const glowColor = {
                'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
                'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
              }[effect];
              ctx.shadowColor = glowColor;
              ctx.shadowBlur = 10 * scale;
            });
          }
          ctx.fillStyle = 'white';
          if (side==='left') {
            ctx.fillRect(50, gameState.paddle_left_y,
                        gameState.paddle_width, gameState.paddle_left_height);
          } else {
            ctx.fillRect(canvas.width-50 - gameState.paddle_width, 
                        gameState.paddle_right_y,
                        gameState.paddle_width, gameState.paddle_right_height);
          }
          ctx.restore();
        });
  
        // Balle
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(gameState.ball_x, gameState.ball_y, gameState.ball_size, 0, 2*Math.PI);
        ctx.fill();
  
        // Powerups
        gameState.powerups.forEach(orb => {
          const type = orb.type || 'speed';
          const img = powerupImages[type];
          if (img.complete) {
            ctx.save();
            const glowColors = {
              'invert':'#FF69B4','shrink':'#FF0000','ice':'#00FFFF',
              'speed':'#FFD700','flash':'#FFFF00','sticky':'#32CD32'
            };
            ctx.shadowColor = glowColors[type] || '#FFD700';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(img, orb.x - 15, orb.y - 15, 30, 30);
            ctx.restore();
          }
        });
  
        // Bumpers
        gameState.bumpers.forEach(bmp => {
          if (bumperImage.complete) {
            ctx.save();
            ctx.shadowColor = '#4169E1';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(bumperImage,
              bmp.x - bmp.size, bmp.y - bmp.size,
              bmp.size*2, bmp.size*2
            );
            ctx.restore();
          }
        });
      }
  
      // Scores
      // ctx.fillStyle = 'white';
      // ctx.font = '20px Arial';
      // ctx.fillText(""+ gameState.score_left, 20, 30);
      // ctx.fillText(""+ gameState.score_right, canvas.width-40, 30);
      
      function updateScoreDisplay() {
        const scoreEl = document.getElementById("score-nb");
        if (scoreEl) {
          // Ici, on suppose que les noms sont déjà injectés via Django dans le HTML.
          // Par exemple, on pourrait avoir utilisé des attributs data pour conserver ces noms.
          // Si ce n'est pas le cas, vous pouvez également définir des variables globales injectées par Django.
          // Ici, nous allons lire le texte initial et remplacer uniquement la partie numérique.
          // Pour plus de flexibilité, vous pouvez modifier cette fonction selon vos besoins.
          // Exemple avec des attributs data (optionnel) :
          scoreEl.innerText = ` ${gameState.score_left} - ${gameState.score_right} `;
        }
        }

      // Affichage powerups actifs
      const powerupNames = {
        'speed':'SPEED','shrink':'SHRINK','ice':'ICE','sticky':'STICKY','invert':'INVERT'
      };
      // Gauche
      if (activeEffects.left.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.left.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          ctx.fillText(powerupNames[effect], 20, yOffset);
          yOffset+=25;
        });
      }
      // Droite
      if (activeEffects.right.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.right.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          const tW = ctx.measureText(powerupNames[effect]).width;
          ctx.fillText(powerupNames[effect], canvas.width-20 - tW, yOffset);
          yOffset+=25;
        });
      }
    updateScoreDisplay();
	  drawCollisionEffects();
	  drawCountdown();
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  
    // on peut retourner un objet si on veut
    return {
      socket,
      getGameState: () => gameState
    };
  });
}
  
===== ./landing/coreHome.js =====
import { requestGet } from '../api/index.js';
import { HTTPError } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

function attachNavigationEvents() {
    const loginBtn = document.querySelector('#login-btn');
    if (loginBtn) {
        loginBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('login clicked');
            navigateTo('/login'); // Utiliser Navigo pour naviguer
        });
    }

    const registerBtn = document.querySelector('#register-btn');
    if (registerBtn) {
        registerBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('register clicked');
            navigateTo('/register'); // Utiliser Navigo pour naviguer
        });
    }
}

export async function initializeHomeView() {
    console.log('initializeHomeView');
    try {
        const data = await requestGet('core', 'home');

        if (data && data.html) {
            updateHtmlContent('#content', data.html);
        } else {
            console.error("Les données HTML de la page d'accueil sont manquantes.");
            showStatusMessage("Impossible de charger la page d'accueil.", 'error');
            return;
        }

    } catch (error) {
        if (error instanceof HTTPError) {
            if (error.status === 403) {
                console.error('Erreur 403 : Utilisateur déjà authentifié');
                showStatusMessage('Vous êtes déjà connecté. Redirection...', 'error');
                navigateTo('/home');
                return;
            }
        } else {
            console.error('Erreur non traitée lors de la récupération de core home :', error);
            showStatusMessage("Une erreur inattendue est survenue. Veuillez réessayer.", 'error');
        }
    }

    attachNavigationEvents();
    console.log('Fin de initializeHomeView');
}


===== ./main.js =====
// main.js

// Import des modules transverses
import { handleNavbar } from './navbar/index.js';
import { loadPongAnimation } from './modules/groundAnimation.js';
import { adjustBurgerHeight } from './modules/animations.js';
import { adjustSinNavHeight } from './modules/animations.js';
import { adjustContainerIfExists } from './modules/animations.js';
import { adjustAllContainers } from './modules/animations.js';
import { initializeRouter } from './router.js'; // Nouveau routeur Navigo

document.addEventListener('DOMContentLoaded', async () => {
    // Charger la navbar
    console.log('DOMContentLoaded');
    await handleNavbar();

    // Initialiser le routeur Navigo
    initializeRouter();

    // Charger les animations et ajustements au démarrage
    loadPongAnimation();
    adjustAllContainers(); // Pour resize
    adjustBurgerHeight(); // Pour load
    adjustSinNavHeight(); // Pour load
    adjustContainerIfExists('login'); // Pour load
    adjustContainerIfExists('register'); // Pour load
	adjustContainerIfExists('bracket_tournament'); // Pour load
});
===== ./modules/animations.js =====
// Ajuster la hauteur du menu burger avec marges
export function adjustBurgerHeight() {
    const navAndMarginHeight = 66; // Hauteur navbar et marge pour le menu burger
    const availableHeight = window.innerHeight - navAndMarginHeight;
    document.documentElement.style.setProperty('--burger-height', `${availableHeight}px`);
}

// Ajuster la hauteur sans la barre navigation
export function adjustSinNavHeight() {
    const navAndMarginHeight = 50; // Hauteur sans la navbar
    const availableHeight = window.innerHeight - navAndMarginHeight;
    document.documentElement.style.setProperty('--sin-nav-height', `${availableHeight}px`);
}


//Fonction responsive
function adjustContainer(ContainerId) {
  console.log("Rentre dans adjust container");
	const container = document.getElementById(ContainerId);
	if (!container) {
    console.log("adjustContainer: container error");
    return;
  } 
	const threshold = 50; // Seuil de hauteur pour activer le centrage
	// Si le contenu dépasse la hauteur de l'écran, on enlève `center-content`
	if (container.scrollHeight > window.innerHeight - threshold) {
		container.classList.remove('center-content');
		container.classList.add('normal-content');
	} else {
    container.classList.add('center-content');
		container.classList.remove('normal-content');
	}
}


/**
 * Vérifie si un élément avec l'ID spécifié existe dans le DOM
 * et appelle adjustContainer si l'élément est présent.
 * @param {string} containerId - L'ID de l'élément à ajuster.
 */
export function adjustContainerIfExists(containerId) {
    const container = document.getElementById(containerId);
    if (container) {
        adjustContainer(containerId);
    }
}


//[IMPROVE] Faire en sorte que adjustContainer login et register soit bind en event uniquement au chargement de leurs pages respectives pour éviter de les appeler inutilement

export function adjustAllContainers() {

    window.addEventListener('resize', () => {
        adjustBurgerHeight();
        adjustSinNavHeight();
        adjustContainerIfExists('login');
        adjustContainerIfExists('register');
		adjustContainerIfExists('bracket_tournament');
    });
}

===== ./modules/groundAnimation.js =====
// Configuration et données des frames
const terrainConfig = {
	width: 80, // en pourcentage (vw)
	height: 40 // en pourcentage (vh)
  };
  
  const frames = [
	{ balleX: 1, balleY: 47, raquetteGaucheY: 36.5, raquetteDroiteY: 36.5 },
	{ balleX: 48, balleY: 0, raquetteGaucheY: 0, raquetteDroiteY: 73 },
	{ balleX: 97, balleY: 47, raquetteGaucheY: 47, raquetteDroiteY: 26 },
	{ balleX: 41, balleY: 95, raquetteGaucheY: 7, raquetteDroiteY: 69 },
	{ balleX: 1, balleY: 60, raquetteGaucheY: 60, raquetteDroiteY: 10 },
	{ balleX: 53, balleY: 0, raquetteGaucheY: 7, raquetteDroiteY: 65 },
	{ balleX: 97, balleY: 37, raquetteGaucheY: 67, raquetteDroiteY: 32 },
	{ balleX: 48, balleY: 95, raquetteGaucheY: 7, raquetteDroiteY: 73 }
  ];
  
  const transitionTime = 2200; // Temps de transition en ms
  let currentFrame = 0;
  let animationRunning = true;
  
  // Sélection des éléments
  const balle = document.querySelector('.balle');
  const traitGauche = document.querySelector('.trait-gauche');
  const traitDroit = document.querySelector('.trait-droit');
  
  /**
   * Initialise les positions des éléments (balle, raquettes) à partir de la première frame.
   */
  function initPositions() {
	setPositions(frames[0]);
  }
  
  /**
   * Met à jour les positions des éléments en fonction de la frame donnée.
   * @param {Object} frame - Frame contenant les positions de la balle et des raquettes.
   */
  function setPositions(frame) {
	balle.style.left = frame.balleX + '%';
	balle.style.top = frame.balleY + '%';
	traitGauche.style.top = frame.raquetteGaucheY + '%';
	traitDroit.style.top = frame.raquetteDroiteY + '%';
  }
  
  /**
   * Déplace la balle et les raquettes avec interpolation entre les frames.
   */
  function deplacerBalleEtRaquettes() {
	if (!animationRunning) return;
  
	const frameActuelle = frames[currentFrame];
	const prochaineFrame = frames[(currentFrame + 1) % frames.length];
	let startTime = null;
  
	function animate(time) {
	  if (!animationRunning) return;
  
	  if (!startTime) startTime = time;
	  const progress = (time - startTime) / transitionTime;
  
	  if (progress < 1) {
		updatePositions(frameActuelle, prochaineFrame, progress);
		requestAnimationFrame(animate);
	  } else {
		currentFrame = (currentFrame + 1) % frames.length;
		requestAnimationFrame(deplacerBalleEtRaquettes);
	  }
	}
  
	requestAnimationFrame(animate);
  }
  
  /**
   * Met à jour les positions interpolées de la balle et des raquettes.
   * @param {Object} frameActuelle - Frame actuelle.
   * @param {Object} prochaineFrame - Frame suivante.
   * @param {number} progress - Progression de l'interpolation (de 0 à 1).
   */
  function updatePositions(frameActuelle, prochaineFrame, progress) {
	balle.style.left = interpolate(frameActuelle.balleX, prochaineFrame.balleX, progress) + '%';
	balle.style.top = interpolate(frameActuelle.balleY, prochaineFrame.balleY, progress) + '%';
	traitGauche.style.top = interpolate(frameActuelle.raquetteGaucheY, prochaineFrame.raquetteGaucheY, progress) + '%';
	traitDroit.style.top = interpolate(frameActuelle.raquetteDroiteY, prochaineFrame.raquetteDroiteY, progress) + '%';
  }
  
  /**
   * Fonction d'interpolation linéaire.
   * @param {number} start - Valeur de départ.
   * @param {number} end - Valeur d'arrivée.
   * @param {number} progress - Progression entre 0 et 1.
   * @returns {number} - Valeur interpolée.
   */
  function interpolate(start, end, progress) {
	return start + (end - start) * progress;
  }
  
/**
 * Arrête l'animation.
 */
export function stopPongAnimation() {
  animationRunning = false;
  }
  

export async function loadPongAnimation() {
    // Initialisation et lancement
    initPositions();
    deplacerBalleEtRaquettes();
  }

===== ./navbar/index.js =====
// navbar/index.js
export { handleNavbar } from './loadNavbar.js';
export { toggleBurgerMenu } from './toggleBurgerMenu.js';

===== ./navbar/delegation.js =====
// burgerMenu/delegation.js

/**
 * Initialise la délégation d'événements pour gérer la fermeture du burger menu.
 */
export function initBurgerMenuDelegation() {
    // Gestion du clic extérieur pour fermer le menu
    document.addEventListener('click', (event) => {
        const menu = document.getElementById('burger-menu');
        const burgerToggle = document.getElementById('burger-menu-toggle');
        const overlay = document.getElementById('overlay');
        if (!menu || !burgerToggle || !overlay) return;

        // Si le menu est affiché et que le clic se fait en dehors du menu et du toggle...
        if (
            menu.style.display === 'block' &&
            !menu.contains(event.target) &&
            !burgerToggle.contains(event.target)
        ) {
            menu.style.display = 'none';
            overlay.style.display = 'none';
        }
    });

    // Gestion déléguée pour les boutons qui ferment le burger menu
    document.addEventListener('click', (event) => {
        if (event.target.matches('#profile-btn, #play-btn, #settings-link, #view-profile-btn')) {
            const menu = document.getElementById('burger-menu');
            const overlay = document.getElementById('overlay');
            if (menu && overlay) {
                menu.style.display = 'none';
                overlay.style.display = 'none';
            }
        }
    });
}

===== ./navbar/loadNavbar.js =====
// loadnavbar.js

import { toggleBurgerMenu } from './toggleBurgerMenu.js';
import { requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { initBurgerMenuDelegation } from './delegation.js'; // Notre module de délégation
import { eventsHandlerBurgerMenu } from '../burgerMenu/index.js';
import { navigateTo } from '../router.js'; // Pour naviguer

/**
 * Initialise le burger menu : attache l'événement sur le bouton de toggle.
 */
async function initializeBurgerMenu(flag) {
    const burgerToggle = document.querySelector('#burger-menu-toggle');
    if (burgerToggle && !burgerToggle.dataset.bound) {
        burgerToggle.addEventListener('click', () => toggleBurgerMenu(flag));
        burgerToggle.dataset.bound = true; // Marque comme attaché
        console.log('Événements du burger menu initialisés.');
    }
}

function handleHomeButtonClick(isAuthenticated) {
    if (isAuthenticated) {
        // Redirige vers la page de jeu
        navigateTo('/home');
    } else {
        // Redirige vers la page de connexion
        navigateTo('/');
    }
}

/**
 * Charge et affiche la navbar, puis initialise le burger menu.
 */
async function loadNavbar() {
    console.log('Début de loadNavbar');
    try {
        // Récupère les données de la navbar
        const data = await requestGet('core', 'navbar');

        if (data && data.html) {
            // Met à jour le contenu HTML de la navbar
            updateHtmlContent('#navbar', data.html);
            console.log('Contenu de la navbar mis à jour.');

            // Attache l'événement au bouton "home"
            const homeButton = document.querySelector('#home-btn');
            if (homeButton && !homeButton.dataset.bound) {
                homeButton.addEventListener('click', () => handleHomeButtonClick(data.is_authenticated));
                homeButton.dataset.bound = true;
            }

            return data.is_authenticated;
        } else {
            console.error('Les données HTML de la navbar sont manquantes.');
            showStatusMessage('Impossible de charger la barre de navigation.', 'error');
            return false;
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la navbar:', error);
        showStatusMessage('Une erreur est survenue lors du chargement de la barre de navigation.', 'error');
        throw error;
    } finally {
        console.log('Fin de loadNavbar');
    }
}

/**
 * Rafraîchit le contenu du burger menu.
 */
export async function refreshBurgerMenu() {
    try {
        let menu = document.getElementById('burger-menu');
        let overlay = document.getElementById('overlay');

        if (!menu || !overlay) return;

        const data = await requestGet('accounts', 'burgerMenu');
        if (data.status === 'success') {
            // Mise à jour du contenu du burger menu selon son état d'affichage
            if (menu.style.display === 'block') {
                updateHtmlContent('#burger-menu-container', data.html);
                menu = document.getElementById('burger-menu');
                overlay = document.getElementById('overlay');
                menu.style.display = 'block';
                overlay.style.display = 'block';
            } else {
                updateHtmlContent('#burger-menu-container', data.html);
                menu = document.getElementById('burger-menu');
                overlay = document.getElementById('overlay');
                menu.style.display = 'none';
                overlay.style.display = 'none';
            }
            // Réinitialise le burger menu (pour le bouton de toggle, etc.)
            initializeBurgerMenu('refresh btn');
            eventsHandlerBurgerMenu();

            console.log('Burger menu mis à jour avec succès.');
        } else {
            console.warn('Burger menu non mis à jour, statut:', data.status);
        }
    } catch (error) {
        console.error('Erreur lors du rafraîchissement du burger menu:', error);
    }
}

/**
 * Gère le chargement de la navbar et du burger menu.
 */
export async function handleNavbar() {
    console.log('Chargement de la navbar...');
    try {
        const is_authenticated = await loadNavbar();

        if (is_authenticated) {
            await initializeBurgerMenu(null);
            // Initialise la délégation d'événements pour le burger menu
            initBurgerMenuDelegation();
            eventsHandlerBurgerMenu();
            console.log('Navbar et burger menu chargés avec succès.');
            // Rafraîchissement périodique si l'utilisateur est authentifié
            setInterval(refreshBurgerMenu, 10000);
        } else {
            console.log('Utilisateur non authentifié ou erreur de chargement.');
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la navbar dans handleNavbar:', error);
        showStatusMessage('Erreur lors du chargement de la barre de navigation. Veuillez réessayer.', 'error');
    }
}

===== ./navbar/toggleBurgerMenu.js =====
// toggleBurgerMenu.js

/**
 * Affiche ou masque le burger menu.
 *
 * @param {string} flag - Un flag éventuel pour certains cas particuliers (ex: "refresh btn").
 */
export function toggleBurgerMenu(flag) {
    console.log('toggleBurgerMenu');
    const menu = document.getElementById('burger-menu');
    const overlay = document.getElementById('overlay');
    if (flag === 'refresh btn') return;
    if (!menu || !overlay) return;

    if (menu.style.display === 'block') {
        closeBurgerMenu(menu, overlay);
    } else {
        openBurgerMenu(menu, overlay);
    }
}

function openBurgerMenu(menu, overlay) {
    menu.style.display = 'block';
    overlay.style.display = 'block';
}

function closeBurgerMenu(menu, overlay) {
    menu.style.display = 'none';
    overlay.style.display = 'none';
}

===== ./tools/displayInfo.js =====
/**
 * Affiche un message de succès dans un élément spécifié.
 * @param {string} elementId - L'ID de l'élément où afficher le message.
 * @param {string} message - Le message de succès à afficher.
 */
export function displaySuccessMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'green';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Affiche un message d'erreur dans un élément spécifié.
 * @param {string} elementId - L'ID de l'élément où afficher le message.
 * @param {string} message - Le message d'erreur à afficher.
 */
export function displayErrorMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'red';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Affiche un message d'information dans un élément spécifié.
 * @param {string} elementId - L'ID de l'élément où afficher le message.
 * @param {string} message - Le message d'information à afficher.
 */
export function displayInfoMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'blue';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Efface les messages affichés dans un élément spécifié.
 * @param {string} elementId - L'ID de l'élément dont le contenu doit être effacé.
 */
export function clearMessage(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = '';
        element.style.display = 'none';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

export function showStatusMessage (message, status) {
    const popup = document.getElementById('popup');
    const info = document.getElementById('info');

    // Définir le message
    info.textContent = message;

    // Supprimer les anciennes classes
    popup.classList.remove('success', 'error', 'd-none', 'hide');

    // Ajouter la classe appropriée
    if (status === 'success') {
        popup.classList.add('success');
    } else if (status === 'error') {
        popup.classList.add('error');
    }

    // Afficher le popup
    popup.classList.add('show');

    // Cacher automatiquement après 3 secondes
    setTimeout(() => {
        popup.classList.remove('show');
        popup.classList.add('hide');
        setTimeout(() => popup.classList.add('d-none'), 500);
    }, 3000);
}
===== ./tools/domHandler.js =====
// Utilitaire pour mettre à jour le contenu texte d'un élément HTML
/**
 * Met à jour le texte affiché d'un élément HTML sélectionné.
 *
 * @param {string} selector - Sélecteur CSS pour cibler l'élément HTML.
 * @param {string} text - Contenu texte à insérer dans l'élément.
 *
 * Cette fonction utilise `querySelector` pour sélectionner **le premier élément**
 * correspondant au sélecteur fourni.
 * 
 * - Si le sélecteur est une **classe combinée** comme `.profile-info h3`, la fonction
 *   va chercher **le premier `<h3>`** trouvé à l'intérieur de l'élément ayant la classe `profile-info`.
 * - Si l'élément a un **`id` unique** (ex. : `id="profile-username"`), vous pouvez le cibler directement
 *   avec le sélecteur `#profile-username`, ce qui est plus précis et performant.
 *
 * Si l'élément correspondant n'est pas trouvé dans le DOM, la fonction ne fait rien
 * et ne lève aucune erreur.
 *
 * Exemple d'utilisation avec une classe combinée :
 * updateTextContent('.profile-info h3', 'Pseudo : JohnDoe');
 *
 * Exemple d'utilisation avec un `id` :
 * updateTextContent('#profile-username', 'Pseudo : JohnDoe');
 *
 * Résultat attendu dans le DOM :
 * Avant : <h3 class="profile-info">Pseudo :</h3>
 * Après : <h3 class="profile-info">Pseudo : JohnDoe</h3>
 */
export function updateTextContent(selector, text) {
    const element = document.querySelector(selector); // Sélectionne le premier élément correspondant au sélecteur
    if (element) {
        element.textContent = text; // Modifie le contenu texte de l'élément
    }
}

// Utilitaire pour mettre à jour un attribut d'un élément HTML
/**
 * Met à jour un attribut spécifique d'un élément HTML sélectionné.
 *
 * @param {string} selector - Sélecteur CSS pour cibler l'élément HTML.
 * @param {string} attribute - Nom de l'attribut à mettre à jour (par ex. : `src`, `alt`, `href`).
 * @param {string} value - Nouvelle valeur à attribuer à l'attribut.
 *
 * Cette fonction utilise `querySelector` pour sélectionner **le premier élément**
 * correspondant au sélecteur fourni.
 * 
 * - Si le sélecteur est une **classe combinée** comme `.profile-info img`, la fonction
 *   va chercher **la première balise `<img>`** trouvée à l'intérieur de l'élément ayant la classe `profile-info`.
 * - Si l'élément possède un **`id` unique**, il est recommandé d'utiliser ce `id` directement
 *   dans le sélecteur (ex. : `#profile-avatar`) pour une sélection plus rapide et précise.
 *
 * Si l'élément correspondant n'est pas trouvé dans le DOM, la fonction ne fait rien
 * et ne lève aucune erreur.
 *
 * Exemple d'utilisation avec une classe combinée :
 * updateAttribute('.profile-info img', 'src', '/path/to/image.jpg');
 *
 * Exemple d'utilisation avec un `id` :
 * updateAttribute('#profile-avatar', 'src', '/path/to/image.jpg');
 *
 * Résultat attendu dans le DOM :
 * Avant : <img class="profile-info" src="" alt="">
 * Après : <img class="profile-info" src="/path/to/image.jpg" alt="">
 */
export function updateAttribute(selector, attribute, value) {
    const element = document.querySelector(selector);
    console.log(`Sélecteur : ${selector}, Élément trouvé :`, element);
    if (element) {
        element.setAttribute(attribute, value);
        console.log(`Attribut ${attribute} mis à jour avec la valeur : ${value}`);
    } else {
        console.error(`Élément non trouvé pour le sélecteur : ${selector}`);
    }
}

//Ajout et modification dynamique du html dans les divs
// Selector = #content ou #navbar 
//  [IMPROVE] A voir aussi ou inclure le bruger menu 
export function updateHtmlContent(selector, html) {
    console.log(`rentre dans updateHtmlContent selector =`, selector);
    if (!html)
            console.log('html est vide');
    try {
        // Mise à jour du contenu à partir des données reçues
        document.querySelector(selector).innerHTML = html;
    } catch {
        //[IMPROVE] faire un autre throw ici pour gerer l' erreur dans les fonctions specialisees
        document.querySelector(selector).innerHTML = '<p>Une erreur est survenue lors du chargement du contenu.</p>';
    }
}


===== ./tools/clearSession.js =====
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer


/**
 * Supprime les tokens, nettoie l'interface utilisateur et redirige vers une URL donnée.
 * @param {string} redirectUrl - L'URL vers laquelle rediriger après le nettoyage. (Par défaut : '#core-home')
 */
export function clearSessionAndUI(redirectUrl = '/') {
    console.log('Nettoyage de la session et de l\'interface utilisateur...');

    // Suppression des tokens
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');

    // Nettoyage de l'interface utilisateur
    const navbar = document.querySelector('#navbar');
    const burgerMenu = document.querySelector('#burger-menu');
    const content = document.querySelector('#content');

    if (navbar) navbar.innerHTML = '';
    if (burgerMenu) burgerMenu.innerHTML = '';
    if (content) content.innerHTML = '';

    // Redirection
    navigateTo(redirectUrl);
    location.reload();
    

    console.log(`Redirection vers ${redirectUrl}`);
}

===== ./tools/errorPage.js =====
import { requestGet } from "../api/index.js";
import { updateHtmlContent } from "./domHandler.js";

export async function initializeNotFoundView()
{
    const response = await requestGet('core', '404');
    if (response.status === 'success')
        updateHtmlContent('#content', response.html)
}

===== ./tools/index.js =====

// Fonctions génériques pour l'affichages d'informations
export { displayErrorMessage, displaySuccessMessage, clearMessage, displayInfoMessage, showStatusMessage } from './displayInfo.js';

export { updateTextContent, updateAttribute , updateHtmlContent} from './domHandler.js';
export { isTouchDevice, resetScrollPosition } from './utility.js';

// Fonction générique, supprime les tokens et remet à zéro l'interface utilisateur
export {clearSessionAndUI} from './clearSession.js';

export {initializeNotFoundView} from './errorPage.js';

===== ./tools/utility.js =====
//utility.js
//fonctions que l' on ne sait pas encore ou mettre mais qui sont en rapport avec le jeu sur tel(loading screen)


export function isTouchDevice() {
  return Boolean(
    ('ontouchstart' in window) || 
    (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || 
    (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0)
  );
}
  

export function resetScrollPosition() {
    // document.scrollingElement est supporté par la majorité des navigateurs modernes.
    console.log("resetScrollPosition");
    const scrollingElement = document.scrollingElement || document.documentElement;
    scrollingElement.scrollTop = 0;
  }
===== ./userProfile/index.js =====
// Affiche le profil utilisateur et active le bouton gestion de profil.
export { handleViewProfile } from './userProfile.js';	
===== ./userProfile/userProfile.js =====
import { requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

// Fonction principale qui récupère et affiche le profil utilisateur
async function viewUserProfile() {
    try {
        const response = await requestGet('accounts', 'userProfile');

        // Si la réponse est undefined, cela signifie que la redirection a déjà été déclenchée
        if (!response) {
            return false;
        }

        if (response.status === 'success' && response.html) {
            console.log('Profil utilisateur chargé avec succès.');
            updateHtmlContent('#content', response.html);
        } else {
            const message = response.message || 'Erreur lors du chargement du profil utilisateur.';
            console.error('Erreur :', message);
            showStatusMessage(message, 'error');
            throw new Error(message);
        }
        return true;
    } catch (error) {
        console.error('Erreur réseau ou réponse lors du chargement du profil utilisateur:', error);
        showStatusMessage('Une erreur est survenue lors du chargement du profil utilisateur.', 'error');
        throw error; // Propagation de l'erreur pour gestion dans handleViewProfile
    }
}

// Fonction pour gérer les événements spécifiques au profil
async function initializeProfileEvents() {
    try {
        const gestionBtn = document.querySelector('#gestion-btn');
        if (!gestionBtn) {
            const message = 'Bouton de gestion de profil introuvable.';
            console.error(message);
            showStatusMessage(message, 'error');
            throw new Error(message);
        }

        gestionBtn.addEventListener('click', () => {
            console.log('Clic sur Gestion de Profil');
            navigateTo('/account'); 
        });

        console.log('Événements de profil initialisés.');
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des événements de profil:', error);
        showStatusMessage('Une erreur est survenue lors de l\'initialisation des événements du profil.', 'error');
        throw error; // Relance l'erreur pour qu'elle soit gérée par handleViewProfile
    }
}

// Fonction pour gérer l'affichage du profil utilisateur
export async function handleViewProfile() {
    console.log('Chargement du profil utilisateur...');

    let profileLoaded;
    try {
        profileLoaded = await viewUserProfile(); // Appel de la fonction principale pour charger le profil
    } catch (error) {
        console.error('Erreur lors du chargement du profil utilisateur dans viewUserProfile:', error);
        showStatusMessage('Erreur lors du chargement du profil utilisateur.', 'error');
        return; // Arrête l'exécution si le chargement échoue
    }

    // Si le profil n'a pas été chargé (par exemple, à cause d'une redirection), on arrête ici.
    if (!profileLoaded) {
        return;
    }

    try {
        await initializeProfileEvents(); // Initialisation des événements spécifiques au profil
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des événements dans initializeProfileEvents:', error);
        showStatusMessage('Erreur lors de l\'initialisation des événements du profil.', 'error');
    }
}


===== ./router.js =====
import { initializeHomeView } from './landing/coreHome.js';
import { handleLogin, initializeRegisterView, initializeLogin2FAView, handleDisable2FA, handleEnable2FA } from './auth/index.js';
import { handleInviteGame, initializeGameHomeView } from './game/index.js';
import { handleAccountsManagement } from './accountManagement/index.js';
import { handleViewProfile } from './userProfile/index.js';
import {handleGameMenu} from './game/index.js';
import { handleFriendProfile } from './friends/index.js';
import { handleNavbar } from './navbar/loadNavbar.js';
import { initializeNotFoundView } from './tools/errorPage.js';
import { handleTournament } from './game/tournament.js'
import { createGameOnline } from './game/index.js';
// Initialisation du routeur Navigo
const router = new window.Navigo('/', { hash: false });


/**
 * Initialisation des routes Navigo.
 */
export function initializeRouter() {
    router
        .on('/', () => {
            console.log('Route: Home');
            handleNavbar();
            initializeHomeView();
        })
        .on('/login', () => {
            console.log('Route: Login');
            handleLogin();
        })
        .on('/login-2fa', () => {
            console.log('Route: Login');
            initializeLogin2FAView();
        })
        .on('/register', () => {
            console.log('Route: Register');
            initializeRegisterView();
        })
        .on('/enable-2fa', () => {
            console.log('Route: 2FA Login');
            handleEnable2FA();
        })
        .on('/disable-2fa', () => {
            console.log('Route: 2FA Login');
            handleDisable2FA();
        })
        .on('/home', () => {
            console.log('Route: Game Home');
            initializeGameHomeView();
        })
        .on('/account', () => {
            console.log('Route: account');
            handleAccountsManagement();
        })
        .on('/profile', () => {
            console.log('Route: profile');
            handleViewProfile();
        })
        .on('/game-options', () => {
            console.log('Route: game-options');
            handleGameMenu();
        })
        .on('/online', () => {
            console.log('Route: online');
            createGameOnline();
        })
        .on('/tournament', () => {
            console.log('Route: tournament');
            handleTournament();
        })
        //improve : ne faut il pas changer le nom en game-option ?
        .on('/game-loading', () => {
            console.log('Route: game-loading');
            startLoading();
        })
        .on('/profile/:friendUsername', ({ data }) => {
            const friendUsername = data.friendUsername; // Utilisez `data` pour extraire le paramètre
            console.log(`Route: Profile for ${friendUsername}`);
            handleFriendProfile(friendUsername);
        })
        .notFound(() => {
            console.error('Route inconnue : Page non trouvée');
            initializeNotFoundView(); // Charge la vue 404 sans recharger landing.html

        });

    // Résolution de la route actuelle
    router.resolve();
}

/**
 * Navigation dynamique.
 * @param {string} route - La route cible.
 */
export function navigateTo(route) {
    console.log(`Navigation vers ${route}`);
    router.navigate(route);
}

