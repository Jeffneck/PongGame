# game/admin.py

from django.contrib import admin
from .models import GameSession, GameResult, GameParameters, GameInvitation

@admin.register(GameSession)
class GameSessionAdmin(admin.ModelAdmin):
    list_display = ('id', 'player_left', 'player_right', 'status', 'created_at')

@admin.register(GameResult)
class GameResultAdmin(admin.ModelAdmin):
    list_display = ('game', 'winner', 'score_left', 'score_right', 'ended_at')

@admin.register(GameParameters)
class GameParametersAdmin(admin.ModelAdmin):
    list_display = ('game_session', 'ball_speed', 'paddle_size', 'bonus_enabled', 'obstacles_enabled')

@admin.register(GameInvitation)
class GameInvitationAdmin(admin.ModelAdmin):
    list_display = ('from_user', 'to_user', 'status', 'created_at')
from django.apps import AppConfig


class GameConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'game'
# game/consumers.py

import json
import redis
from django.conf import settings
from channels.generic.websocket import AsyncWebsocketConsumer
from uuid import UUID

# from .game_loop.redis_utils import get_key

r = redis.Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=0
)

class PongConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.game_id = self.scope['url_route']['kwargs']['game_id']
        self.group_name = f"pong_{self.game_id}"

        await self.accept()
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket connected for game_id={self.game_id}")

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket disconnected for game_id={self.game_id}")

    async def receive(self, text_data=None, bytes_data=None):
        data = json.loads(text_data)
        action = data.get('action')
        player = data.get('player')

        if action == 'start_move':
            direction = data.get('direction')  # 'up' ou 'down'
            self.start_move_paddle(player, direction)

        elif action == 'stop_move':
            self.stop_move_paddle(player)

    def start_move_paddle(self, player, direction):
        velocity = 0
        if direction == 'up':
            velocity = -8  # Ajustez la vitesse selon vos préférences
        elif direction == 'down':
            velocity = 8

        r.set(f"{self.game_id}:paddle_{player}_velocity", velocity)
        print(f"[PongConsumer] start_move_paddle: player={player}, velocity={velocity}")

    def stop_move_paddle(self, player):
        r.set(f"{self.game_id}:paddle_{player}_velocity", 0)
        print(f"[PongConsumer] stop_move_paddle: player={player}")

    # Handlers pour les événements du groupe
    async def broadcast_game_state(self, event):
        await self.send(json.dumps(event['data']))
        # print(f"[PongConsumer] Broadcast game_state for game_id={self.game_id}")

    async def game_over(self, event):
        winner = event['winner']
        looser = event['looser']
        # tournament_id = event['tournament_id']

        # Préparer le JSON de réponse
        response_data = {
            'type': 'game_over',
            'winner': winner,
            'looser': looser
        }

        # Envoyer le JSON au client WebSocket
        await self.send(text_data=json.dumps(response_data))

    async def powerup_applied(self, event):
        await self.send(json.dumps({
            'type': 'powerup_applied',
            'player': event['player'],
            'effect': event['effect'],
            'duration': event['duration']
        }))
        print(f"[PongConsumer] Broadcast powerup_applied for game_id={self.game_id}, player={event['player']}, effect={event['effect']}, duration={event['duration']}")

    async def powerup_spawned(self, event):
        await self.send(json.dumps({
            'type': 'powerup_spawned',
            'powerup': event['powerup']
        }))
        print(f"[PongConsumer] Broadcast powerup_spawned for game_id={self.game_id}")

    async def countdown(self, event):
        await self.send(json.dumps({
            'type': 'countdown',
            'countdown_nb': event['countdown_nb']
        }))
        print(f"[PongConsumer] Broadcast countdown for game_id={self.game_id}")
    
    # async def start_game(self, event):
    #     await self.send(json.dumps({
    #         'type': 'start_game',
    #     }))
    #     print(f"[PongConsumer] Broadcast start_game for game_id={self.game_id}")

    async def powerup_expired(self, event):
        await self.send(json.dumps({
            'type': 'powerup_expired',
            'powerup': event['powerup']
        }))
        print(f"[PongConsumer] Broadcast powerup_expired for game_id={self.game_id}")

    async def bumper_spawned(self, event):
        await self.send(json.dumps({
            'type': 'bumper_spawned',
            'bumper': event['bumper']
        }))
        print(f"[PongConsumer] Broadcast bumper_spawned for game_id={self.game_id}")

    async def bumper_expired(self, event):
        await self.send(json.dumps({
            'type': 'bumper_expired',
            'bumper': event['bumper']
        }))
        print(f"[PongConsumer] Broadcast bumper_expired for game_id={self.game_id}")

    async def collision_event(self, event):
        await self.send(json.dumps({
            'type': 'collision_event',
            'collision': event['collision']
        }))
        print(f"[PongConsumer] Broadcast collision_event for game_id={self.game_id}")


# [IMPROVE] adapter le consummer  aux notifications envoyees par broadcast.py# game/forms.py

from django import forms
from django.core.exceptions import ValidationError
from .models import GameParameters, LocalTournament, TournamentParameters

class GameParametersForm(forms.ModelForm):
    class Meta:
        model = GameParameters
        fields = ['ball_speed', 'paddle_size', 'bonus_enabled', 'obstacles_enabled']
        widgets = {
            'ball_speed': forms.Select(attrs={'class': 'form-control'}),
            'paddle_size': forms.Select(attrs={'class': 'form-control'}),
            'bonus_enabled': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            'obstacles_enabled': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }
        labels = {
            'ball_speed': 'Vitesse de la balle',
            'paddle_size': 'Taille de la raquette',
            'bonus_enabled': 'Activer les bonus/malus',
            'obstacles_enabled': 'Activer les bumpers/obstacles',
        }

class TournamentParametersForm(forms.ModelForm):
    # Champs relatifs aux paramètres
    BALL_SPEED_CHOICES = [(1, 'Slow'), (2, 'Medium'), (3, 'Fast')]
    PADDLE_SIZE_CHOICES = [(1, 'Small'), (2, 'Medium'), (3, 'Large')]

    ball_speed = forms.ChoiceField(choices=BALL_SPEED_CHOICES, initial=2, label="Vitesse de balle")
    paddle_size = forms.ChoiceField(choices=PADDLE_SIZE_CHOICES, initial=2, label="Taille raquette")
    bonus_enabled = forms.BooleanField(initial=True, required=False, label="Activer bonus")
    obstacles_enabled = forms.BooleanField(initial=False, required=False, label="Activer obstacles")

    class Meta:
        model = LocalTournament
        fields = ['name', 'player1', 'player2', 'player3', 'player4']
        labels = {
            'name': 'Nom du Tournoi',
            'player1': 'Joueur 1',
            'player2': 'Joueur 2',
            'player3': 'Joueur 3',
            'player4': 'Joueur 4',
        }

    def clean(self):
        cleaned_data = super().clean()
        player1 = cleaned_data.get('player1')
        player2 = cleaned_data.get('player2')
        player3 = cleaned_data.get('player3')
        player4 = cleaned_data.get('player4')

        if (
            player1 == player2 or
            player1 == player3 or
            player1 == player4 or
            player2 == player3 or
            player2 == player4 or
            player3 == player4
        ):
            raise ValidationError("Les noms des joueurs doivent être uniques.")

        return cleaned_data

    def save(self, commit=True):
        tournament = super().save(commit=commit)

        # 2) Crée le TournamentParameters associé
        if commit:
            TournamentParameters.objects.create(
                tournament=tournament,
                ball_speed=self.cleaned_data['ball_speed'],
                paddle_size=self.cleaned_data['paddle_size'],
                bonus_enabled=self.cleaned_data['bonus_enabled'],
                obstacles_enabled=self.cleaned_data['obstacles_enabled'],
            )

        return tournament# game/game_objects.py

import random
import math
import time

class Paddle: 
    def __init__(self, position, size, speed):
        """
        position: 'left' ou 'right'
        size: taille initiale de la raquette
        speed: vitesse de déplacement
        """
        self.position = position
        self.width = 10
        self.height = size
        self.x = 50 if position == 'left' else 750
        self.y = 200 - self.height // 2
        self.speed = speed
        self.velocity = 0
        # self.shown_size = size  # Current displayed size

    def move(self, direction, is_on_ice, terrain_top, terrain_bottom, speed_boost=False):
        ice_acceleration = 0.5
        ice_friction = 0.02
        if is_on_ice:
            if direction != 0:
                self.velocity += direction * ice_acceleration
            self.velocity *= (1 - ice_friction)
        else:
            speed = self.speed * 1.5 if speed_boost else self.speed
            self.velocity = direction * speed

        # Apply movement with boundary checking
        new_y = self.y + self.velocity
        if new_y < terrain_top:
            new_y = terrain_top
            self.velocity = 0
        elif new_y + self.height > terrain_bottom:
            new_y = terrain_bottom - self.height
            self.velocity = 0

        self.y = new_y

    def resize(self, new_height):
        self.height = new_height

class Ball:
    def __init__(self, x, y, speed_x, speed_y, size=7):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.size = size
        self.last_player = None  # Nouvel attribut pour suivre le dernier joueur

    # def move(self):
    #     self.x += self.speed_x
    #     self.y += self.speed_y

    def reset(self, x, y, speed_x, speed_y):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.last_player = None  # Réinitialiser le dernier joueur

class PowerUpOrb:
    def __init__(self, game_id, effect_type, terrain_rect, color=None):
        self.game_id = game_id
        self.effect_type = effect_type  # 'invert', 'shrink', 'ice', 'speed', 'sticky', 'flash'
        self.size = 15
        self.color = color or self.get_default_color()
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 10
        self.effect_duration = 5
        self.in_cooldown = False
        self.cooldown_end_time = 0

        # Define spawn area boundaries (25% to 75% of field width) / added
        self.spawn_area = {
            'left': terrain_rect['left'] + (terrain_rect['width'] * 0.25),
            'right': terrain_rect['left'] + (terrain_rect['width'] * 0.75),
            'top': terrain_rect['top'] + (terrain_rect['height'] * 0.1),
            'bottom': terrain_rect['top'] + (terrain_rect['height'] * 0.9)
        }

    def get_default_color(self):
        colors = {
            'invert': (255, 105, 180),  # Pink
            'shrink': (255, 0, 0),      # Red
            'ice': (0, 255, 255),       # Cyan
            'speed': (255, 215, 0),     # Gold
            'flash': (255, 255, 0),     # Yellow
            # 'sticky': (50, 205, 50)     # Lime green
        }
        return colors.get(self.effect_type, (255, 255, 255))

    def start_cooldown(self): # / added
        """Start cooldown period that prevents this type of powerup from spawning"""
        self.in_cooldown = True
        self.cooldown_end_time = time.time() + self.duration + self.effect_duration
        print(f"[PowerUpOrb] {self.effect_type} cooldown started until: {self.cooldown_end_time}")

    def check_cooldown(self): # / added
        """Check if powerup is in cooldown period"""
        if self.in_cooldown:
            if time.time() >= self.cooldown_end_time:
                self.in_cooldown = False
                print(f"[PowerUpOrb] {self.effect_type} cooldown ended")
                return False
            return True
        return False

    def check_position_valid(self, x, y, powerup_orbs, bumpers):
        # Check distance from other powerups / added
        MIN_POWERUP_DISTANCE = 40
        MIN_BUMPER_DISTANCE = 40

        #Debug count
        active_powerups = 0
        active_bumpers = 0

        for orb in powerup_orbs:
            if orb.active and orb != self:
                active_powerups += 1
                distance = math.hypot(x - orb.x, y - orb.y)
                print(f"[DEBUG] PowerUp checking distance to other powerup: {distance}")
                if distance < MIN_POWERUP_DISTANCE:
                    print(f"[DEBUG] PowerUp spawn rejected: too close to other powerup ({distance} < {MIN_POWERUP_DISTANCE})")
                    return False

        # Check distance from bumpers
        MIN_BUMPER_DISTANCE = 40
        for bumper in bumpers:
            if bumper.active:
                active_bumpers += 1
                distance = math.hypot(x - bumper.x, y - bumper.y)
                print(f"[DEBUG] PowerUp checking distance to bumper: {distance}")
                if distance < MIN_BUMPER_DISTANCE:
                    print(f"[DEBUG] PowerUp spawn rejected: too close to bumper ({distance} < {MIN_BUMPER_DISTANCE})")
                    return False
        print(f"[DEBUG] PowerUp spawn position check complete. Checked against {active_powerups} active powerups and {active_bumpers} active bumpers")
        return True

    def spawn(self, terrain_rect, powerup_orbs=None, bumpers=None):
        if self.active or self.check_cooldown():
            return False
        if powerup_orbs is None:
            powerup_orbs = []
        if bumpers is None:
            bumpers = []

        max_attempts = 100

        for attempt in range(max_attempts):
            # Spawn within the defined middle area / modified
            new_x = random.uniform(self.spawn_area['left'], self.spawn_area['right'])
            new_y = random.uniform(self.spawn_area['top'], self.spawn_area['bottom'])

            # Additional check to ensure better distribution in the middle
            center_x = terrain_rect['left'] + (terrain_rect['width'] / 2)
            if abs(new_x - center_x) < 50:  # If too close to center, try again
                continue

            # Check if position is valid (not too close to other objects) / added
            if self.check_position_valid(new_x, new_y, powerup_orbs, bumpers):
                self.x = new_x
                self.y = new_y
                self.rect = (self.x, self.y, self.size, self.size)
                self.active = True
                self.spawn_time = time.time()
                print(f"[DEBUG] Successfully spawned powerup after {attempt + 1} attempts")
                return True
            else:
                print(f"[DEBUG] Attempt {attempt + 1} failed validation")
        return False

    def activate(self):
        self.active = True
        self.spawn_time = time.time()

    def deactivate(self):
        self.active = False
        self.x = None
        self.y = None
        self.spawn_time = None
        self.start_cooldown()

class Bumper:
    def __init__(self, game_id, terrain_rect):
        self.game_id = game_id
        self.size = 20
        self.color = (255, 255, 255)  # White
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 10
        self.last_collision_time = 0 

        # Define spawn area boundaries (40% to 60% of field width for more central placement) / added
        self.spawn_area = {
            'left': terrain_rect['left'] + (terrain_rect['width'] * 0.25),
            'right': terrain_rect['left'] + (terrain_rect['width'] * 0.75),
            'top': terrain_rect['top'] + (terrain_rect['height'] * 0.1),
            'bottom': terrain_rect['top'] + (terrain_rect['height'] * 0.9)
        }

    def check_position_valid(self, x, y, powerup_orbs, bumpers): # / added
        # Check distance from powerups
        MIN_POWERUP_DISTANCE = 40
        MIN_BUMPER_DISTANCE = 40

        # Debug counters
        active_powerups = 0
        active_bumpers = 0

        for orb in powerup_orbs:
            if orb.active:
                active_powerups += 1
                distance = math.hypot(x - orb.x, y - orb.y)
                print(f"[DEBUG] Bumper checking distance to powerup: {distance}")
                if distance < MIN_POWERUP_DISTANCE:
                    print(f"[DEBUG] Bumper spawn rejected: too close to powerup ({distance} < {MIN_POWERUP_DISTANCE})")
                    return False

        # Check distance from other bumpers
        MIN_BUMPER_DISTANCE = 40
        for bumper in bumpers:
            if bumper.active and bumper != self:
                active_bumpers += 1
                distance = math.hypot(x - bumper.x, y - bumper.y)
                print(f"[DEBUG] Bumper checking distance to other bumper: {distance}")
                if distance < MIN_BUMPER_DISTANCE:
                    print(f"[DEBUG] Bumper spawn rejected: too close to other bumper ({distance} < {MIN_BUMPER_DISTANCE})")
                    return False
        print(f"[DEBUG] Bumper spawn position check complete. Checked against {active_powerups} active powerups and {active_bumpers} active bumpers")
        return True

    def spawn(self, terrain_rect, powerup_orbs=None, bumpers=None):
        if self.active:
            return False

        if powerup_orbs is None:
            powerup_orbs = []
        if bumpers is None:
            bumpers = []

        max_attempts = 100

        # left = terrain_rect['left']
        # right = terrain_rect['left'] + terrain_rect['width']
        # top = terrain_rect['top']
        # bottom = terrain_rect['top'] + terrain_rect['height'] / removed

        for _ in range(max_attempts):
            # Spawn within the defined middle area / modified
            new_x = random.uniform(self.spawn_area['left'], self.spawn_area['right'])
            new_y = random.uniform(self.spawn_area['top'], self.spawn_area['bottom'])

            # Check distance from center to avoid too much clustering
            center_x = terrain_rect['left'] + (terrain_rect['width'] / 2)
            center_y = terrain_rect['top'] + (terrain_rect['height'] / 2)
            dist_to_center = math.hypot(new_x - center_x, new_y - center_y)
            
            if dist_to_center < 30:  # If too close to center, try again
                continue

            # Check if position is valid (not too close to other objects)
            if self.check_position_valid(new_x, new_y, powerup_orbs, bumpers):
                self.x = new_x
                self.y = new_y
                self.rect = (self.x, self.y, self.size, self.size)
                self.active = True
                self.spawn_time = time.time()
                return True

        return False
    
    def activate(self):
        self.active = True

    def deactivate(self):
        self.active = False
# game/manager.py

import asyncio
from game.tasks import start_game_loop
import sys

_GLOBAL_LOOP = None

def set_global_loop(loop):
    global _GLOBAL_LOOP
    _GLOBAL_LOOP = loop
    print(f"[manager.py] Global loop set: {loop}")

def get_global_loop():
    return _GLOBAL_LOOP

def schedule_game(game_id):
    try:
        current_loop = asyncio.get_event_loop()
        if not current_loop.is_running():
            raise RuntimeError("Event loop is not running")
        current_loop.create_task(start_game_loop(game_id))
        print(f"[schedule_game] create_task OK dans loop={current_loop} pour game_id={game_id}")
    except (RuntimeError, AttributeError) as e:
        print("No current event loop in this thread, fallback run_coroutine_threadsafe", file=sys.stderr)
        global_loop = get_global_loop()
        if global_loop and global_loop.is_running():
            future = asyncio.run_coroutine_threadsafe(start_game_loop(game_id), global_loop)
            print(f"[schedule_game] run_coroutine_threadsafe OK dans global_loop={global_loop} pour game_id={game_id}")
        else:
            print("No global loop available or loop is not running, game cannot be scheduled.", file=sys.stderr)
# game/models.py
from django.db import models
from django.utils.timezone import now
from datetime import timedelta
import uuid
from django.contrib.auth import get_user_model  # ✅ Import sans circularité

User = get_user_model()  # ✅ Récupère CustomUser dynamiquement
class GameSession(models.Model):
    """
    Un enregistrement pour représenter une partie (en cours ou terminée).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tournament_id = models.UUIDField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=10, default='waiting')
    
    # Le champ is_online pour déterminer si c'est une partie en ligne ou locale
    is_online = models.BooleanField(default=False)

    # Si la partie est en ligne, on relie à un CustomUser
    player_left = models.ForeignKey(User, related_name='game_sessions_as_player_left', on_delete=models.CASCADE, null=True, blank=True)
    player_right = models.ForeignKey(User, related_name='game_sessions_as_player_right', on_delete=models.CASCADE, null=True, blank=True)

    # Si la partie est locale, on utilise des champs de texte (par exemple, les noms des joueurs)
    player_left_local = models.CharField(max_length=50, null=True, blank=True)
    player_right_local = models.CharField(max_length=50, null=True, blank=True)

    # un joueur pret appuie sur le bouton PLAY et passe ce bool a true
    ready_left = models.BooleanField(default=False)
    # valable uniquement quand 2 joueur online
    ready_right = models.BooleanField(default=False)
    
    def __str__(self):
        return f"GameSession {self.id} (status={self.status})"




class GameParameters(models.Model):
    game_session = models.OneToOneField(GameSession, related_name='parameters', on_delete=models.CASCADE)
    BALL_SPEED_CHOICES = [(1, 'Slow'), (2, 'Medium'), (3, 'Fast'),]
    ball_speed = models.PositiveSmallIntegerField(choices=BALL_SPEED_CHOICES, default=2)

    paddle_size_CHOICES = [(1, 'Small'), (2, 'Medium'), (3, 'Large'),]
    paddle_size = models.PositiveSmallIntegerField(choices=paddle_size_CHOICES, default=2)

    bonus_enabled = models.BooleanField(default=True)
    obstacles_enabled = models.BooleanField(default=False)


    def __str__(self):
        return (f"Ball speed: {self.get_ball_speed_display()}, "
                f"paddle size: {self.get_paddle_size_display()}, "
                f"Bonus/Malus: {'On' if self.bonus_enabled else 'Off'}, "
                f"Bumpers: {'On' if self.obstacles_enabled else 'Off'}")



class GameResultManager(models.Manager):
    """Manager pour récupérer l'historique des matchs d'un utilisateur."""
    
    def get_user_match_history(self, user):
        """Retourne l'historique des parties jouées par l'utilisateur."""
        return self.get_queryset().filter(  # ✅ Utilise `get_queryset()` pour éviter l'erreur
            models.Q(game__player_left=user) | models.Q(game__player_right=user)
        ).order_by('-ended_at')

class GameResult(models.Model):
    """
    Enregistre le score final d'une partie terminée.
    """
    # game = models.ForeignKey("game.GameSession", on_delete=models.CASCADE)
    game = models.OneToOneField("game.GameSession", on_delete=models.CASCADE)
    winner = models.ForeignKey(User, related_name='games_won', on_delete=models.CASCADE, null=True, blank=True)
    looser = models.ForeignKey(User, related_name='games_lost', on_delete=models.CASCADE, null=True, blank=True)  
    winner_local = models.CharField(max_length=50, null=True, blank=True)
    looser_local = models.CharField(max_length=50, null=True, blank=True)
    score_left = models.IntegerField()
    score_right = models.IntegerField()
    ended_at = models.DateTimeField(auto_now_add=True)

    objects = GameResultManager()  # ✅ Ajout du Manager personnalisé

    def __str__(self):
        return f"[{self.game.id}] winner={self.winner} looser={self.looser} => {self.score_left}-{self.score_right}"


# TOURNAMENT MODELS


class LocalTournament(models.Model):
    """
    Un tournoi local avec 4 joueurs, 2 demi-finales et 1 finale.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100, default="Local Tournament")

    # Les pseudos des 4 joueurs (pas forcément des utilisateurs enregistrés)
    player1 = models.CharField(max_length=50, default='mbappe')
    player2 = models.CharField(max_length=50, default='zizou')
    player3 = models.CharField(max_length=50, default='ribery')
    player4 = models.CharField(max_length=50, default='cantona')

    # Sessions de jeu pour le bracket
    semifinal1 = models.ForeignKey(
        "GameSession",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        related_name="tournament_semifinal1",
    )
    semifinal2 = models.ForeignKey(
        "GameSession",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        related_name="tournament_semifinal2",
    )
    final = models.ForeignKey(
        "GameSession",
        on_delete=models.SET_NULL,
        null=True, blank=True,
        related_name="tournament_final",
    )

    # Gagnants des matchs
    winner_semifinal_1 = models.CharField(max_length=50, null=True, blank=True)
    winner_semifinal_2 = models.CharField(max_length=50, null=True, blank=True)
    winner_final = models.CharField(max_length=50, null=True, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=30,
        default="pending",
        help_text="Ex: 'pending', 'semifinal1_in_progress', 'semifinal2_in_progress', 'final_in_progress', 'finished', etc."
    )

    def get_winner(self):
        """Retourne le vainqueur du tournoi si la finale est terminée."""
        return self.winner_final if self.status == "finished" else None

    def __str__(self):
        return f"Tournament {self.name} - {self.id}"

class TournamentParameters(models.Model):
    """
    Paramètres généraux valables pour TOUTES les parties d'un tournoi.
    """
    # Lien 1-1 avec le tournoi : 
    #   - on_delete=CASCADE (ou SET_NULL) au choix, ici on peut supprimer 
    #     les params si le tournoi est supprimé.
    tournament = models.OneToOneField(
        LocalTournament,
        on_delete=models.CASCADE,
        related_name='parameters'
    )

    BALL_SPEED_CHOICES = [
        (1, 'Slow'),
        (2, 'Medium'),
        (3, 'Fast'),
    ]
    ball_speed = models.PositiveSmallIntegerField(choices=BALL_SPEED_CHOICES, default=2)

    PADDLE_SIZE_CHOICES = [
        (1, 'Small'),
        (2, 'Medium'),
        (3, 'Large'),
    ]
    paddle_size = models.PositiveSmallIntegerField(choices=PADDLE_SIZE_CHOICES, default=2)

    bonus_enabled = models.BooleanField(default=True)
    obstacles_enabled = models.BooleanField(default=False)

    def __str__(self):
        return (f"TournamentParameters for {self.tournament} | "
                f"Ball speed={self.get_ball_speed_display()}, "
                f"Racket size={self.get_paddle_size_display()}, "
                f"Bonus={self.bonus_enabled}, Obstacles={self.obstacles_enabled}")

# INVITATIONS ----------------------------------------

# utile pour savoir si une invitation a expire
def default_expiration_time():
    """Retourne l'heure actuelle + 30 secondes."""
    return now() + timedelta(seconds=30)

class GameInvitation(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    from_user = models.ForeignKey(User, related_name='invitations_sent', on_delete=models.CASCADE)
    to_user = models.ForeignKey(User, related_name='invitations_received', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(default=default_expiration_time)
    status = models.CharField(
        max_length=10,
        choices=[('pending', 'Pending'), ('accepted', 'Accepted'), ('rejected', 'Rejected'), ('expired', 'Expired')],
        default='pending',
    )
    # NOUVEAU : permet de relier directement l'invitation à la session créée (si acceptée)
    session = models.ForeignKey(
        'GameSession',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='invitations'
    )

    def is_expired(self):
        return now() > self.expires_at

    def __str__(self):
        if self.status == 'expired':
            return f"Invitation expirée de {self.from_user.username} à {self.to_user.username}"
        return f"Invitation de {self.from_user.username} à {self.to_user.username} - {self.status}"


# class GameInvitationParameters(models.Model):
#     """
#     Permet de stocker les paramètres de jeu pour une invitation en ligne
#     (avant que la session ne soit créée).
#     """
#     invitation = models.OneToOneField(
#         GameInvitation,
#         on_delete=models.CASCADE,
#         related_name='parameters'
#     )

#     BALL_SPEED_CHOICES = [(1, 'Slow'), (2, 'Medium'), (3, 'Fast')]
#     ball_speed = models.PositiveSmallIntegerField(choices=BALL_SPEED_CHOICES, default=2)

#     paddle_size_CHOICES = [(1, 'Small'), (2, 'Medium'), (3, 'Large')]
#     paddle_size = models.PositiveSmallIntegerField(choices=paddle_size_CHOICES, default=2)

#     bonus_enabled = models.BooleanField(default=True)
#     obstacles_enabled = models.BooleanField(default=False)

#     def __str__(self):
#         return (f"(Invitation={self.invitation.id}) "
#                 f"BallSpeed={self.get_ball_speed_display()}, "
#                 f"RacketSize={self.get_paddle_size_display()}, "
#                 f"Bonus={self.bonus_enabled}, Bumpers={self.obstacles_enabled}")from django.urls import re_path
from .consumers import PongConsumer

websocket_urlpatterns = [
    # ws://host/ws/pong/<uuid>/
    re_path(r'^ws/pong/(?P<game_id>[0-9a-f-]+)/$', PongConsumer.as_asgi()),
]

# from django.urls import re_path
# from channels.routing import ProtocolTypeRouter, URLRouter
# from channels.security.websocket import AllowedHostsOriginValidator
# from .consumers import PongConsumer

# application = ProtocolTypeRouter({
#     "websocket": AllowedHostsOriginValidator(
#         URLRouter([
#             re_path(r"^ws/pong/(?P<game_id>[0-9a-f-]+)/$", PongConsumer.as_asgi()),
#         ])
#     ),
# })# game/tasks.py

import asyncio
from .game_loop.loop import game_loop

ACTIVE_GAMES = {}  # Dict: { game_id -> asyncio.Task }

async def start_game_loop(game_id):

    task = asyncio.create_task(game_loop(game_id))
    ACTIVE_GAMES[game_id] = task

    print(f"[tasks.py] Game loop started for game_id={game_id}")

    try:
        await task
    except asyncio.CancelledError:
        print(f"[tasks.py] Game loop for game_id={game_id} was cancelled.")
    finally:
        del ACTIVE_GAMES[game_id]
        print(f"[tasks.py] Game loop ended for game_id={game_id}")

def is_game_running(game_id):
    return game_id in ACTIVE_GAMES

def stop_game(game_id):
    task = ACTIVE_GAMES.get(game_id)
    if task:
        task.cancel()
        print(f"[tasks.py] Game loop for game_id={game_id} has been cancelled.")
from django.test import TestCase

# Create your tests here.
# game/urls.py

# from django.urls import path
# from . import views
# from . import local_game_views
# from . import online_game_views
# from . import local_tournament_views

# urlpatterns = [
#     path('', views.index, name='index'),
#     path('list_results/', views.list_results, name='list_results'),

#     # Views ne renvoyant pas de HTML
#     path('ready-game/<uuid:game_id>/', views.ready_game, name='ready_game'),
    
#     path('local_game/<uuid:game_id>/', local_game_views.live_local_game, name='live_local_game'),
#     path('local_game/parameter_local_game/', local_game_views.parameter_local_game, name='parameter_local_game'),
    
#     path('tournament/parameter_local_tournament/', local_tournament_views.parameter_local_tournament, name='parameter_local_tournament'),
    
#     # Routes modifiées avec segments distinctifs
#     path('tournament/live/<uuid:game_id>/', local_tournament_views.live_tournament_game, name='live_tournament_game'),
#     path('tournament/detail/<uuid:tournament_id>/', local_tournament_views.detail_local_tournament, name='detail_local_tournament'),
    
#     path('tournament/detail/<uuid:tournament_id>/<str:match_type>/next_game_presentation_tournament/', local_tournament_views.next_game_presentation_tournament, name='next_game_presentation_tournament'),
#     path('tournament/detail/<uuid:tournament_id>/<str:match_type>/start_next_tournament_game/', local_tournament_views.start_next_tournament_game, name='start_next_tournament_game'),
# ]


from django.urls import path

from .views.gameHome import GameHomeView
from .views.gameMenu import GameMenuView
from .views.gameLoading import LoadingView
from .views.gameLocal import StartLocalGameView, CreateGameLocalView
from .views.gameResults import GameResultsView 
from .views.gameOnline import CreateGameOnlineView, SendGameSessionInvitationView, AcceptGameInvitationView, RejectGameInvitationView, CleanExpiredInvitationsView, CheckGameInvitationStatusView, StartOnlineGameView, JoinOnlineGameAsLeftView, JoinOnlineGameAsRightView
from .views.gameTournament import CreateTournamentView, CreateTournamentGameSessionView, StartTournamentGameSessionView, TournamentBracketView, TournamentNextGameView
import logging


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)

logger.debug("Rentre dans urls.py de l'app game")

app_name = 'game'

urlpatterns = [
    path('home/', GameHomeView.as_view(), name='home'),  # Mise à jour pour CBV
    path('menu/', GameMenuView.as_view(), name='game_menu'),  # Mise à jour pour CBV
    path('loading/', LoadingView.as_view(), name='loading'),  # Mise à jour pour CBV
    # path('invite_game/', InviteGameView.as_view(), name='invite_game'),  # Vue fonctionnelle
    # path('invite_tournament/', invite_tournament_view, name='invite_tournament'),  # Vue fonctionnelle
    # path('send_invitation/', SendInvitationView.as_view(), name='send_invitation'),
    # path('cancel_invitation/', CancelInvitationView.as_view(), name='cancel_invitation'),  # Vue fonctionnelle
    # path('respond_to_invitation/', RespondToInvitationView.as_view(), name='respond_to_invitation'),
    # path('accept_invitation/<int:invitation_id>/', AcceptGameInvitationView.as_view(), name='accept_invitation'),
    # path('respond_to_invitation/', RespondToInvitationView.as_view(), name='respond_to_invitation'),
    # path('list_invitations/', ListInvitationsView.as_view(), name='list_invitations'),
    
    #LOCAL GAME 
    path('create_local_game/', CreateGameLocalView.as_view(), name='create_local_game'),
    path('start_local_game/<uuid:game_id>/', StartLocalGameView.as_view(), name='start_local_game'),

    # LOCAL TOURNAMENT GAMES
    path('create_tournament/', CreateTournamentView.as_view(), name='create_tournament'),
    path('tournament_bracket/<uuid:tournament_id>/', TournamentBracketView.as_view(), name='tournament_bracket'),
    path('tournament_next_game/<uuid:tournament_id>/', TournamentNextGameView.as_view(), name='tournament_next_game'),
    path('create_tournament_game_session/<uuid:tournament_id>/', CreateTournamentGameSessionView.as_view(), name='create_tournament_gameSession'),
    path('start_tournament_game_session/<uuid:game_id>/', StartTournamentGameSessionView.as_view(), name='start_tournament_gameSession'),

    #ONLINE GAME
    # create game
    # player left (the one that send the invitation)
    path('create_game_online/', CreateGameOnlineView.as_view(), name='create_game_online'),
    path('send_gameSession_invitation/', SendGameSessionInvitationView.as_view(), name='send_gameSession_invitation'),
    path('join_online_game_as_left/<uuid:game_id>/', JoinOnlineGameAsLeftView.as_view(), name='join_online_game_as_left'),
    path('start_online_game/<uuid:game_id>/', StartOnlineGameView.as_view(), name='start_online_game'),

    # player right (the one that receive the invitation)
    path('accept_game_invitation/<uuid:invitation_id>/', AcceptGameInvitationView.as_view(), name='accept_game_invitation'),
    path('join_online_game_as_right/<uuid:game_id>/', JoinOnlineGameAsRightView.as_view(), name='join_online_game_as_right'),
    path('reject_game_invitation/<uuid:invitation_id>/', RejectGameInvitationView.as_view(), name='reject_game_invitation'),

    # Invitations managers
    path('check_invitation_status/<uuid:invitation_id>/', CheckGameInvitationStatusView.as_view(), name='check_invitation_status'),
    path('clean_expired_invitations/<uuid:invitation_id>/', CleanExpiredInvitationsView.as_view(), name='clean_expired_invitations'),

    # See game results
    path('game_results/<uuid:game_id>/', GameResultsView.as_view(), name='get_local_results'),
]
import { requestGet, requestPost } from '../api/index.js'; 
import { updateHtmlContent } from '../tools/index.js'; 
// import { handleInviteGame } from './handleInvitationGame.js'; // Suppose qu'on gère l'invitation en ligne ici
// import { launchLiveGameWithOptions } from './live_game.js';
import { handleLocalGame } from './localGame.js'
import { createGameOnline } from './onlineGame.js'

import { navigateTo } from '../router.js';

function attachGameMenuEvents() {
    const sections = ['local', 'online', 'tournament'];

    sections.forEach((section) => {
        // Bouton de sélection
        document.getElementById(`${section}-game-btn`)?.addEventListener('click', () => {
            sections.forEach((s) => {
                document.getElementById(`customization-${s}`).classList.add('d-none');
            });
            document.getElementById(`customization-${section}`).classList.remove('d-none');
        });

        // Bouton Voir Tuto
        document.getElementById(`tutorial-btn-${section}`)?.addEventListener('click', () => {
            const tutorialContent = document.getElementById(`tutorial-content-${section}`);
            tutorialContent.classList.toggle('collapse');
        });

        // Gestion de la vitesse de la balle
        document.getElementById(`ballSpeed${section.charAt(0).toUpperCase() + section.slice(1)}`)?.addEventListener('input', (event) => {
            console.log(`Vitesse de balle (${section}):`, event.target.value);
        });

        // Bouton principal (Lancer Partie, Inviter un ami, Lancer Tournoi)
        const startGameButton = document.getElementById(`start-game-btn-${section}`);
        const inviteGameButton = document.getElementById(`invite-game-btn-${section}`);
        const inviteTournamentButton = document.getElementById(`invite-tournament-btn-${section}`);
        const test = document.getElementById(`${section}-game-btn`); 

        // Définir un comportement différent selon le bouton
        if (startGameButton && section === 'local') {
            startGameButton.addEventListener('click', async () => {
                const parametersForm = new FormData();
                parametersForm.append('game_type', section);

                // Récupérer les éléments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                // Vérifier s’ils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }
                    
                console.log(`Vitesse de balle (${section}):`, ballSpeedElement.value);
                console.log(`Taille de raquette (${section}):`, paddleSizeElement.value);
                console.log(`Bonus activé (${section}):`, bonusCheckbox?.checked);
                console.log(`Obstacles activés (${section}):`, obstacleCheckbox?.checked);
                // Lire les valeurs
                parametersForm.append('ball_speed', ballSpeedElement.value);
                parametersForm.append('paddle_size', paddleSizeElement.value);
                parametersForm.append('bonus_enabled', bonusCheckbox?.checked ?? false);
                parametersForm.append('obstacles_enabled', obstacleCheckbox?.checked ?? false);

                await handleLocalGame(parametersForm)
            });
        }

        if (startGameButton && section === 'online') {
            startGameButton.addEventListener('click', async () => {
                try {
                    // Récupère les éléments
                    const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                    const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                    const bonusCheckbox = document.getElementById(`bonus${section}`);
                    const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                    if (!ballSpeedElement || !paddleSizeElement) {
                        console.error(`Impossible de trouver les champs pour la section "${section}".`);
                        return;
                    }
                    
                    // Stockage en mémoire JS
                    const onlineParams = {
                        ball_speed: ballSpeedElement.value,
                        paddle_size: paddleSizeElement.value,
                        bonus_enabled: bonusCheckbox?.checked ?? false,
                        obstacles_enabled: obstacleCheckbox?.checked ?? false,
                    };
                    sessionStorage.setItem('params', JSON.stringify(onlineParams));
                    console.log('Paramètres de la partie online:', onlineParams);

                    // Maintenant on va charger la page "invite_game.html"
                    // et injecter le HTML dans #content (ou autre conteneur).
                    navigateTo('/online');

                } catch (err) {
                    console.error('Erreur lors de la phase d\'invitation :', err);
                    alert('Impossible d\'inviter un ami.');
                }
            });
        }

        if (startGameButton && section === 'tournament') {
            startGameButton.addEventListener('click', async () => {
                

                // Récupérer les éléments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);
                
                // Vérifier s’ils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }

                 // Stockage en mémoire JS
                const tournamentparams = {
                    ball_speed: ballSpeedElement.value,
                    paddle_size: paddleSizeElement.value,
                    bonus_enabled: bonusCheckbox?.checked ?? false,
                    obstacles_enabled: obstacleCheckbox?.checked ?? false,
                };

                sessionStorage.setItem('params', JSON.stringify(tournamentparams));
                navigateTo(`/tournament`);
            });
        }
    });
}



export async function handleGameMenu() {
    console.log('Chargement du menu du jeu...');
    try {
        // 1) On va chercher le HTML du menu
        const response = await requestGet('game', 'menu');
        if (!response) {
            return;
        }
        // 2) On injecte ce HTML dans la div #content
        updateHtmlContent('#content', response.html);
        // 3) On attache les événements
        attachGameMenuEvents();
    } catch (error) {
        console.error('Erreur dans handleGameMenu:', error);
    }
}
/* live_game.js
 *
 * Centralise les fonctions communes pour :
 * dessiner le canvas, les bumpers et les powerups
 * lancer le jeu en co-routine avec le bouton startGame 
 * recevoir les notifications (envoyées par broadcast.py > consumers.py > websocket)
 *    detecter la position de tous les elements de jeu (gameState)
 *    afficher des animations aux lieux d'impacts de la balle /lieux d'apparition des bumpers et powerups 
 * 
 */

import { requestPost } from '../api/index.js';
import { createPowerupSVG, createBumperSVG } from './live_game_svg.js';


export async function launchLiveGameWithOptions(gameId, userRole, urlStartButton) {
  const protocol = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws/pong/${gameId}/`;

  let startGameSelector = null;
  let onStartGame = null;
  
  console.log(`userRole = ${userRole}`);
  if (urlStartButton) {
    // Sélectionner l'élément DOM correspondant au bouton de démarrage
    startGameSelector = document.querySelector("#startGameBtn");
    // Vérifier que l'élément a bien été trouvé
    if (!startGameSelector) {
      console.error("L'élément avec le sélecteur '#startGameBtn' n'a pas été trouvé.");
    }
    
    onStartGame = async (gameId) => {
      // Assurez-vous que startGameSelector est bien un élément DOM avant d'accéder à classList
      if (startGameSelector) {
        startGameSelector.classList.add('d-none');
      }
      const url = urlStartButton;
      const formData = new FormData();
      formData.append('game_id', gameId);
      formData.append('userRole', userRole);
  
      const response = await requestPost('game', url, formData);
      if (response.status !== 'success') {
        alert("Erreur lors du démarrage : " + response.message);
      }
    };
  }

  // fonction qui gere toute la logique de jeu à partir de notre config
  return initLiveGame({
    gameId,
    userRole,
    wsUrl,
    startGameSelector,
    onStartGame
  });
}


  // ========== initPowerupImages ==========
  
  function initPowerupImages(powerupImages) {
    // Initialise la map de type => Image()
    Object.keys(powerupImages).forEach(type => {
      powerupImages[type].src = createPowerupSVG(type);
    });
  }
  
  // ========== applyFlashEffect ==========
  
  function applyFlashEffect(gameState, duration = 300) {
    gameState.flash_effect = true;
    setTimeout(() => {
      gameState.flash_effect = false;
    }, duration);
  }



// ========== La grosse fonction initLiveGame ==========

/**
 * Initialise un "live game" (local ou online) dans le canvas.
 * @param {Object} config 
 *    config.gameId  : string
 *    config.userRole: "left" | "right" | "both"   // ex: "both" = local, "left" ou "right" = online
 *    config.wsUrl   : URL du WebSocket
 *    config.startGameSelector?: ID du bouton (ex: "#startGameBtn")
 *    config.onStartGame?: Function de callback pour lancer la partie 
 *                         (ex: faire un POST sur /start_online_game/ ou /start_local_game/)
   */
function initLiveGame(config) {
  return new Promise((resolve) => {
    // 1) Préparer les éléments HTML
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startGameBtn = config.startGameSelector;
  
    // 2) Gérer le bouton "Start" (optionnel)
    if (startGameBtn && config.onStartGame) {
      // Débloquer le bouton après 3s (optionnel)
  //     setTimeout(() => { 
	// 	startGameBtn.style.opacity = "0.7";
  //       startGameBtn.disabled = false;
	    startGameBtn.classList.add("active");
	
	// }, 3000);
  
      // Clic => on appelle la callback onStartGame
      startGameBtn.addEventListener('click', async () => {
        await config.onStartGame()
        // await startGameWithCountdown(startGameBtn, config.onStartGame, config.gameId);
      });
    }

	// Draw visual effects / added
	function drawCollisionEffects() {
		collisionEffects.forEach(effect => {
			const age = effect.type.includes('spawn') ?
			  Date.now() - effect.startTime :
			  Date.now() - effect.startTime;
			const duration = effect.type.includes('spawn') ?
			  SPAWN_EFFECT_DURATION :
			  EXPIRE_EFFECT_DURATION;
			const progress = age / duration;
  
			ctx.save();
			ctx.globalAlpha = 1 - progress;
  
			switch(effect.type) {
				case 'paddle_collision':
					// Ripple effect
					const rippleSize = 20 + (progress * 40);
					ctx.strokeStyle = 'white';
					ctx.lineWidth = 3 * (1 - progress);
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, rippleSize, 0, Math.PI * 2);
					ctx.stroke();
					break;
  
				// case 'border_collision':
				//     // Simple glow effect at collision point
				//     const glowSize = 20 * (1 - progress);
				//     ctx.shadowColor = 'white';
				//     ctx.shadowBlur = 15 * (1 - progress);
					
				//     ctx.beginPath();
				//     ctx.arc(effect.x, effect.border_side === 'up' ? 50 : 350, glowSize, 0, Math.PI * 2);
				//     ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - progress) + ')';
				//     ctx.fill();
				//     break;
  
				case 'bumper_collision':
					// Explosion effect
					const numParticles = 8;
					const radius = 30 * progress;
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 3 * (1 - progress);
					
					for (let i = 0; i < numParticles; i++) {
						const angle = (i / numParticles) * Math.PI * 2;
						const startX = effect.x + Math.cos(angle) * 10;
						const startY = effect.y + Math.sin(angle) * 10;
						const endX = effect.x + Math.cos(angle) * radius;
						const endY = effect.y + Math.sin(angle) * radius;
						
						ctx.beginPath();
						ctx.moveTo(startX, startY);
						ctx.lineTo(endX, endY);
						ctx.stroke();
					}
					break;
				case 'powerup_spawn':
					// Expanding circles with powerup color
					const circles = 3;
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2;
					
					for (let i = 0; i < circles; i++) {
						const circleProgress = (progress + (i / circles)) % 1;
						const radius = circleProgress * 40;
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
						ctx.stroke();
					}
  
					// Add sparkles
					const sparkles = 8;
					for (let i = 0; i < sparkles; i++) {
						const angle = (i / sparkles) * Math.PI * 2;
						const sparkleDistance = 20 + (progress * 20);
						const x = effect.x + Math.cos(angle) * sparkleDistance;
						const y = effect.y + Math.sin(angle) * sparkleDistance;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fillStyle = effect.color;
						ctx.fill();
					}
					break;
  
				case 'powerup_expire':
					// Imploding effect
					const fadeRadius = 20 * (1 - progress);
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2 * (1 - progress);
					
					// Shrinking circle
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, fadeRadius, 0, Math.PI * 2);
					ctx.stroke();
					
					// Particles moving inward
					const particles = 6;
					for (let i = 0; i < particles; i++) {
						const angle = (i / particles) * Math.PI * 2;
						const distance = fadeRadius * 2;
						const x = effect.x + Math.cos(angle) * distance * progress;
						const y = effect.y + Math.sin(angle) * distance * progress;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fill();
					}
					break;
  
				case 'bumper_spawn':
					// Expanding diamond pattern
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2;
					const size = 40 * progress;
					const rotation = progress * Math.PI;
					
					ctx.translate(effect.x, effect.y);
					ctx.rotate(rotation);
					
					// Inner diamond
					ctx.beginPath();
					ctx.moveTo(0, -size);
					ctx.lineTo(size, 0);
					ctx.lineTo(0, size);
					ctx.lineTo(-size, 0);
					ctx.closePath();
					ctx.stroke();
					
					// Outer diamond
					ctx.beginPath();
					ctx.moveTo(0, -size * 1.5);
					ctx.lineTo(size * 1.5, 0);
					ctx.lineTo(0, size * 1.5);
					ctx.lineTo(-size * 1.5, 0);
					ctx.closePath();
					ctx.stroke();
					break;
  
				case 'bumper_expire':
					// Dissolving rings effect
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2 * (1 - progress);
					
					const rings = 3;
					for (let i = 0; i < rings; i++) {
						const ringProgress = (progress + (i / rings)) % 1;
						const ringRadius = 20 * ringProgress;
						
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, ringRadius, 0, Math.PI * 2);
						ctx.stroke();
						
						// Add dissolving particles
						const particleCount = 8;
						for (let j = 0; j < particleCount; j++) {
							const particleAngle = (j / particleCount) * Math.PI * 2;
							const distance = ringRadius * (1 + progress);
							const px = effect.x + Math.cos(particleAngle) * distance;
							const py = effect.y + Math.sin(particleAngle) * distance;
							
							ctx.fillStyle = '#4169E1';
							ctx.fillRect(px - 1, py - 1, 2, 2);
						}
					}
					break;
			}
			ctx.restore();
		});
	}


	function drawCountdown() {
    if (typeof gameState.countdown !== 'undefined') {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
  
      ctx.fillStyle = 'white';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillText(gameState.countdown, canvas.width / 2, canvas.height / 3);
      ctx.restore();
    }
	}
  
    // 3) Mise en place du redimensionnement du canvas
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    let scale = 1;

	    // Const for visual effects on notifications /
		const collisionEffects = [];
		const EFFECT_DURATION = 300;
		const SPAWN_EFFECT_DURATION = 500;
		const EXPIRE_EFFECT_DURATION = 300;
	  
		// spawn visual effect 
		function createSpawnEffect(type, x, y, effectType, color) {
		  const effect = {
			  type,
			  x,
			  y,
			  effectType,
			  color: color || '#FFFFFF',
			  startTime: Date.now(),
			  alpha: 1
		  };
		  collisionEffects.push(effect);
		  
		  setTimeout(() => {
			  const index = collisionEffects.indexOf(effect);
			  if (index > -1) {
				  collisionEffects.splice(index, 1);
			  }
		  }, type.includes('spawn') ? SPAWN_EFFECT_DURATION : EXPIRE_EFFECT_DURATION);
	  }
	
	  // collision visual effects
	  function createCollisionEffect(type, x, y, color) {
		const effect = {
			type,
			x,
			y,
			color,
			startTime: Date.now(),
			alpha: 1
		};
		collisionEffects.push(effect);
		
		// Remove effect after duration
		setTimeout(() => {
			const index = collisionEffects.indexOf(effect);
			if (index > -1) {
				collisionEffects.splice(index, 1);
			}
		}, EFFECT_DURATION);
	  }

  
    function handleResize() {
      const ORIGINAL_WIDTH = 800;
      const ORIGINAL_HEIGHT = 400;
      const margin = 12; // Marge interne utilisée pour le positionnement
      const container = document.querySelector('.game-container');
      if (!container) return;
  
      // Dimensions du conteneur et de la fenêtre
      const containerWidth = container.clientWidth;
      const windowHeight = window.innerHeight;
  
      // Calcul du scale en fonction de l'espace disponible
      let scale = Math.min(containerWidth / ORIGINAL_WIDTH, windowHeight * 0.7 / ORIGINAL_HEIGHT);
  
      // Appliquer le scale sur le canvas (dimension affichée)
      canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
      canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';
  
      // Garder la résolution logique du canvas inchangée
      canvas.width = ORIGINAL_WIDTH;
      canvas.height = ORIGINAL_HEIGHT;
      
      // Ajuster dynamiquement la hauteur du game-container (en fonction de la largeur)
      container.style.height = Math.min(windowHeight * 0.8, containerWidth / 2) + 'px';
  
      ctx.imageSmoothingEnabled = false;
  
      // Utilisation du facteur d'échelle pour d'autres ajustements
      const s = scale;
  
      // Positionnement absolu de score-display par rapport à game-container
      // On considère que :
      //   - Le canvas est positionné en absolute dans le game-container (déjà défini dans votre CSS).
      //   - Le canvas est décalé d'une marge (margin) par rapport au bord supérieur et gauche du container.
      // On positionne alors le score-display pour qu'il soit centré horizontalement sur le bord supérieur du canvas.
      const scoreDisplay = document.getElementById("score-display");
      if (scoreDisplay) {
          // Assurez-vous que le game-container est en position relative (pour que le positionnement absolu se fasse par rapport à lui)
          container.style.position = "relative";
          // Le canvas devrait être positionné en absolute (vérifiez votre CSS)
          // Récupérer la position du canvas par rapport au container (offsetLeft et offsetTop fonctionnent si le container est en position relative)
          const canvasLeft = canvas.offsetLeft;
          const canvasTop = canvas.offsetTop;
          // Calculer la largeur affichée du canvas (en pixels)
          const canvasDisplayWidth = ORIGINAL_WIDTH * s;
  
          // Placer le score-display centré sur le bord supérieur du canvas.
          // On fixe sa position verticale à la même valeur que canvasTop (souvent égale à la marge appliquée)
          // et sa position horizontale au centre du canvas.
          scoreDisplay.style.position = "absolute";
          scoreDisplay.style.left = (canvasLeft + canvasDisplayWidth / 2) + "px";
          scoreDisplay.style.top = (canvasTop + 2) + "px";
          // Pour centrer le score-display par rapport à son point de positionnement, on décale de 50% de sa largeur.
          scoreDisplay.style.transform = "translate(-50%, 0)";
          scoreDisplay.style.transformOrigin = "center top";
  
          // On fixe la taille de la police en pixels pour éviter les fluctuations liées aux unités rem
          scoreDisplay.style.fontSize = (30 * s) + "px";
      }
  }
  window.addEventListener('resize', handleResize);
  handleResize(); // initial
  
    // 4) Initialiser WebSocket
    const socket = new WebSocket(config.wsUrl);
    
    socket.onopen = () => {
      console.log("[live_game_utils] WebSocket connection opened:", config.wsUrl);
    };
    socket.onclose = () => {
      console.log("[live_game_utils] WebSocket connection closed.");
    };
  
    // 5) Gérer l'état du jeu local
    const activeEffects = { left: new Set(), right: new Set() };
    const effectTimers = {};
    let gameState = {
      type: 'game_state',
      ball_x: 400, 
      ball_y: 200,
      ball_size: 7,
      ball_speed_x: 4,
      ball_speed_y: 4,
      paddle_left_y: 170,
      paddle_right_y: 170,
      paddle_width: 10,
      paddle_left_height: 60,
      paddle_right_height: 60,
      score_left: 0, 
      score_right: 0,
      powerups: [],
      bumpers: [],
      flash_effect: false
    };
	// let showCountdown = false;
    // let countdownNumber = 3;
  
    // 6) Gérer la réception de messages WebSocket
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
  
      if (data.type === 'game_state') {
        // Mémoriser les effets actifs avant maj
        const prevLeft = new Set(activeEffects.left);
        const prevRight = new Set(activeEffects.right);
        gameState = data;
        // Réinjecter
        activeEffects.left = prevLeft;
        activeEffects.right = prevRight;
      }  else if (data.type === 'powerup_spawned') {
		const powerupColor = {
			'invert': '#FF69B4',
			'shrink': '#FF0000',
			'ice': '#00FFFF',
			'speed': '#FFD700',
			'flash': '#FFFF00',
			'sticky': '#32CD32'
		}[data.powerup.type] || '#FFFFFF';
		
		createSpawnEffect('powerup_spawn', 
			data.powerup.x, 
			data.powerup.y, 
			data.powerup.type,
			powerupColor);
	  } else if (data.type === 'powerup_expired') {
		createSpawnEffect('powerup_expire',
			data.powerup.x,
			data.powerup.y,
			data.powerup.type);
		} else if (data.type === 'bumper_spawned') {
			createSpawnEffect('bumper_spawn',
				data.bumper.x,
				data.bumper.y);
			
		} else if (data.type === 'bumper_expired') {
			createSpawnEffect('bumper_expire',
				data.bumper.x,
				data.bumper.y);
    } else if (data.type === 'countdown') {
      // Stocker le compte à rebours dans le gameState
      gameState.countdown = data.countdown_nb;
      // drawCountdown(data.countdown_nb);
		} else if (data.type === 'collision_event') {
			const collision = data.collision;
			switch(collision.type) {
				case 'paddle_collision':
					createCollisionEffect('paddle_collision', 
						collision.paddle_side === 'left' ? 60 : canvas.width - 60, 
						gameState.ball_y);
					break;
					
				case 'border_collision':
					createCollisionEffect('border_collision',
						collision.coor_x_collision,
						collision.border_side === 'up' ? 50 : 350);
					break;
					
				case 'bumper_collision':
					createCollisionEffect('bumper_collision',
						collision.bumper_x,
						collision.bumper_y);
					break;
			}
		}
		else if (data.type === 'game_over') {
        console.log("[live_game_utils] Game over detected");
        // alert("Game Over! Winner = " + data.winner);
        socket.close();
        resolve();  // 🔹 Signale à `runTournamentFlow()` que la partie est terminée
      }
      else if (data.type === 'powerup_applied') {
        // console.log(`[live_game_utils] Power-up applied to ${data.player}: ${data.effect}`);
        if (data.effect === 'flash') {
          applyFlashEffect(gameState);
          return;
        }
        let displaySide = data.player;
        if (!['speed','sticky'].includes(data.effect)) {
          // Les autres s'appliquent à l'adversaire
          displaySide = (data.player === 'left') ? 'right' : 'left';
        }
        activeEffects[displaySide].add(data.effect);
  
        // Timer pour retirer l'effet
        if (effectTimers[`${displaySide}_${data.effect}`]) {
          clearTimeout(effectTimers[`${displaySide}_${data.effect}`]);
        }
        effectTimers[`${displaySide}_${data.effect}`] = setTimeout(() => {
          console.log(`[live_game_utils] Removing effect ${data.effect} for ${displaySide}`);
          activeEffects[displaySide].delete(data.effect);
        }, data.duration * 1000);
      }
    };
  
    // 7) Gérer le clavier : en fonction de userRole
    const keysPressed = {};
  
    document.addEventListener('keydown', (evt) => {
      if (evt.repeat) return;
      let action = "start_move";
      let player = null, direction = null;
  
      // userRole = 'both' => local => on écoute W/S + flèches
      // userRole = 'left' => seulement W/S
      // userRole = 'right' => seulement flèches ↑/↓
      if (config.userRole === 'both' || config.userRole === 'left') {
        switch(evt.key) {
          case 'w':
          case 'W':
            player = 'left';
            direction = 'up';
            break;
          case 's':
          case 'S':
            player = 'left';
            direction = 'down';
            break;
        }
      }
      if ((config.userRole === 'both' || config.userRole === 'right') && !player) {
        switch(evt.key) {
          case 'ArrowUp':
            player = 'right';
            direction = 'up';
            break;
          case 'ArrowDown':
            player = 'right';
            direction = 'down';
            break;
        }
      }
  
      if (player && direction && !keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player, direction }));
        }
        keysPressed[evt.key] = true;
        // console.log(`[live_game_utils] start_move: ${player}, ${direction}`);
      }
    });
  
    document.addEventListener('keyup', (evt) => {
      let action = "stop_move";
      let player = null;
  
      // userRole=both/left => check W,S
      if (config.userRole === 'both' || config.userRole === 'left') {
        if (['w','W','s','S'].includes(evt.key)) {
          player = 'left';
        }
      }
      // userRole=both/right => check ArrowUp, ArrowDown
      if ((config.userRole === 'both' || config.userRole === 'right') && !player) {
        if (['ArrowUp','ArrowDown'].includes(evt.key)) {
          player = 'right';
        }
      }
  
      if (player && keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player}));
        }
        keysPressed[evt.key] = false;
        // console.log(`[live_game_utils] stop_move: ${player}`);
      }
    });
  
    // 8) Préparer les images powerups/bumper
    const powerupImages = {
      'invert': new Image(),
      'shrink': new Image(),
      'ice': new Image(),
      'speed': new Image(),
      'flash': new Image(),
      'sticky': new Image()
    };
    initPowerupImages(powerupImages);
  
    const bumperImage = new Image();
    bumperImage.src = createBumperSVG();


	// // -- Fonction pour démarrer la partie
  //   async function startGameWithCountdown(startGameBtn, onStartGame, gameId) {
	// 	showCountdown = true;
	// 	startGameBtn.classList.add('d-none');
		
	// 	// Start countdown animation
	// 	let count = 3;
		
	// 	// Function to update the countdown
  //   const updateCount = async () => {
	// 		countdownNumber = count;
	// 		count--;
			
	// 		if (count < 0) {
	// 			clearInterval(countdownInterval);
	// 			showCountdown = false;
	// 			// onStartGame && await onStartGame(gameId);
	// 		}
	// 	};
	
	// 	// Show first number immediately
	// 	updateCount();
		
	// 	// Then update every second
	// 	const countdownInterval = setInterval(updateCount, 1000);
	// }

  // async function displayCountdownNumber(countdown_nb, startGameBtn) {
	// 	showCountdown = true;
    
	// 	drawCountdown(countdown_nb)
		// Start countdown animation
		// let count = 3;
		
		// // Function to update the countdown
    // const updateCount = async () => {
		// 	countdownNumber = count;
		// 	count--;
			
		// 	if (count < 0) {
		// 		clearInterval(countdownInterval);
		// 		showCountdown = false;
		// 		// onStartGame && await onStartGame(gameId);
		// 	}
		// };
	
		// // Show first number immediately
		// updateCount();
		
		// // Then update every second
		// const countdownInterval = setInterval(updateCount, 1000);
	// }
  
    // 9) La boucle de dessin
    function draw() {
      if (gameState.flash_effect) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#101A32';
        ctx.fillRect(0,0,canvas.width, canvas.height);
  
        // Zone de jeu
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(50,50, canvas.width-100, canvas.height-100);
  
        // Dessin raquettes
        ['left','right'].forEach(side => {
          ctx.save();
          if (activeEffects[side].size > 0) {
            activeEffects[side].forEach(effect => {
              const glowColor = {
                'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
                'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
              }[effect];
              ctx.shadowColor = glowColor;
              ctx.shadowBlur = 10 * scale;
            });
          }
          ctx.fillStyle = 'white';
          if (side==='left') {
            ctx.fillRect(50, gameState.paddle_left_y,
                        gameState.paddle_width, gameState.paddle_left_height);
          } else {
            ctx.fillRect(canvas.width-50 - gameState.paddle_width, 
                        gameState.paddle_right_y,
                        gameState.paddle_width, gameState.paddle_right_height);
          }
          ctx.restore();
        });
  
        // Balle
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(gameState.ball_x, gameState.ball_y, gameState.ball_size, 0, 2*Math.PI);
        ctx.fill();
  
        // Powerups
        gameState.powerups.forEach(orb => {
          const type = orb.type || 'speed';
          const img = powerupImages[type];
          if (img.complete) {
            ctx.save();
            const glowColors = {
              'invert':'#FF69B4','shrink':'#FF0000','ice':'#00FFFF',
              'speed':'#FFD700','flash':'#FFFF00','sticky':'#32CD32'
            };
            ctx.shadowColor = glowColors[type] || '#FFD700';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(img, orb.x - 15, orb.y - 15, 30, 30);
            ctx.restore();
          }
        });
  
        // Bumpers
        gameState.bumpers.forEach(bmp => {
          if (bumperImage.complete) {
            ctx.save();
            ctx.shadowColor = '#4169E1';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(bumperImage,
              bmp.x - bmp.size, bmp.y - bmp.size,
              bmp.size*2, bmp.size*2
            );
            ctx.restore();
          }
        });
      }
  
      // Scores
      // ctx.fillStyle = 'white';
      // ctx.font = '20px Arial';
      // ctx.fillText(""+ gameState.score_left, 20, 30);
      // ctx.fillText(""+ gameState.score_right, canvas.width-40, 30);
      
      function updateScoreDisplay() {
        const scoreEl = document.getElementById("score-nb");
        if (scoreEl) {
          // Ici, on suppose que les noms sont déjà injectés via Django dans le HTML.
          // Par exemple, on pourrait avoir utilisé des attributs data pour conserver ces noms.
          // Si ce n'est pas le cas, vous pouvez également définir des variables globales injectées par Django.
          // Ici, nous allons lire le texte initial et remplacer uniquement la partie numérique.
          // Pour plus de flexibilité, vous pouvez modifier cette fonction selon vos besoins.
          // Exemple avec des attributs data (optionnel) :
          scoreEl.innerText = ` ${gameState.score_left} - ${gameState.score_right} `;
        }
        }

      // Affichage powerups actifs
      const powerupNames = {
        'speed':'SPEED','shrink':'SHRINK','ice':'ICE','sticky':'STICKY','invert':'INVERT'
      };
      // Gauche
      if (activeEffects.left.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.left.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          ctx.fillText(powerupNames[effect], 20, yOffset);
          yOffset+=25;
        });
      }
      // Droite
      if (activeEffects.right.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.right.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          const tW = ctx.measureText(powerupNames[effect]).width;
          ctx.fillText(powerupNames[effect], canvas.width-20 - tW, yOffset);
          yOffset+=25;
        });
      }
    updateScoreDisplay();
	  drawCollisionEffects();
	  drawCountdown();
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  
    // on peut retourner un objet si on veut
    return {
      socket,
      getGameState: () => gameState
    };
  });
}
  # game/game_loop/ball_utils.py
from .redis_utils import get_key, set_key, delete_key
from .dimensions_utils import get_terrain_rect
import time
import math
import random
import asyncio

BALL_MIN_SPEED = 1
BALL_MAX_SPEED = 20
# -------------- BALL : UPDATE OBJECTS  --------------------
def move_ball(game_id, ball):
    ball.x = float(get_key(game_id, "ball_x")) + float(get_key(game_id, "ball_vx"))
    ball.y = float(get_key(game_id, "ball_y")) + float(get_key(game_id, "ball_vy"))
    update_ball_redis(game_id, ball)


# async def reset_ball(game_id, ball):
#     terrain_rect = get_terrain_rect(game_id)
#     center_x = terrain_rect['left'] + terrain_rect['width'] // 2
#     center_y = terrain_rect['top'] + terrain_rect['height'] // 2

#     # Get the initial ball speed multiplier from Redis / added
#     speed_multiplier = float(get_key(game_id, "initial_ball_speed_multiplier"))
#     initial_speed_x = random.choice([-3, 3]) * speed_multiplier  # Base speed * multiplier / modified
#     initial_speed_y = random.choice([-3, 3]) * speed_multiplier

#     ball.reset(center_x, center_y, initial_speed_x, initial_speed_y) #modified
#     update_ball_redis(game_id, ball)

#     print(f"[game_loop.py] Ball reset to ({ball.x}, {ball.y}) with speed ({ball.speed_x}, {ball.speed_y})")


def reset_ball(game_id, ball):
    terrain_rect = get_terrain_rect(game_id)
    center_x = terrain_rect['left'] + terrain_rect['width'] // 2
    center_y = terrain_rect['top'] + terrain_rect['height'] // 2
    # Réinitialiser la balle en position centrale avec vitesse nulle
    ball.reset(center_x, center_y, 0, 0)
    update_ball_redis(game_id, ball)
    print(f"[game_loop.py] Ball reset to ({ball.x}, {ball.y}) with speed (0, 0)")
    # Lancer une tâche asynchrone qui, après 1 seconde, démarre la balle
    import asyncio  # S'assurer que asyncio est importé
    asyncio.create_task(start_ball_after_delay(game_id, ball))
    
async def start_ball_after_delay(game_id, ball):
    await asyncio.sleep(1)  # Attendre 1 seconde
    # Ici, vous pouvez définir les vitesses de départ souhaitées
    speed_multiplier = float(get_key(game_id, "initial_ball_speed_multiplier"))
    initial_speed_x = random.choice([-3, 3]) * speed_multiplier  # Base speed * multiplier / modified
    initial_speed_y = random.choice([-3, 3]) * speed_multiplier
    ball.speed_x = initial_speed_x
    ball.speed_y = initial_speed_y
    update_ball_redis(game_id, ball)
    print(f"[game_loop.py] Ball started with speed ({ball.speed_x}, {ball.speed_y})")

def move_ball_sticky(game_id, paddle_left, paddle_right, ball):
    stuck_side = get_key(game_id, "ball_stuck_side").decode('utf-8')  # 'left' ou 'right'
    
    # Récupérer la raquette correspondante
    if stuck_side == 'left':
        current_paddle = paddle_left
    else:
        current_paddle = paddle_right

    # Calculer y en fonction de sticky_relative_pos_<side>
    rel_pos = float(get_key(game_id, f"sticky_relative_pos_{stuck_side}") or 0)

    # Mettre la balle à la nouvelle position
    # X = collée contre la raquette
    if stuck_side == 'left':
        ball.x = current_paddle.x + current_paddle.width + ball.size
    else:
        ball.x = current_paddle.x - ball.size

    # Y = (paddle.y + rel_pos)
    ball.y = current_paddle.y + rel_pos

    # Vérifier si on doit la relâcher (ex: après 1s)
    start_t = float(get_key(game_id, f"sticky_start_time_{stuck_side}") or 0)
    if time.time() - start_t >= 1.0:
        # Relâcher la balle avec un petit boost
        release_ball_sticky(game_id, current_paddle, stuck_side, ball)



# -------------- BALL : UPDATE REDIS KEYS  --------------------
def stick_ball_to_paddle(game_id, stuck_side, current_paddle, ball):
    """
    Colle la balle sur la raquette <stuck_side>.
    """
    print(f"[sticky] stick ball to {stuck_side} paddle")
    # Calcul de la position relative
    relative_pos = ball.y - current_paddle.y

    # Stocker la vitesse originale de la balle pour la remettre plus tard (facultatif)
    set_key(game_id, "ball_original_vx", ball.speed_x)
    set_key(game_id, "ball_original_vy", ball.speed_y)

    # Indiquer en Redis que la balle est collée à cette raquette
    set_key(game_id, "ball_stuck", 1)
    set_key(game_id, "ball_stuck_side", stuck_side)
    set_key(game_id, f"sticky_relative_pos_{stuck_side}", relative_pos)
    set_key(game_id, f"sticky_start_time_{stuck_side}", time.time())

    # Mettre la balle immobile
    ball.speed_x = 0
    ball.speed_y = 0

    # Positionner la balle contre la raquette
    if stuck_side == 'left':
        ball.x = current_paddle.x + current_paddle.width + ball.size
    else:
        ball.x = current_paddle.x - ball.size

def release_ball_sticky(game_id, current_paddle, stuck_side, ball):
    print(f"[sticky] Releasing ball from {stuck_side} paddle")
    # on conserve l'ancienne

    # On récupère la vitesse originale (si on l'avait stockée)
    ball.speed_x = float(get_key(game_id, "ball_original_vx") or BALL_MIN_SPEED)
    ball.speed_y = float(get_key(game_id, "ball_original_vy") or BALL_MIN_SPEED)

    # on donne le status speed boosted pour la rendre plus rapide lors de la prochaine collision avec le paddle
    set_key(game_id, "ball_speed_boosted", 1)
    # manage_ball_speed_and_angle(game_id, current_paddle, stuck_side, ball)

    # Nettoyage des cles ayant permis a la balle de stuck
    delete_key(game_id, "ball_stuck")
    delete_key(game_id, "ball_stuck_side")
    delete_key(game_id, f"sticky_relative_pos_{stuck_side}")
    delete_key(game_id, f"sticky_start_time_{stuck_side}")
    delete_key(game_id, "ball_original_vx")
    delete_key(game_id, "ball_original_vy")

    # Nettoyer le flag sticky de la raquette
    delete_key(game_id, f"paddle_{stuck_side}_sticky")

# -------------- BALL : UPDATE REDIS GENERAL KEYS --------------------

def manage_ball_speed_and_angle(game_id, current_paddle, paddle_side, ball):
    
    ball_already_boosted = get_key(game_id, "ball_speed_already_boosted")
    ball_speed_boosted = get_key(game_id, "ball_speed_boosted")
    if ball_already_boosted and ball_already_boosted.decode('utf-8') == '1':
        ball.speed_x = float(get_key(game_id, "ball_speed_x_before_boost") or BALL_MIN_SPEED)
        ball.speed_y = float(get_key(game_id, "ball_speed_y_before_boost") or BALL_MIN_SPEED)
        delete_key(game_id, "ball_speed_x_before_boost")
        delete_key(game_id, "ball_speed_y_before_boost")
        delete_key(game_id, "ball_speed_already_boosted")
    
    if ball_speed_boosted and ball_speed_boosted.decode('utf-8') == '1':
        set_key(game_id, "ball_speed_x_before_boost", ball.speed_x)
        set_key(game_id, "ball_speed_y_before_boost", ball.speed_y)
        set_key(game_id, "ball_speed_already_boosted", 1)
        delete_key(game_id, "ball_speed_boosted")
        tmp_speed = math.hypot(ball.speed_x, ball.speed_y) * 2
    else :
        tmp_speed = math.hypot(ball.speed_x, ball.speed_y) + 0.3
    
    #calculer la vitesse de renvoi de la balle
    new_speed = max(BALL_MIN_SPEED, min(BALL_MAX_SPEED, tmp_speed)) 

    # calculer l'angle de renvoi de la balle
    relative_y = (ball.y - (current_paddle.y + current_paddle.height / 2)) / (current_paddle.height / 2)
    relative_y = max(-1, min(1, relative_y))  # Limiter à l'intervalle [-1, 1]
    angle = relative_y * (math.pi / 4)  # Max 45 degrés

    # definir la speed_x et y grace à la vitesse generale et l'angle de renvoi calculé
    new_speed_x = new_speed * math.cos(angle)
    if paddle_side == 'left':
        ball.speed_x = new_speed_x
    else:
        ball.speed_x = -new_speed_x

    ball.speed_y = new_speed * math.sin(angle)



def update_ball_redis(game_id, ball):
    set_key(game_id, "ball_x", ball.x)
    set_key(game_id, "ball_y", ball.y)
    set_key(game_id, "ball_vx", ball.speed_x)
    set_key(game_id, "ball_vy", ball.speed_y)# game/game_loop/broadcast.py

from channels.layers import get_channel_layer
from .redis_utils import get_key


# --------- GAME STATE : NOTIFICATIONS -----------
async def broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers):
    """
    Envoie l'état actuel du jeu aux clients via WebSocket.
    """
    # Récupérer les états des power-ups
    powerups_data = []
    for powerup_orb in powerup_orbs:
        active = get_key(game_id, f"powerup_{powerup_orb.effect_type}_active" or 0)
        if active and active.decode('utf-8') == '1':
            x = float(get_key(game_id, f"powerup_{powerup_orb.effect_type}_x") or 0)
            y = float(get_key(game_id, f"powerup_{powerup_orb.effect_type}_y") or 0)
            powerups_data.append({
                'type': powerup_orb.effect_type,
                'x': x,
                'y': y,
                'color': list(powerup_orb.color)  # Convertir en liste pour JSON
            })

    # Récupérer les états des bumpers
    # print(f"[game_loop.py] bumpers to send: {bumpers}")
    bumpers_data = []
    for bumper in bumpers:
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active" or 0)
        if active and active.decode('utf-8') == '1':
            x = float(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x") or 0)
            y = float(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y") or 0)
            bumpers_data.append({
                'x': x,
                'y': y,
                'size': bumper.size,
                'color': list(bumper.color)  # Convertir en liste pour JSON
            })

    data = {
        'type': 'game_state',
        'ball_x': ball.x,
        'ball_y': ball.y,
        'ball_size': ball.size,
        'ball_speed_x': ball.speed_x,
        'ball_speed_y': ball.speed_y,
        'paddle_left_y': paddle_left.y,
        'paddle_right_y': paddle_right.y,
        'paddle_width': paddle_left.width,
        'paddle_left_height': paddle_left.height,
        'paddle_right_height': paddle_right.height,
        'score_left': int(get_key(game_id, "score_left") or 0),
        'score_right': int(get_key(game_id, "score_right") or 0),
        'powerups': powerups_data,
        'bumpers': bumpers_data,
        'flash_effect': bool(get_key(game_id, f"flash_effect"))
    }
    # IMPROVE le flash effect peut etre renvoye en notif powerup applied

    await channel_layer.group_send(f"pong_{game_id}", {
        'type': 'broadcast_game_state',
        'data': data
    })
    # print(f"[game_loop.py] Broadcast game_state for game_id={game_id}")




# --------- POWER UPS : NOTIFICATIONS -----------
async def notify_powerup_spawned(game_id, powerup_orb):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_spawned',
            'powerup': {
                'type': powerup_orb.effect_type,
                'x': powerup_orb.x,
                'y': powerup_orb.y,
                'color': list(powerup_orb.color)
            }
        }
    )

async def notify_countdown(game_id, countdown_nb):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'countdown',
            'countdown_nb': countdown_nb
        }
    )

# async def notify_start_game(game_id):
#     channel_layer = get_channel_layer()
#     await channel_layer.group_send(
#         f"pong_{game_id}",
#         {
#             'type': 'start_game',
#         }
#     )

async def notify_powerup_applied(game_id, player, effect, effect_duration):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_applied',
            'player': player,
            'effect': effect,
            'duration': effect_duration
        }
    )

async def notify_powerup_expired(game_id, powerup_orb):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_expired',
            'powerup': {
                'type': powerup_orb.effect_type,
                'x': powerup_orb.x,
                'y': powerup_orb.y
            }
        }
    )

# --------- BUMPERS : NOTIFICATIONS -----------
async def notify_bumper_spawned(game_id, bumper):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'bumper_spawned',
            'bumper': {
                'x': bumper.x,
                'y': bumper.y,
            }
        }
    )


async def notify_bumper_expired(game_id, bumper):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'bumper_expired',
            'bumper': {
                'x': bumper.x,
                'y': bumper.y
            }
        }
    )

# --------- COLLISIONS : NOTIFICATIONS -----------
async def notify_collision(game_id, collision_info):
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'collision_event',
            'collision': collision_info
        }
    )

async def notify_paddle_collision(game_id, paddle_side, ball):
    collision_info = {
        'type': 'paddle_collision',
        'paddle_side': paddle_side,
        'new_speed_x': ball.speed_x,
        'new_speed_y': ball.speed_y,
    }
    await notify_collision(game_id, collision_info)

    print(f"[collisions.py] Ball collided with {paddle_side} paddle. New speed: ({ball.speed_x}, {ball.speed_y})")

async def notify_border_collision(game_id, border_side, ball):
    collision_info = {
        'type': 'border_collision',
        'border_side': border_side,
        'coor_x_collision': ball.x,
    }
    await notify_collision(game_id, collision_info)

    print(f"[collisions.py] Ball collided with {border_side} border at coor x = {ball.x}.")

async def notify_bumper_collision(game_id, bumper, ball):
    collision_info = {
        'type': 'bumper_collision',
        'bumper_x': bumper.x,
        'bumper_y': bumper.y,
        'new_speed_x': ball.speed_x,
        'new_speed_y': ball.speed_y,
    }
    await notify_collision(game_id, collision_info)



# --------- END GAME : NOTIFICATIONS  -----------

async def notify_game_finished(game_id, tournament_id, winner, looser):
    # Si winner et looser sont des objets CustomUser, on récupère leur username,
    # sinon on les laisse tels quels (cas d'un match en mode local, où ce sont déjà des chaînes)
    winner_serializable = winner.username if hasattr(winner, 'username') else winner
    looser_serializable = looser.username if hasattr(looser, 'username') else looser

    print(f"[broadcast.py] notify_game_finished winner: {winner_serializable} looser: {looser_serializable} tournament_id: {tournament_id}")
    channel_layer = get_channel_layer()
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'game_over',
            'tournament_id': str(tournament_id),
            'winner': winner_serializable,
            'looser': looser_serializable
        }
    )# game/game_loop/bumpers_utils.py

import time
from .redis_utils import get_key, set_key, delete_key
from .dimensions_utils import get_terrain_rect
from .broadcast import notify_bumper_spawned, notify_bumper_expired
import random

MAX_ACTIVE_BUMPERS = 2
SPAWN_INTERVAL_BUMPERS = 10
# -------------- BUMPERS --------------------
async def handle_bumpers_spawn(game_id, bumpers, current_time):
    # Initialisation de last_bumper_spawn_time si elle n'est pas déjà définie
    if not hasattr(handle_bumpers_spawn, "last_bumper_spawn_time"):
        handle_bumpers_spawn.last_bumper_spawn_time = current_time  # Initialisation lors du premier appel

    # Utilisation de la variable statique pour vérifier l'intervalle de temps
    if current_time - handle_bumpers_spawn.last_bumper_spawn_time >= SPAWN_INTERVAL_BUMPERS:
        active_bumpers = count_active_bumpers(game_id, bumpers)
        if active_bumpers < MAX_ACTIVE_BUMPERS:
            # S'assurer qu'on ne génère qu'un seul bumper à la fois
            bumper = random.choice(bumpers)
            if not bumper.active:
                terrain = get_terrain_rect(game_id)
                spawned = await spawn_bumper(game_id, bumper, terrain)
                if spawned:
                    # Mettre à jour le temps de spawn du bumper pour éviter les doubles spawns
                    handle_bumpers_spawn.last_bumper_spawn_time = current_time
                    print(f"[game_loop.py] game_id={game_id} - Bumper spawned at ({bumper.x}, {bumper.y}).")


async def spawn_bumper(game_id, bumper, terrain_rect):
    if bumper.spawn(terrain_rect):
        set_bumper_redis(game_id, bumper)
        print(f"[game_loop.py] Bumper spawned at ({bumper.x}, {bumper.y})")
        await notify_bumper_spawned(game_id, bumper)
        return True
    return False

def count_active_bumpers(game_id, bumpers):
    count = 0
    for bumper in bumpers:
        # active = int(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0)
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0
        if active and active.decode('utf-8') == '1':
        # if active :
            count += 1
    print(f"[loop.py] count_active_bumpers ({count})")
    return count

async def handle_bumper_expiration(game_id, bumpers):
    current_time = time.time()
    for bumper in bumpers:
        active = get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0
        # active = int(get_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active") or 0)
        if active and active.decode('utf-8') == '1'and current_time - bumper.spawn_time >= bumper.duration:
        # if active and current_time - bumper.spawn_time >= bumper.duration:
            delete_bumper_redis(game_id, bumper)
            print(f"[loop.py] Bumper at ({bumper.x}, {bumper.y}) expired")
            await notify_bumper_expired(game_id, bumper)

# -------------- BUMPERS : UPDATE REDIS DATA --------------------
def set_bumper_redis(game_id, bumper):
    bumper.activate()
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active", 1)
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x", bumper.x)
    set_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y", bumper.y)


def delete_bumper_redis(game_id, bumper):
    bumper.deactivate()
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_active")
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_x")
    delete_key(game_id, f"bumper_{bumper.x}_{bumper.y}_y")# game/game_loop/collisions.py

import math
import random
import time
from asgiref.sync import sync_to_async
from .ball_utils import  stick_ball_to_paddle, manage_ball_speed_and_angle, update_ball_redis
from .redis_utils import get_key, set_key, delete_key
from .powerups_utils import apply_powerup
from .broadcast import notify_paddle_collision, notify_border_collision, notify_bumper_collision, notify_powerup_applied

MIN_SPEED = 1.0

# async def handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball):
#     """
#     Gère le fait qu'on marque un point ou qu'on ait juste un rebond sur la raquette.
#     Retourne 'score_left', 'score_right' ou None si on continue le jeu.
#     """
    
#     # 1) Vérifier si la balle sort à gauche => point pour la droite
#     if ball.x - ball.size <= paddle_left.x + paddle_left.width:
#     # if ball.x - ball.size  <= paddle_left.x:
#         # Soit on a collision, soit c'est un but
#         if paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height:
#             # Collision raquette gauche
#             # Vérifier sticky
#             is_sticky = bool(get_key(game_id, "paddle_left_sticky") or 0)
#             if is_sticky : 
#                 is_already_stuck = bool(get_key(game_id, "ball_stuck") or 0)
#                 if not is_already_stuck:
#                     # On "colle" la balle
#                     stick_ball_to_paddle(game_id, 'left', paddle_left, ball)
#                     # set_key(game_id, "paddle_left_already_stuck", 1)
#                 return None
#             else:

#                 # Rebond classique
#                 ball.last_player = 'left'
#                 await process_paddle_collision(game_id, 'left', paddle_left, ball)
#                 return None
#         else:
#             # Balle sortie côté gauche => score pour la droite
#             return 'score_right'

#     # 2) Vérifier si la balle sort à droite => point pour la gauche
#     if ball.x + ball.size >= paddle_right.x - paddle_right.width :
#     # if ball.x  >= paddle_right.x:
#         if paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height:
#             # Collision raquette droite
#             is_sticky = bool(get_key(game_id, "paddle_right_sticky") or 0)
#             if is_sticky:
#                 is_already_stuck = bool(get_key(game_id, "ball_stuck") or 0)
#                 if not is_already_stuck:
#                     # On "colle" la balle
#                     stick_ball_to_paddle(game_id, 'right', paddle_right, ball)
#                     # set_key(game_id, "paddle_right_already_stuck", 1)
#                 return None
#             else:
#                 ball.last_player = 'right'
#                 await process_paddle_collision(game_id, 'right', paddle_right, ball)
#                 return None
#         else:
#             return 'score_left'

#     return None

async def handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball):
    """
    Gère le fait qu'on marque un point ou qu'on ait juste un rebond sur la raquette.
    Retourne 'score_left', 'score_right' ou None si on continue le jeu.
    """
    # 1) Vérifier si la balle est passée suffisamment pour être considérée comme un but
    # Ici, on utilise le centre de la balle (ball.x) pour déterminer le score.
    if ball.x + ball.size <= paddle_left.x + paddle_left.width and not (paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height):
        return 'score_right'
    if ball.x - ball.size >= paddle_right.x - paddle_right.width and not (paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height):
        return 'score_left'
    
    # 2) Vérifier la collision avec la raquette gauche
    # Ici, on détecte la collision dès que le bord gauche de la balle touche la raquette.
    if ball.speed_x < 0 and (ball.x - ball.size) <= (paddle_left.x + paddle_left.width):
        if paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height:
            # Si la balle touche la raquette, réaligner la balle sur le bord de la raquette
            ball.x = paddle_left.x + paddle_left.width + ball.size
            await process_paddle_collision(game_id, 'left', paddle_left, ball)
            return None

    # 3) Vérifier la collision avec la raquette droite
    # Ici, on détecte la collision dès que le bord droit de la balle touche la raquette.
    if ball.speed_x > 0 and (ball.x + ball.size) >= (paddle_right.x - paddle_right.width):
        if paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height:
            # Réaligner la balle sur le bord de la raquette
            ball.x = paddle_right.x - paddle_right.width - ball.size
            await process_paddle_collision(game_id, 'right', paddle_right, ball)
            return None

    return None

#ball
async def process_paddle_collision(game_id, paddle_side, current_paddle, ball):
    """
    Gère la logique de collision entre la balle et une raquette.
    Ajuste la vitesse et la direction de la balle, met à jour Redis et notifie les clients.
    """
    print("process_paddle_collision")


    # speed = math.hypot(ball.speed_x, ball.speed_y) * 1.03  # Augmenter la vitesse
    speed = manage_ball_speed_and_angle(game_id, current_paddle, paddle_side, ball)




    # Mettre à jour la balle dans Redis
    update_ball_redis(game_id, ball)

    # Notifier la collision via WebSocket
    await notify_paddle_collision(game_id, paddle_side, ball)
    

async def handle_border_collisions(game_id, ball):
    """
    Gère les collisions avec les bords supérieur et inférieur.
    Ajuste la vitesse de la balle en conséquence.
    """
    if ball.y - ball.size <= 50:
        border_side = "up"
        ball.speed_y = abs(ball.speed_y)  # Rebond vers le bas
        update_ball_redis(game_id, ball)
        await notify_border_collision(game_id, border_side, ball)

    elif ball.y + ball.size >= 350:
        border_side = "down"
        ball.speed_y = -abs(ball.speed_y)  # Rebond vers le haut
        update_ball_redis(game_id, ball)
        await notify_border_collision(game_id, border_side, ball)


async def handle_bumper_collision(game_id, ball, bumpers):
    """
    Gère les collisions entre la balle et les bumpers.
    Ajuste la vitesse et la direction de la balle, met à jour Redis et notifie les clients.
    """
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active:
            dist = math.hypot(ball.x - bumper.x, ball.y - bumper.y)
            if dist <= ball.size + bumper.size:
                # if current_time - bumper.last_collision_time >= COOLDOWN_TIME:
                angle = math.atan2(ball.y - bumper.y, ball.x - bumper.x)
                speed = math.hypot(ball.speed_x, ball.speed_y)
                ball.speed_x = speed * math.cos(angle)
                ball.speed_y = speed * math.sin(angle)

                # Mettre à jour la balle dans Redis
                update_ball_redis(game_id, ball)

                # IMPROVE (inutile ?) Mettre à jour le temps de la dernière collision
                bumper.last_collision_time = current_time

                # Notifier la collision via WebSocket
                await notify_bumper_collision(game_id, bumper, ball)
                    

async def handle_powerup_collision(game_id, ball, powerup_orbs):
    """
    Vérifie si la balle a ramassé un power-up en dehors des collisions avec les paddles.
    Applique l'effet du power-up au joueur concerné, met à jour Redis et notifie les clients.
    """
    for powerup_orb in powerup_orbs:
        if powerup_orb.active:
            dist = math.hypot(ball.x - powerup_orb.x, ball.y - powerup_orb.y)
            if dist <= ball.size + powerup_orb.size:
                # Associer le power-up au dernier joueur qui a touché la balle
                last_player = ball.last_player
                if last_player:
                    await apply_powerup(game_id, last_player, powerup_orb)
# game/game_loop/dimensions_utils.py
def get_terrain_rect(game_id):
    """
    Retourne les dimensions du terrain. Peut être ajusté pour récupérer les dimensions dynamiquement.
    """
    return {
        'left': 50,
        'top': 50,
        'width': 700,
        'height': 300
    }
# game/game_loop/initialize_game.py

from .redis_utils import set_key
from ..game_objects import Paddle, Ball, PowerUpOrb, Bumper
from .dimensions_utils import get_terrain_rect


FIELD_HEIGHT = 300

#------------- INITIALIZE : CREATE ALL GAME OBJECTS WITH THEIR INITIAL VALUES --------------
def initialize_game_objects(game_id, parameters):
    paddle_size = {1: 30, 2: 60, 3: 90}[parameters.paddle_size]
    paddle_speed = 6  # Peut être ajusté si nécessaire
    ball_speed_multiplier = parameters.ball_speed

    # Obtenir les dimensions du terrain
    terrain_rect = get_terrain_rect(game_id)

    # Initialiser les raquettes
    paddle_left = Paddle('left', paddle_size, paddle_speed)
    paddle_right = Paddle('right', paddle_size, paddle_speed)

    # Initialiser la balle
    initial_ball_speed_x = 4 * ball_speed_multiplier
    initial_ball_speed_y = 4 * ball_speed_multiplier
    ball = Ball(
        terrain_rect['left'] + terrain_rect['width'] // 2,
        terrain_rect['top'] + terrain_rect['height'] // 2,
        initial_ball_speed_x,
        initial_ball_speed_y
    )

    # Initialiser les power-ups et bumpers
    powerup_orbs = [
        PowerUpOrb(game_id, 'invert', terrain_rect, color=(255, 105, 180)),  # Rose pour inverser
        PowerUpOrb(game_id, 'shrink', terrain_rect, color=(255, 0, 0)),      # Rouge pour rétrécir
        PowerUpOrb(game_id, 'ice', terrain_rect, color=(0, 255, 255)),       # Cyan pour glace
        PowerUpOrb(game_id, 'speed', terrain_rect, color=(255, 215, 0)),     # Or pour vitesse
        PowerUpOrb(game_id, 'flash', terrain_rect, color=(255, 255, 0)),     # Jaune pour flash
        PowerUpOrb(game_id, 'sticky', terrain_rect, color=(50, 205, 50))     # Vert lime pour collant
    ]

    bumpers = []
    if parameters.obstacles_enabled:
        bumpers = [Bumper(game_id, terrain_rect) for _ in range(3)]  # Ajuster le nombre si nécessaire

    return paddle_left, paddle_right, ball, powerup_orbs, bumpers



#------------- INITIALIZE : UPDATE REDIS DATABASE WITH OBJECTS VALUES--------------
def initialize_redis(game_id, paddle_left, paddle_right, ball, parameters):
    # Positions initiales des raquettes
    set_key(game_id, "paddle_left_y", paddle_left.y)
    set_key(game_id, "paddle_right_y", paddle_right.y)

    # Vélocités initiales des raquettes (0 => immobiles)
    set_key(game_id, "paddle_left_velocity", 0)
    set_key(game_id, "paddle_right_velocity", 0)

    # Store initial paddle heights from parameters / added
    initial_height = {1: 60, 2: 80, 3: 100}[parameters.paddle_size]
    set_key(game_id, "initial_paddle_height", initial_height)
    set_key(game_id, "paddle_left_height", initial_height)
    set_key(game_id, "paddle_right_height", initial_height)

    # Balle
    set_key(game_id, "ball_x", ball.x)
    set_key(game_id, "ball_y", ball.y)
    set_key(game_id, "ball_vx", ball.speed_x)
    set_key(game_id, "ball_vy", ball.speed_y)

    # Store initial ball speed multiplier from parameters / added
    initial_speed = {1: 1, 2: 1.5, 3: 2}[parameters.ball_speed]
    set_key(game_id, "initial_ball_speed_multiplier", initial_speed)# game/game_loop/loop.py

import asyncio
import time
from django.conf import settings
from channels.layers import get_channel_layer
# from asgiref.sync import sync_to_async

from .redis_utils import get_key
from .models_utils import get_gameSession_status, get_gameSession, is_online_gameSession, get_gameSession_parameters, set_gameSession_status
from .initialize_game import initialize_game_objects, initialize_redis
from .paddles_utils import move_paddles
from .ball_utils import move_ball, move_ball_sticky, reset_ball
from .collisions import (
    handle_scoring_or_paddle_collision,
    # make_paddle_sticky,
    handle_border_collisions,
    handle_bumper_collision,
    handle_powerup_collision
)
from .score_utils import handle_score, winner_detected, finish_game
from .bumpers_utils import handle_bumpers_spawn, handle_bumper_expiration
from .powerups_utils import handle_powerups_spawn, handle_powerup_expiration
from .broadcast import broadcast_game_state, notify_countdown

class WaitForPlayersTimeout(Exception):
    """Exception levée lorsqu'un délai d'attente est dépassé avant que les joueurs ne soient prêts."""
    pass

async def wait_for_players(game_id):
    print(f"[game_loop.py] wait_for_players {game_id}.")
    timeout = 30  # Durée maximale d'attente en secondes.
    start_time = time.time()
    
    # Boucle d'attente pour vérifier si les joueurs sont prêts
    while time.time() - start_time < timeout:
        gs = await get_gameSession(game_id)
        if gs.ready_left and gs.ready_right:
            print(f"[game_loop.py] wait_for_players Everyone is READY {game_id}.")
            return True
        await asyncio.sleep(0.1)  # Petite pause pour éviter une boucle trop chargée
    
    # Si le timeout est dépassé, on lève une exception
    raise WaitForPlayersTimeout(f"Délai d'attente de {timeout} secondes dépassé pour game_id {game_id}.")


async def countdown_before_game(game_id):
    for countdown_nb in range(3, 0, -1):
        await notify_countdown(game_id, countdown_nb)
        await asyncio.sleep(1)

# async def countdown_between_goals(game_id):
#     for countdown_nb in range(3, 0, -1):
#         await notify_countdown(game_id, countdown_nb)
#         await asyncio.sleep(1)

async def game_loop(game_id):
    """
    Boucle principale pour UNE partie identifiée par game_id.
    Tourne ~90 fois/s tant que la partie n'est pas 'finished'.
    """
    channel_layer = get_channel_layer()
    dt = 1/90
    print(f"[game_loop.py] Starting loop for game_id={game_id}.")
    try:
        await wait_for_players(game_id)
        await countdown_before_game(game_id)
        # Récupérer/charger les paramètres
        parameters = await get_gameSession_parameters(game_id)


        # Construire les objets (raquettes, balle, powerups, bumpers)
        paddle_left, paddle_right, ball, powerup_orbs, bumpers = initialize_game_objects(game_id, parameters)
        initialize_redis(game_id, paddle_left, paddle_right, ball, parameters)
        print(f"[game_loop] Game objects initialisés pour game_id={game_id}")

        
        await set_gameSession_status(game_id, "running")
        
        # 2) Lancer la boucle ~90fps 
        while True:
            # Vérifier si la partie est encore 'running' ou si on l'a terminée
            session_status = await get_gameSession_status(game_id)
            if session_status != 'running':
                print(f"[game_loop] game_id={game_id} => statut={session_status}. Fin de la boucle.")
                break

            current_time = time.time()

            # 2.1 - Mouvements
            move_paddles(game_id, paddle_left, paddle_right)

            #creer fonction is_sticky dans powerup utils ou ball utils
            stuck_flag = get_key(game_id, "ball_stuck")
            if stuck_flag and stuck_flag.decode('utf-8') == '1':
                move_ball_sticky(game_id, paddle_left, paddle_right, ball)
            else :
                move_ball(game_id, ball)
            # print(f"1")#debug
            # 2.2 - Collisions
            await handle_border_collisions(game_id, ball)
            await handle_bumper_collision(game_id, ball, bumpers)
            await handle_powerup_collision(game_id, ball, powerup_orbs)
            # print(f"2")#debug

            # 2.3 - Paddles / Score
            scorer = await handle_scoring_or_paddle_collision(game_id, paddle_left, paddle_right, ball)
            if scorer in ['score_left', 'score_right']:
                handle_score(game_id, scorer)

                # Vérifier si on a un gagnant
                if winner_detected(game_id):
                    await finish_game(game_id)
                    break
                else:
                    # Sinon reset de la balle
                    reset_ball(game_id, ball)

            # print(f"3")#debug
            # 2.4 - Powerups & Bumpers
            if parameters.bonus_enabled:
                await handle_powerups_spawn(game_id, powerup_orbs, current_time)
                await handle_powerup_expiration(game_id, powerup_orbs)

            if parameters.obstacles_enabled:
                await handle_bumpers_spawn(game_id, bumpers, current_time)
                await handle_bumper_expiration(game_id, bumpers)
            # print(f"4")#debug

            # 2.5 - Broadcast de l'état
            await broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, powerup_orbs, bumpers)

            # print(f"5")#debug
            # 2.6 - Attendre ~16ms
            await asyncio.sleep(dt)

    except Exception as e:
        print(f"[game_loop] Exception pour game_id={game_id} : {e}")

    finally:
        print(f"[game_loop] Fin du game_loop pour game_id={game_id}.")# game/game_loop/models_utils.py
from django.apps import apps  # Import retardé pour éviter les conflits d'import
from asgiref.sync import sync_to_async

class GameSessionNotFound(Exception):
    """Exception personnalisée pour le cas où la session n'existe pas."""
    pass

class GameParametersNotFound(Exception):
    """Exception levée lorsqu'aucun GameParameters n'est défini dans la GameSession."""
    pass

async def get_gameSession(game_id):
    # print("get_gamesession")
    GameSession = apps.get_model('game', 'GameSession')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        return session
    except GameSession.DoesNotExist as e:
        raise GameSessionNotFound(f"La GameSession avec l'ID {game_id} n'existe pas.") from e

async def get_gameSession_status(game_id):
    # print("get_gameSession_status")
    session = await get_gameSession(game_id)
    return session.status

async def is_online_gameSession(game_id):
    # print("is_online_gameSession")
    session = await get_gameSession(game_id)
    return session.is_online

async def set_gameSession_status(game_id, status):
    # print("set_gameSession_status")
    GameSession = apps.get_model('game', 'GameSession')
    try:
        # Précharger player_left et player_right pour éviter des appels ORM en mode lazy
        session = await sync_to_async(
            GameSession.objects.select_related('player_left', 'player_right').get
        )(pk=game_id)
        session.status = status
        await sync_to_async(session.save)()
        return session
    except GameSession.DoesNotExist as e:
        raise GameSessionNotFound(f"La GameSession avec l'ID {game_id} n'existe pas.") from e

async def get_gameSession_parameters(game_id):
    GameSession = apps.get_model('game', 'GameSession')
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        parameters = await sync_to_async(getattr)(session, 'parameters', None)
    except parameters is None:
        raise GameParametersNotFound(f"La GameSession avec l'ID {game_id} n'a pas de paramètres définis.")
    return parameters

async def get_LocalTournament(game_id, phase):
    # print("get_LocalTournament")
    LocalTournament = apps.get_model('game', 'LocalTournament')
    if phase == "semifinal1":
        tournament = await sync_to_async(LocalTournament.objects.filter(semifinal1__id=game_id).first)()
    elif phase == "semifinal2":
        tournament = await sync_to_async(LocalTournament.objects.filter(semifinal2__id=game_id).first)()
    else:
        tournament = await sync_to_async(LocalTournament.objects.filter(final__id=game_id).first)()
    return tournament

async def create_gameResults(game_id, gameSession_isOnline, endgame_infos):
    """Crée un GameResult après la fin d'un match."""
    GameSession = apps.get_model('game', 'GameSession')
    GameResult = apps.get_model('game', 'GameResult')

    try:
        print(f"[create_gameResults] Creating GameResult for game {game_id}...")
        # Récupérer la session de jeu en mode async
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)

        # ✅ Regrouper la création de GameResult dans une fonction synchrone
        def save_game_result():
            print(f"[create_gameResults] GameResult CREATED")
            GameResult.objects.create(
                game=session,
                winner=endgame_infos['winner'],
                looser=endgame_infos['looser'],
                winner_local=endgame_infos['winner_local'],
                looser_local=endgame_infos['looser_local'],
                score_left=endgame_infos['score_left'],
                score_right=endgame_infos['score_right']
            )

        # ✅ Exécuter la sauvegarde dans un thread synchrone sécurisé
        await sync_to_async(save_game_result, thread_sensitive=True)()

    except GameSession.DoesNotExist:
        print(f"[create_gameResults] GameSession {game_id} does not exist.")
    except Exception as e:
        print(f"[create_gameResults] Error creating GameResult: {e}")# game/game_loop/paddles_utils.py
from .redis_utils import get_key, set_key
from .dimensions_utils import get_terrain_rect
# FIELD_HEIGHT = 400

# -------------- PADDLES --------------------
def move_paddles(game_id, paddle_left, paddle_right):
    # 1) Lire les infos depuis Redis
    left_vel = float(get_key(game_id, "paddle_left_velocity") or 0)
    right_vel = float(get_key(game_id, "paddle_right_velocity") or 0)

    # Hauteurs
    new_left_height = float(get_key(game_id, "paddle_left_height") or paddle_left.height)
    new_right_height = float(get_key(game_id, "paddle_right_height") or paddle_right.height)

    # Effets
    is_left_inverted = bool(get_key(game_id, "paddle_left_inverted"))
    is_right_inverted = bool(get_key(game_id, "paddle_right_inverted"))
    is_left_on_ice = bool(get_key(game_id, "paddle_left_ice_effect"))
    is_right_on_ice = bool(get_key(game_id, "paddle_right_ice_effect"))
    has_left_speed_boost = bool(get_key(game_id, "paddle_left_speed_boost"))
    has_right_speed_boost = bool(get_key(game_id, "paddle_right_speed_boost"))

    # 2) Appliquer la hauteur
    paddle_left.height = new_left_height
    paddle_right.height = new_right_height

    # 3) Calculer la direction effective
    #    si invert => inverser le signe
    if is_left_inverted:
        left_vel = -left_vel
    if is_right_inverted:
        right_vel = -right_vel

    #    si speed_boost => multiplier la vitesse
    if has_left_speed_boost:
        left_vel *= 1.5
    if has_right_speed_boost:
        right_vel *= 1.5

    # 4) Déduire direction ou laisser en “velocity”
    #    si on préfère la “direction” => -1,0,+1
    #    ou rester en “velocity” direct
    #    Dans le Paddle, on a la logique : if is_on_ice => friction etc.
    direction_left = 0
    if left_vel > 0: direction_left = 1
    elif left_vel < 0: direction_left = -1

    direction_right = 0
    if right_vel > 0: direction_right = 1
    elif right_vel < 0: direction_right = -1

    # 5) Appeler la méthode move(...) de la classe Paddle
    terrain_top = 50
    terrain_bottom = 350

    # On peut éventuellement passer “speed_boost” dans la signature.
    # Ou, comme ci-dessous, vous appliquez la friction/glace directement dedans.
    paddle_left.move(direction_left, is_left_on_ice, terrain_top, terrain_bottom, speed_boost=has_left_speed_boost)
    paddle_right.move(direction_right, is_right_on_ice, terrain_top, terrain_bottom, speed_boost=has_right_speed_boost)

    # 6) Sauvegarder la position finale dans Redis
    set_key(game_id, "paddle_left_y", paddle_left.y)
    set_key(game_id, "paddle_right_y", paddle_right.y)
    # Ici, on peut aussi sauvegarder la velocity si on veut la persister.

# -------------- PADDLES : UPDATE REDIS--------------------
# def update_paddles_redis(game_id, paddle_left, paddle_right):
#     """Updates paddle positions considering active effects."""
#     left_vel = float(get_key(game_id, f"paddle_left_velocity") or 0)
#     right_vel = float(get_key(game_id, f"paddle_right_velocity") or 0)

#     # Apply speed boost if active
#     if get_key(game_id, f"paddle_left_speed_boost"):
#         left_vel *= 1.5  # 50% speed increase
#     if get_key(game_id, f"paddle_right_speed_boost"):
#         right_vel *= 1.5  # 50% speed increase

#     # Convert velocity to direction
#     left_direction = 0 if left_vel == 0 else (1 if left_vel > 0 else -1)
#     right_direction = 0 if right_vel == 0 else (1 if right_vel > 0 else -1)

#     # Apply inverted controls first
#     if get_key(game_id, f"paddle_left_inverted"):
#         left_direction *= -1
#         left_vel *= -1
#     if get_key(game_id, f"paddle_right_inverted"):
#         right_direction *= -1
#         right_vel *= -1

#     # Check ice effects
#     left_on_ice = bool(get_key(game_id, f"paddle_left_ice_effect"))
#     right_on_ice = bool(get_key(game_id, f"paddle_right_ice_effect"))

#     # Get current paddle heights from Redis
#     left_height = float(get_key(game_id, f"paddle_left_height") or paddle_left.height)
#     right_height = float(get_key(game_id, f"paddle_right_height") or paddle_right.height)

#     # Define boundaries
#     TOP_BOUNDARY = 50
#     BOTTOM_BOUNDARY = 350  # This is the bottom border of the play area

#     # Move paddles with ice physics if active, otherwise normal movement
#     if left_on_ice:
#         paddle_left.move(left_direction, left_on_ice, TOP_BOUNDARY, BOTTOM_BOUNDARY)
#     else:
#         # Update position
#         paddle_left.y += left_vel
#         # Constrain movement using current height
#         # Bottom boundary is the maximum y position where the paddle can be placed
#         paddle_left.y = max(TOP_BOUNDARY, min(BOTTOM_BOUNDARY - left_height, paddle_left.y))

#     if right_on_ice:
#         paddle_right.move(right_direction, right_on_ice, TOP_BOUNDARY, BOTTOM_BOUNDARY)
#     else:
#         # Update position
#         paddle_right.y += right_vel
#         # Constrain movement using current height
#         paddle_right.y = max(TOP_BOUNDARY, min(BOTTOM_BOUNDARY - right_height, paddle_right.y))
#     set_key(game_id, f"paddle_left_y", paddle_left.y)
#     set_key(game_id, f"paddle_right_y", paddle_right.y)import time
from .dimensions_utils import get_terrain_rect
from .redis_utils import set_key, get_key, delete_key
from .broadcast import notify_powerup_applied, notify_powerup_spawned, notify_powerup_expired
import asyncio
import math
import random

MAX_ACTIVE_POWERUPS = 2
SPAWN_INTERVAL_POWERUPS = 7
DURATION_EFFECT_POWERUPS = 5

# -------------- POWER UP --------------------
async def handle_powerups_spawn(game_id, powerup_orbs, current_time):
    # Initialisation de last_powerup_spawn_time si elle n'est pas déjà définie
    if not hasattr(handle_powerups_spawn, "last_powerup_spawn_time"):
        handle_powerups_spawn.last_powerup_spawn_time = current_time  # Initialisation lors du premier appel

    # Utilisation de la variable statique pour vérifier l'intervalle de temps
    if current_time - handle_powerups_spawn.last_powerup_spawn_time >= SPAWN_INTERVAL_POWERUPS:
        active_powerups = count_active_powerups(game_id, powerup_orbs)
        if active_powerups < MAX_ACTIVE_POWERUPS:
            # S'assurer qu'on ne génère qu'un seul powerup à la fois
            powerup_orb = random.choice(powerup_orbs)
            if not powerup_orb.active:
                terrain = get_terrain_rect(game_id)
                spawned = await spawn_powerup(game_id, powerup_orb, terrain)
                if spawned:
                    # Mettre à jour le temps de spawn du powerup pour éviter les doubles spawns
                    handle_powerups_spawn.last_powerup_spawn_time = current_time
                    print(f"[game_loop.py] game_id={game_id} - PowerUp {powerup_orb.effect_type} spawned.")



async def spawn_powerup(game_id, powerup_orb, terrain_rect):
    # Ne pas faire spawn 2 fois le même powerup sur le terrain
    if powerup_orb.active:
        print(f"[powerups.py] PowerUp {powerup_orb.effect_type} is already active, skipping spawn.")
        return False

    if (powerup_orb.spawn)(terrain_rect):
        set_powerup_redis(game_id, powerup_orb)
        print(f"[powerups.py] PowerUp {powerup_orb.effect_type} spawned at ({powerup_orb.x}, {powerup_orb.y})")
        await notify_powerup_spawned(game_id, powerup_orb)
        return True
    return False



async def apply_powerup(game_id, player, powerup_orb):
    print(f"[powerups.py] Applying power-up {powerup_orb.effect_type} to {player}")
    # Create task for handling effect duration
    asyncio.create_task(handle_powerup_duration(game_id, player, powerup_orb))
    print(f"[game_loop.py] Creating duration task for {powerup_orb.effect_type}")
    delete_powerup_redis(game_id, powerup_orb)
    await notify_powerup_applied(game_id, player, powerup_orb.effect_type, DURATION_EFFECT_POWERUPS)


async def handle_powerup_duration(game_id, player, powerup_orb): 
    """Handles the duration of a power-up effect asynchronously."""
    effect_type = powerup_orb.effect_type
    effect_duration = 5  # 5 seconds for all effects

    print(f"[game_loop.py] Starting effect {effect_type} for {player}")

    # Apply effect
    #IMPROVE => utiliser shown_size de paddle pour original_height
    

    print("handle_powerup_duration")
    if effect_type == 'flash':
        set_key(game_id, f"flash_effect", 1)
        await asyncio.sleep(0.3) # Flash lasts 300ms
        delete_key(game_id, f"flash_effect")

    elif effect_type == 'shrink':
        opponent = 'left' if player == 'right' else 'right'
        print(f"[game_loop.py] Applying shrink to {opponent}")  # Debug log
        
        # Get current height and store it as original
        current_height = float(get_key(game_id, f"paddle_{opponent}_height") or 60)
        print(f"[game_loop.py] Original height: {current_height}")  # Debug log
        
        # Store original height for restoration
        set_key(game_id, f"paddle_{opponent}_original_height", current_height)
        
        # Calculate and set new height
        new_height = current_height * 0.5
        set_key(game_id, f"paddle_{opponent}_height", new_height)
        print(f"[game_loop.py] New height set to: {new_height}")  # Debug log
        
        # Wait for duration
        await asyncio.sleep(effect_duration)
    
        # Restore original height
        original_height = float(get_key(game_id, f"paddle_{opponent}_original_height") or 60)
        set_key(game_id, f"paddle_{opponent}_height", original_height)
        delete_key(game_id, f"paddle_{opponent}_original_height")
        print(f"[game_loop.py] Height restored to: {original_height}")  # Debug log

    elif effect_type == 'speed':
        # Set paddle speed multiplier
        set_key(game_id, f"paddle_{player}_speed_boost", 1)  # Flag for speed boost
        print(f"[game_loop.py] Speed boost applied to {player} paddle")
        
        await asyncio.sleep(effect_duration)
        
        # Remove speed boost
        delete_key(game_id, f"paddle_{player}_speed_boost")
        print(f"[game_loop.py] Speed boost removed from {player} paddle")

    elif effect_type == 'ice':
        opponent = 'left' if player == 'right' else 'right'
        set_key(game_id, f"paddle_{opponent}_ice_effect", 1)
        await asyncio.sleep(effect_duration)
        delete_key(game_id, f"paddle_{opponent}_ice_effect")

    elif effect_type == 'sticky':
        set_key(game_id, f"paddle_{player}_sticky", 1)
        await asyncio.sleep(effect_duration)
        delete_key(game_id, f"paddle_{player}_sticky")

    elif effect_type == 'invert':
        opponent = 'left' if player == 'right' else 'right'
        set_key(game_id, f"paddle_{opponent}_inverted", 1)
        await asyncio.sleep(effect_duration)
        delete_key(game_id, f"paddle_{opponent}_inverted")
    print("END handle_powerup_duration")





def count_active_powerups(game_id, powerup_orbs):
    count = 0
    for powerup_orb in powerup_orbs:
        active = get_key(game_id, f"powerup_{powerup_orb.effect_type}_active") or 0
        if active and active.decode('utf-8') == '1':
            count += 1
    # print(f"[loop.py] count_active_powerups ({count})")
    return count

async def handle_powerup_expiration(game_id, powerup_orbs):
    current_time = time.time()
    for powerup_orb in powerup_orbs:
        if powerup_orb.active and current_time - powerup_orb.spawn_time >= powerup_orb.duration:
            delete_powerup_redis(game_id, powerup_orb)
            print(f"[game_loop.py] PowerUp {powerup_orb.effect_type} expired at ({powerup_orb.x}, {powerup_orb.y})")
            await notify_powerup_expired(game_id, powerup_orb)


# -------------- POWER UP : UPDATE REDIS DATA --------------------
def set_powerup_redis(game_id, powerup_orb):
    powerup_orb.activate()
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_active", 1)
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_x", powerup_orb.x)
    set_key(game_id, f"powerup_{powerup_orb.effect_type}_y", powerup_orb.y)

def delete_powerup_redis(game_id, powerup_orb):
    powerup_orb.deactivate()
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_active")
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_x")
    delete_key(game_id, f"powerup_{powerup_orb.effect_type}_y")
# game/game_loop/redis_utils.py

import redis
from django.conf import settings

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

def set_key(game_id, key, value):
    r.set(f"{game_id}:{key}", value)

def get_key(game_id, key):
    return r.get(f"{game_id}:{key}")

def delete_key(game_id, key):
    r.delete(f"{game_id}:{key}")

def scan_and_delete_keys(game_id):
    keys = list(r.scan_iter(f"{game_id}:*"))
    for key in keys:
        r.delete(key)

# game/game_loop/score_utils.py

from channels.layers import get_channel_layer
from asgiref.sync import sync_to_async
from .broadcast import notify_game_finished, notify_powerup_expired, notify_bumper_expired
from .redis_utils import set_key, get_key, scan_and_delete_keys, delete_key
from .models_utils import is_online_gameSession, set_gameSession_status, create_gameResults, get_LocalTournament

from .powerups_utils import handle_powerups_spawn, delete_powerup_redis
from .bumpers_utils import handle_bumpers_spawn, delete_bumper_redis
# transformer en parametre ajustable GameParameters?
WIN_SCORE = 6 


async def reset_all_objects(game_id, powerup_orbs, bumpers): # / added
    """Reset all active powerups and bumpers when a point is scored."""
    # Reset all powerups
    for powerup in powerup_orbs:
        if powerup.active:
            delete_powerup_redis(game_id, powerup)
            powerup.deactivate()
            await notify_powerup_expired(game_id, powerup)

    # Reset all bumpers
    for bumper in bumpers:
        if bumper.active:
            delete_bumper_redis(game_id, bumper)
            bumper.deactivate()
            await notify_bumper_expired(game_id, bumper)

    # Reset any active effects
    keys_to_delete = [
        "paddle_left_sticky", "paddle_right_sticky",
        "paddle_left_inverted", "paddle_right_inverted",
        "paddle_left_ice_effect", "paddle_right_ice_effect",
        "paddle_left_speed_boost", "paddle_right_speed_boost",
        "flash_effect"
    ]
    for key in keys_to_delete:
        delete_key(game_id, key)

    # Reset paddle heights to initial values
    initial_height = float(get_key(game_id, "initial_paddle_height"))
    set_key(game_id, "paddle_left_height", initial_height)
    set_key(game_id, "paddle_right_height", initial_height)


def handle_score(game_id, scorer):
    if scorer == 'score_left':
        score_left = int(get_key(game_id, "score_left") or 0) + 1
        set_key(game_id, "score_left", score_left)
        print(f"[loop.py] Player Left scored. Score: {score_left} - {get_key(game_id, 'score_right')}")            

    else :
        score_right = int(get_key(game_id, "score_right") or 0) + 1
        set_key(game_id, "score_right", score_right)
        print(f"[loop.py] Player Right scored. Score: {get_key(game_id, 'score_left')} - {score_right}")



def winner_detected(game_id):

    score_left = int(get_key(game_id, "score_left") or 0)
    score_right = int(get_key(game_id, "score_right") or 0)

    if (score_left == WIN_SCORE or score_right == WIN_SCORE):
        return True
    return False

async def finish_game(game_id):
    # Récupérer les scores depuis Redis
    score_left = int(get_key(game_id, "score_left") or 0)
    score_right = int(get_key(game_id, "score_right") or 0)

    # Marquer la session comme terminée et récupérer ses informations
    gameSession = await set_gameSession_status(game_id, "finished")
    if not gameSession:
        print(f"[finish_game] GameSession {game_id} does not exist.")
        return

    # Pour être sûr que les attributs player_left et player_right sont préchargés,
    # vérifiez qu'ils ne déclenchent pas de requête additionnelle.
    # Ici, ils ont été chargés grâce au select_related dans set_gameSession_status.

    # Si la GameSession est Online, créer un enregistrement des gameResults
    if score_left > score_right:
        winner = gameSession.player_left
        winner_local = gameSession.player_left_local
        looser = gameSession.player_right
        looser_local = gameSession.player_right_local
    else:
        winner = gameSession.player_right
        winner_local  = gameSession.player_right_local
        looser = gameSession.player_left
        looser_local = gameSession.player_left_local

    endgame_infos = {
        'winner': winner,
        'looser': looser,
        'winner_local': winner_local,
        'looser_local': looser_local,
        'score_left': score_left,
        'score_right': score_right,
    }
    gameSession_isOnline = await is_online_gameSession(game_id)
    await create_gameResults(game_id, gameSession_isOnline, endgame_infos)

    # Gestion du tournoi (inchangé)
    tournament = await get_LocalTournament(game_id, "semifinal1")
    if tournament:
        print(f"[finish_game] this game was semifinal1 from tournament game_id={game_id}")
        tournament.status = 'semifinal1_done'
        tournament.winner_semifinal_1 = winner_local
        await sync_to_async(tournament.save)()
    else:
        tournament = await get_LocalTournament(game_id, "semifinal2")
        if tournament:
            tournament.status = 'semifinal2_done'
            tournament.winner_semifinal_2 = winner_local
            await sync_to_async(tournament.save)()
        else:
            tournament = await get_LocalTournament(game_id, "final")
            if tournament:
                tournament.status = 'finished'
                tournament.winner_final = winner_local
                await sync_to_async(tournament.save)()
            else:
                print(f"[finish_game] No tournament found for game_id={game_id}")

    tournament_id = gameSession.tournament_id
    print(f"[finish_game] tournament_id={tournament_id}")
    if gameSession_isOnline:
        await notify_game_finished(game_id, tournament_id, winner, looser)
    else :
        await notify_game_finished(game_id, tournament_id, winner_local, looser_local)

    scan_and_delete_keys(game_id)
    print(f"[loop.py] Redis keys deleted for game_id={game_id}")
