<!DOCTYPE html>
<html>
<head>
  <title>Game</title>
  <style>
    #gameCanvas {
      background: black;
      border: 2px solid white;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <h1>Pong Game - ID : {{ game_id }}</h1>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <script>
    const gameId = "{{ game_id }}";
    const protocol = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
    const wsUrl = protocol + '//' + window.location.host + '/ws/pong/' + gameId + '/';
    const socket = new WebSocket(wsUrl);
  
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
  
    let gameState = {
      ball_x: 400, ball_y: 200,
      ball_radius: 7,
      ball_speed_x: 4,
      ball_speed_y: 4,
      paddle_left_y: 170,
      paddle_right_y: 170,
      paddle_width: 10,
      paddle_left_height: 60,
      paddle_right_height: 60,
      score_left: 0, score_right: 0,
      powerups: [],
      bumpers: [],
      player_effects: {
        left: {
          inverted_controls: false,
          shrink_paddle: null,
          ice_physics: false,
          speed_boost: null,
          sticky_ball: false
        },
        right: {
          inverted_controls: false,
          shrink_paddle: null,
          ice_physics: false,
          speed_boost: null,
          sticky_ball: false
        }
      },
      flash_effect: false
    };
  
    socket.onopen = () => {
      console.log("[Frontend] WebSocket connection opened.");
    };
  
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log("[Frontend] Received data:", data);
      if (data.type === 'game_state') {
        gameState = data;
      } else if (data.type === 'game_over') {
        alert("Game Over! Winner = " + data.winner);
        socket.close();
      }
    };
  
    socket.onclose = () => {
      console.log("[Frontend] WebSocket connection closed.");
    };
  
    document.addEventListener('keydown', (evt) => {
      let action = null, player=null, direction=null;
      if(evt.key === 'w' || evt.key === 'W'){
        player='left'; direction='up';
      } else if(evt.key === 's' || evt.key === 'S'){
        player='left'; direction='down';
      } else if(evt.key === 'ArrowUp'){
        player='right'; direction='up';
      } else if(evt.key === 'ArrowDown'){
        player='right'; direction='down';
      }
      if(player && direction){
        socket.send(JSON.stringify({
          action: 'move',
          player,
          direction
        }));
        console.log(`[Frontend] Sent move: player=${player}, direction=${direction}`);
      }
    });
  
    function draw(){
      if (gameState.flash_effect) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw terrain
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
        
        // Draw paddles
        ctx.fillStyle = 'white';
        ctx.fillRect(50, gameState.paddle_left_y, gameState.paddle_width, gameState.paddle_left_height);
        ctx.fillRect(canvas.width - 50 - gameState.paddle_width, gameState.paddle_right_y, gameState.paddle_width, gameState.paddle_right_height);
        
        // Draw ball
        ctx.beginPath();
        ctx.arc(gameState.ball_x, gameState.ball_y, gameState.ball_radius, 0, 2*Math.PI);
        ctx.fill();
        
        // Draw power-ups
        gameState.powerups.forEach(orb => {
          ctx.fillStyle = `rgb(${orb.color[0]}, ${orb.color[1]}, ${orb.color[2]})`;
          ctx.beginPath();
          ctx.arc(orb.x, orb.y, 15, 0, 2*Math.PI);
          ctx.fill();
        });
        
        // Draw bumpers
        gameState.bumpers.forEach(bumper => {
          ctx.fillStyle = `rgb(${bumper.color[0]}, ${bumper.color[1]}, ${bumper.color[2]})`;
          ctx.beginPath();
          ctx.arc(bumper.x, bumper.y, bumper.radius, 0, 2*Math.PI);
          ctx.fill();
        });
      }
  
      // Affichage des scores
      ctx.fillStyle='white';
      ctx.font="20px Arial";
      ctx.fillText(`${gameState.score_left}`, 20, 30);
      ctx.fillText(`${gameState.score_right}`, canvas.width-40, 30);
  
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  </script>
</body>
</html>
