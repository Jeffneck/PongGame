# game/admin.py

from django.contrib import admin
from .models import GameSession, GameResult, GameParameters, GameInvitation

@admin.register(GameSession)
class GameSessionAdmin(admin.ModelAdmin):
    list_display = ('id', 'player_left', 'player_right', 'status', 'created_at')

@admin.register(GameResult)
class GameResultAdmin(admin.ModelAdmin):
    list_display = ('game', 'winner', 'score_left', 'score_right', 'ended_at')

@admin.register(GameParameters)
class GameParametersAdmin(admin.ModelAdmin):
    list_display = ('game_session', 'ball_speed', 'racket_size', 'bonus_malus_activation', 'bumpers_activation')

@admin.register(GameInvitation)
class GameInvitationAdmin(admin.ModelAdmin):
    list_display = ('from_user', 'to_user', 'status', 'created_at')
from django.apps import AppConfig


class GameConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'game'
# game/consumers.py

import json
import redis
from django.conf import settings
from channels.generic.websocket import AsyncWebsocketConsumer

r = redis.Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=0
)

class PongConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.game_id = self.scope['url_route']['kwargs']['game_id']
        self.group_name = f"pong_{self.game_id}"

        await self.accept()
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket connected for game_id={self.game_id}")

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)
        print(f"[PongConsumer] WebSocket disconnected for game_id={self.game_id}")

    async def receive(self, text_data=None, bytes_data=None):
        """
        Nouveau protocole:
        {
          "action": "start_move",
          "player": "left",
          "direction": "up"
        }
        ou
        {
          "action": "stop_move",
          "player": "left"
        }
        """
        data = json.loads(text_data)
        action = data.get('action')
        player = data.get('player')

        if action == 'start_move':
            # Le joueur commence à bouger le paddle
            direction = data.get('direction')  # 'up' ou 'down'
            await self.start_move_paddle(player, direction)

        elif action == 'stop_move':
            # Le joueur arrête de bouger le paddle
            await self.stop_move_paddle(player)

    async def start_move_paddle(self, player, direction):
        """
        Met une vélocité non nulle dans Redis tant que la touche est enfoncée.
        """
        velocity = 0
        if direction == 'up':
            velocity = -8  # Ajustez la vitesse selon vos préférences
        elif direction == 'down':
            velocity = 8

        r.set(f"{self.game_id}:paddle_{player}_velocity", velocity)
        print(f"[PongConsumer] start_move_paddle: player={player}, velocity={velocity}")

    async def stop_move_paddle(self, player):
        """
        Remet la vélocité à 0 quand la touche est relâchée.
        """
        r.set(f"{self.game_id}:paddle_{player}_velocity", 0)
        print(f"[PongConsumer] stop_move_paddle: player={player}")

    async def broadcast_game_state(self, event):
        """
        Reçoit { 'type': 'broadcast_game_state', 'data': { ... } }
        et envoie data au client.
        """
        await self.send(json.dumps(event['data']))
        # print(f"[PongConsumer] Broadcast game_state to game_id={self.game_id}")

    async def game_over(self, event):
        """
        Reçoit { 'type': 'game_over', 'winner': 'left' } par ex.
        """
        await self.send(json.dumps({
            'type': 'game_over',
            'winner': event['winner']
        }))
        print(f"[PongConsumer] Broadcast game_over to game_id={self.game_id}, winner={event['winner']}")
# game/forms.py

from django import forms
from .models import GameParameters

class GameParametersForm(forms.ModelForm):
    class Meta:
        model = GameParameters
        fields = ['ball_speed', 'racket_size', 'bonus_malus_activation', 'bumpers_activation']
        widgets = {
            'ball_speed': forms.Select(attrs={'class': 'form-control'}),
            'racket_size': forms.Select(attrs={'class': 'form-control'}),
            'bonus_malus_activation': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            'bumpers_activation': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
        }
        labels = {
            'ball_speed': 'Vitesse de la balle',
            'racket_size': 'Taille de la raquette',
            'bonus_malus_activation': 'Activer les bonus/malus',
            'bumpers_activation': 'Activer les bumpers/obstacles',
        }
# game/game_loop.py

import redis
import asyncio
from django.conf import settings
from channels.layers import get_channel_layer
from .models import GameSession, GameResult, GameParameters
from .game_objects import Paddle, Ball, PowerUpOrb, Bumper
from asgiref.sync import sync_to_async
import math
import random
import time

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

FIELD_WIDTH = 800
FIELD_HEIGHT = 400
WIN_SCORE = 4

# collision avec les bumpers
COOLDOWN_TIME = 0.5  # Temps en secondes

# Initialize paddles and ball
async def initialize_game_objects(game_id, parameters):
    paddle_size = {1: 30, 2: 60, 3: 90}[parameters.racket_size]
    paddle_speed = 6  # Can be made adjustable if needed
    ball_speed_multiplier = parameters.ball_speed

    # Obtenir les dimensions du terrain
    terrain_rect = await get_terrain_rect(game_id)

    # Initialize paddles
    paddle_left = Paddle('left', paddle_size, paddle_speed)
    paddle_right = Paddle('right', paddle_size, paddle_speed)

    # Initialize ball
    initial_ball_speed_x = 4 * ball_speed_multiplier
    initial_ball_speed_y = 4 * ball_speed_multiplier
    ball = Ball(
        terrain_rect['left'] + terrain_rect['width'] // 2,
        terrain_rect['top'] + terrain_rect['height'] // 2,
        initial_ball_speed_x,
        initial_ball_speed_y
    )

    # Initialize power-ups and bumpers
    power_up_orbs = [
        PowerUpOrb(game_id, 'invert', terrain_rect, color=(255, 105, 180)),  # Pink for invert
        PowerUpOrb(game_id, 'shrink', terrain_rect, color=(255, 0, 0)),      # Red for shrink
        PowerUpOrb(game_id, 'ice', terrain_rect, color=(0, 255, 255)),       # Cyan for ice
        PowerUpOrb(game_id, 'speed', terrain_rect, color=(255, 215, 0)),     # Gold for speed
        PowerUpOrb(game_id, 'flash', terrain_rect, color=(255, 255, 0)),     # Yellow for flash
        PowerUpOrb(game_id, 'sticky', terrain_rect, color=(50, 205, 50))     # Lime green for sticky
    ]

    bumpers = []
    if parameters.bumpers_activation:
        bumpers = [Bumper(game_id, terrain_rect) for _ in range(3)]  # Adjust number as needed

    return paddle_left, paddle_right, ball, power_up_orbs, bumpers

async def get_terrain_rect(game_id):
    """
    Retourne les dimensions du terrain. Peut être ajusté pour récupérer les dimensions dynamiquement.
    """
    return {
        'left': 50,
        'top': 50,
        'width': 700,
        'height': 300
    }

async def game_loop(game_id):
    """
    Boucle principale pour UNE partie identifiée par game_id.
    Tourne ~60 fois/s tant que la partie est "running".
    """
    channel_layer = get_channel_layer()
    dt = 1/60
    print(f"[game_loop.py] Starting loop for game_id={game_id}.")

    try:
        # Récupérer les paramètres du jeu
        parameters = await get_game_parameters(game_id)
        if not parameters:
            print(f"[game_loop.py] No parameters found for game_id={game_id}. Using defaults.")
            parameters = await sync_to_async(GameParameters.objects.create)(
                game_session=await sync_to_async(GameSession.objects.get)(pk=game_id)
            )
        
        # Initialiser les objets de jeu
        paddle_left, paddle_right, ball, power_up_orbs, bumpers = await initialize_game_objects(game_id, parameters)
        print(f"[game_loop.py] Game objects initialized for game_id={game_id}.")
        
        # Initialiser les positions et vélocités dans Redis
        await initialize_redis(game_id, paddle_left, paddle_right, ball, power_up_orbs, bumpers)
        print(f"[game_loop.py] Game objects positions initialized in Redis for game_id={game_id}.")
        
        last_powerup_spawn_time = time.time()
        powerup_spawn_interval = 10  # Adjust as needed

        last_bumper_spawn_time = time.time()
        bumper_spawn_interval = 15  # Adjust as needed

        while True:
            current_time = time.time()
            # print(f"[game_loop.py] game_id={game_id} - Loop iteration at {current_time}")

            # Vérifier si la partie est encore "running"
            session_status = await get_game_status(game_id)
            # print(f"[game_loop.py] game_id={game_id} - Session status: {session_status}")
            if session_status != 'running':
                print(f"[game_loop.py] game_id={game_id} is not running (status={session_status}), breaking loop.")
                break

            # 1. Mettre à jour les positions des raquettes depuis Redis en fonction de la vélocité
            await update_paddles_from_redis(game_id, paddle_left, paddle_right)
            # print(f"[game_loop.py] game_id={game_id} - Paddles positions updated from Redis.")

            # 2. Mettre à jour la position de la balle
            ball.move()
            await update_ball_redis(game_id, ball)
            # print(f"[game_loop.py] game_id={game_id} - Ball position updated to ({ball.x}, {ball.y})")

            # 3. Vérifier les collisions
            collision = await check_collisions(game_id, paddle_left, paddle_right, ball, bumpers, power_up_orbs)
            if collision in ['score_left', 'score_right']:
                await handle_score(game_id, collision)
                # print(f"[game_loop.py] game_id={game_id} - Handling score for {collision}")
                
                # Vérifier si quelqu'un a gagné
                score_left = int(r.get(f"{game_id}:score_left") or 0)
                score_right = int(r.get(f"{game_id}:score_right") or 0)
                if score_left >= WIN_SCORE or score_right >= WIN_SCORE:
                    # On arrête la boucle si la partie est terminée
                    break
                else:
                    # Personne n'a encore gagné,
                    # on réinitialise la balle pour continuer la partie
                    terrain_rect = await get_terrain_rect(game_id)
                    center_x = terrain_rect['left'] + terrain_rect['width'] // 2
                    center_y = terrain_rect['top'] + terrain_rect['height'] // 2
                    ball.reset(center_x, center_y, 4, 4)  # Vitesse X/Y à ajuster
                    await update_ball_redis(game_id, ball)
                    print(f"[game_loop.py] Ball reset to ({ball.x}, {ball.y}) with speed ({ball.speed_x}, {ball.speed_y})")

            # 4. Gérer les power-ups
            if parameters.bonus_malus_activation:
                if current_time - last_powerup_spawn_time >= powerup_spawn_interval:
                    # Tenter de spawn un power-up
                    active_powerups = await count_active_powerups(game_id, power_up_orbs)
                    # print(f"[game_loop.py] game_id={game_id} - Active power-ups: {active_powerups}")
                    if active_powerups < 2:  # MAX_ACTIVE_POWERUPS = 2
                        orb = random.choice(power_up_orbs)
                        if not orb.active:
                            spawned = await spawn_powerup(game_id, orb)
                            if spawned:
                                last_powerup_spawn_time = current_time
                                print(f"[game_loop.py] game_id={game_id} - PowerUp {orb.effect_type} spawned.")

            # 5. Gérer les bumpers
            if parameters.bumpers_activation:
                if current_time - last_bumper_spawn_time >= bumper_spawn_interval:
                    # Tenter de spawn un bumper
                    active_bumpers = await count_active_bumpers(game_id, bumpers)
                    # print(f"[game_loop.py] game_id={game_id} - Active bumpers: {active_bumpers}")
                    if active_bumpers < 2:  # MAX_BUMPERS = 2
                        bumper = random.choice(bumpers)
                        if not bumper.active:
                            spawned = await spawn_bumper(game_id, bumper)
                            if spawned:
                                last_bumper_spawn_time = current_time
                                print(f"[game_loop.py] game_id={game_id} - Bumper spawned at ({bumper.x}, {bumper.y}).")

            # 6. Gérer les power-ups expirés
            await handle_powerup_expiration(game_id, power_up_orbs)
            # print(f"[game_loop.py] game_id={game_id} - Handled power-up expiration.")

            # 7. Gérer les bumpers expirés
            await handle_bumper_expiration(game_id, bumpers)
            # print(f"[game_loop.py] game_id={game_id} - Handled bumper expiration.")

            # 8. Broadcast l'état actuel du jeu
            await broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, power_up_orbs, bumpers)
            # print(f"[game_loop.py] game_id={game_id} - Broadcasted game state.")

            # Attendre le prochain cycle
            await asyncio.sleep(dt)
    
    except Exception as e:
        print(f"[game_loop.py] game_id={game_id} encountered an exception: {e}")
    
    finally:
        print(f"[game_loop.py] game_id={game_id} loop ended.")

async def update_paddles_from_redis(game_id, paddle_left, paddle_right):
    """
    Lit la vélocité dans Redis et met à jour la position (y) des paddles.
    """
    left_vel = float(r.get(f"{game_id}:paddle_left_velocity") or 0)
    right_vel = float(r.get(f"{game_id}:paddle_right_velocity") or 0)

    # Appliquer la vélocité
    paddle_left.y += left_vel
    paddle_right.y += right_vel

    # Contraindre le mouvement dans [50, 350 - paddle.height]
    paddle_left.y = max(50, min(350 - paddle_left.height, paddle_left.y))
    paddle_right.y = max(50, min(350 - paddle_right.height, paddle_right.y))

    # Stocker la position mise à jour
    r.set(f"{game_id}:paddle_left_y", paddle_left.y)
    r.set(f"{game_id}:paddle_right_y", paddle_right.y)

async def get_game_status(game_id):
    """
    Récupère le statut de la partie depuis la base de données.
    """
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        return session.status
    except GameSession.DoesNotExist:
        return 'finished'

async def get_game_parameters(game_id):
    """
    Récupère les paramètres (GameParameters) de la partie depuis la base de données.
    """
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        parameters = await sync_to_async(getattr)(session, 'parameters', None)
        return parameters
    except GameSession.DoesNotExist:
        return None

async def initialize_redis(game_id, paddle_left, paddle_right, ball, power_up_orbs, bumpers):
    """
    Initialise les positions et vitesses dans Redis pour chaque objet.
    """
    # Positions initiales des paddles
    r.set(f"{game_id}:paddle_left_y", paddle_left.y)
    r.set(f"{game_id}:paddle_right_y", paddle_right.y)

    # Vélocités initiales des paddles (0 => immobiles)
    r.set(f"{game_id}:paddle_left_velocity", 0)
    r.set(f"{game_id}:paddle_right_velocity", 0)

    # Balle
    r.set(f"{game_id}:ball_x", ball.x)
    r.set(f"{game_id}:ball_y", ball.y)
    r.set(f"{game_id}:ball_vx", ball.speed_x)
    r.set(f"{game_id}:ball_vy", ball.speed_y)

    # Power-ups
    for orb in power_up_orbs:
        r.delete(f"{game_id}:powerup_{orb.effect_type}_active")
        r.delete(f"{game_id}:powerup_{orb.effect_type}_x")
        r.delete(f"{game_id}:powerup_{orb.effect_type}_y")

    # Bumpers
    for bumper in bumpers:
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_active")
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_x")
        r.delete(f"{game_id}:bumper_{bumper.x}_{bumper.y}_y")

async def update_ball_redis(game_id, ball):
    """
    Met à jour la position de la balle dans Redis.
    """
    r.set(f"{game_id}:ball_x", ball.x)
    r.set(f"{game_id}:ball_y", ball.y)
    r.set(f"{game_id}:ball_vx", ball.speed_x)
    r.set(f"{game_id}:ball_vy", ball.speed_y)

async def check_collisions(game_id, paddle_left, paddle_right, ball, bumpers, power_up_orbs):
    """
    Vérifie collisions ball/paddles/bumpers/bords, retourne 'score_left', 'score_right' ou None.
    """
    # Left paddle
    if ball.x - ball.size <= paddle_left.x + paddle_left.width:
        if paddle_left.y <= ball.y <= paddle_left.y + paddle_left.height:
            await handle_paddle_collision(game_id, 'left', paddle_left, ball)
            await check_powerup_collection(game_id, 'left', ball, power_up_orbs)
            return None
        else:
            return 'score_right'

    # Right paddle
    if ball.x + ball.size >= paddle_right.x:
        if paddle_right.y <= ball.y <= paddle_right.y + paddle_right.height:
            await handle_paddle_collision(game_id, 'right', paddle_right, ball)
            await check_powerup_collection(game_id, 'right', ball, power_up_orbs)
            return None
        else:
            return 'score_left'

    # Bords haut/bas
    if ball.y - ball.size <= 50:
        ball.speed_y = abs(ball.speed_y)  # Rebond vers le bas
    elif ball.y + ball.size >= 350:
        ball.speed_y = -abs(ball.speed_y)  # Rebond vers le haut

    # Bumpers
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active:
            dist = math.hypot(ball.x - bumper.x, ball.y - bumper.y)
            if dist <= ball.size + bumper.size:
                if current_time - bumper.last_collision_time >= COOLDOWN_TIME:
                    angle = math.atan2(ball.y - bumper.y, ball.x - bumper.x)
                    speed = math.hypot(ball.speed_x, ball.speed_y) * 1.05
                    ball.speed_x = speed * math.cos(angle)
                    ball.speed_y = speed * math.sin(angle)

                    # Mettre à jour la balle dans Redis
                    await update_ball_redis(game_id, ball)

                    # Mettre à jour le temps de la dernière collision
                    bumper.last_collision_time = current_time

                    print(f"[game_loop.py] Ball collided with bumper at ({bumper.x}, {bumper.y}). New speed: ({ball.speed_x}, {ball.speed_y})")
    
    return None

async def handle_paddle_collision(game_id, paddle_side, paddle, ball):
    """
    Gère la logique de collision entre la balle et une raquette.
    """
    relative_y = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2)
    relative_y = max(-1, min(1, relative_y))  # Limiter à l'intervalle [-1, 1]

    angle = relative_y * (math.pi / 4)  # Max 45 degrés
    speed = math.hypot(ball.speed_x, ball.speed_y) * 1.03  # Augmenter la vitesse

    if paddle_side == 'left':
        ball.speed_x = speed * math.cos(angle)
    else:
        ball.speed_x = -speed * math.cos(angle)

    ball.speed_y = speed * math.sin(angle)

    # Mettre à jour la balle dans Redis
    await update_ball_redis(game_id, ball)

    print(f"[game_loop.py] Ball collided with {paddle_side} paddle. New speed: ({ball.speed_x}, {ball.speed_y})")

async def check_powerup_collection(game_id, player, ball, power_up_orbs):
    """
    Vérifie si la balle a ramassé un power-up.
    """
    for orb in power_up_orbs:
        if orb.active:
            dist = math.hypot(ball.x - orb.x, ball.y - orb.y)
            if dist <= ball.size + orb.size:
                await apply_powerup(game_id, player, orb)
                orb.deactivate()
                r.set(f"{game_id}:powerup_{orb.effect_type}_active", 0)
                print(f"[game_loop.py] Player {player} collected power-up {orb.effect_type} at ({orb.x}, {orb.y})")

async def apply_powerup(game_id, player, orb):
    """
    Applique l'effet du power-up au joueur.
    """
    # Implémenter la logique d'application des effets
    print(f"[game_loop.py] Applying power-up {orb.effect_type} to {player}")

    # Exemple de notification
    channel_layer = get_channel_layer()
    effect = orb.effect_type
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'powerup_applied',
            'player': player,
            'effect': effect
        }
    )

async def handle_score(game_id, scorer):
    """
    Gère l'incrément du score, vérifie si la partie est terminée.
    """
    if scorer == 'score_left':
        score_left = int(r.get(f"{game_id}:score_left") or 0) + 1
        r.set(f"{game_id}:score_left", score_left)
        print(f"[game_loop.py] Player Left scored. Score: {score_left} - {r.get(f'{game_id}:score_right')}")
        if score_left >= WIN_SCORE:
            await finish_game(game_id, 'left')
    elif scorer == 'score_right':
        score_right = int(r.get(f"{game_id}:score_right") or 0) + 1
        r.set(f"{game_id}:score_right", score_right)
        print(f"[game_loop.py] Player Right scored. Score: {r.get(f'{game_id}:score_left')} - {score_right}")
        if score_right >= WIN_SCORE:
            await finish_game(game_id, 'right')

async def finish_game(game_id, winner):
    """
    Termine la partie, notifie, supprime les clés Redis, enregistre GameResult.
    """
    print(f"[game_loop.py] Game {game_id} finished, winner={winner}")
    channel_layer = get_channel_layer()
    try:
        session = await sync_to_async(GameSession.objects.get)(pk=game_id)
        session.status = 'finished'
        await sync_to_async(session.save)()

        score_left = int(r.get(f"{game_id}:score_left") or 0)
        score_right = int(r.get(f"{game_id}:score_right") or 0)
        await sync_to_async(GameResult.objects.create)(
            game=session,
            winner=winner,
            score_left=score_left,
            score_right=score_right
        )
        print(f"[game_loop.py] GameResult created for game_id={game_id}, winner={winner}")
    except GameSession.DoesNotExist:
        print(f"[game_loop.py] GameSession {game_id} does not exist.")
        pass

    # Notifier
    await channel_layer.group_send(
        f"pong_{game_id}",
        {
            'type': 'game_over',
            'winner': winner
        }
    )
    # print(f"[game_loop.py] Broadcast game_over for game_id={game_id}, winner={winner}")

    # Nettoyer les clés Redis
    keys = list(r.scan_iter(f"{game_id}:*"))
    for key in keys:
        r.delete(key)
    print(f"[game_loop.py] Redis keys deleted for game_id={game_id}")

async def spawn_powerup(game_id, orb):
    terrain_rect = await get_terrain_rect(game_id)
    if await sync_to_async(orb.spawn)(terrain_rect):
        r.set(f"{game_id}:powerup_{orb.effect_type}_active", 1)
        r.set(f"{game_id}:powerup_{orb.effect_type}_x", orb.x)
        r.set(f"{game_id}:powerup_{orb.effect_type}_y", orb.y)
        print(f"[game_loop.py] PowerUp {orb.effect_type} spawned at ({orb.x}, {orb.y})")
        return True
    return False

async def spawn_bumper(game_id, bumper):
    terrain_rect = await get_terrain_rect(game_id)
    if await sync_to_async(bumper.spawn)(terrain_rect):
        key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
        r.set(key, 1)
        r.set(f"{game_id}:bumper_{bumper.x}_{bumper.y}_x", bumper.x)
        r.set(f"{game_id}:bumper_{bumper.x}_{bumper.y}_y", bumper.y)
        print(f"[game_loop.py] Bumper spawned at ({bumper.x}, {bumper.y})")
        return True
    return False

async def count_active_powerups(game_id, power_up_orbs):
    """
    Compte le nombre de power-ups actifs.
    """
    count = 0
    for orb in power_up_orbs:
        if r.get(f"{game_id}:powerup_{orb.effect_type}_active"):
            count += 1
    return count

async def count_active_bumpers(game_id, bumpers):
    """
    Compte le nombre de bumpers actifs.
    """
    count = 0
    for bumper in bumpers:
        if r.get(f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"):
            count += 1
    return count

async def handle_powerup_expiration(game_id, power_up_orbs):
    """
    Gère l'expiration des power-ups.
    """
    current_time = time.time()
    for orb in power_up_orbs:
        if orb.active and current_time - orb.spawn_time >= orb.duration:
            orb.deactivate()
            r.set(f"{game_id}:powerup_{orb.effect_type}_active", 0)
            print(f"[game_loop.py] PowerUp {orb.effect_type} expired at ({orb.x}, {orb.y})")

async def handle_bumper_expiration(game_id, bumpers):
    """
    Gère l'expiration des bumpers.
    """
    current_time = time.time()
    for bumper in bumpers:
        if bumper.active and current_time - bumper.spawn_time >= bumper.duration:
            bumper.deactivate()
            key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
            r.set(key, 0)
            print(f"[game_loop.py] Bumper at ({bumper.x}, {bumper.y}) expired")

async def broadcast_game_state(game_id, channel_layer, paddle_left, paddle_right, ball, power_up_orbs, bumpers):
    """
    Envoie l'état actuel du jeu aux clients via WebSocket.
    """
    # Récupérer les états des power-ups
    powerups = []
    for orb in power_up_orbs:
        if r.get(f"{game_id}:powerup_{orb.effect_type}_active"):
            x = float(r.get(f"{game_id}:powerup_{orb.effect_type}_x"))
            y = float(r.get(f"{game_id}:powerup_{orb.effect_type}_y"))
            powerups.append({
                'type': orb.effect_type,
                'x': x,
                'y': y,
                'color': list(orb.color)  # Convertir en liste pour JSON
            })

    # Récupérer les états des bumpers
    active_bumpers = []
    for bumper in bumpers:
        key = f"{game_id}:bumper_{bumper.x}_{bumper.y}_active"
        if r.get(key):
            active_bumpers.append({
                'x': bumper.x,
                'y': bumper.y,
                'size': bumper.size,
                'color': list(bumper.color)  # Convertir en liste pour JSON
            })

    data = {
        'type': 'game_state',
        'ball_x': ball.x,
        'ball_y': ball.y,
        'ball_size': ball.size,
        'ball_speed_x': ball.speed_x,
        'ball_speed_y': ball.speed_y,
        'paddle_left_y': paddle_left.y,
        'paddle_right_y': paddle_right.y,
        'paddle_width': paddle_left.width,
        'paddle_left_height': paddle_left.height,
        'paddle_right_height': paddle_right.height,
        'score_left': int(r.get(f"{game_id}:score_left") or 0),
        'score_right': int(r.get(f"{game_id}:score_right") or 0),
        'powerups': powerups,
        'bumpers': active_bumpers,
    }

    await channel_layer.group_send(f"pong_{game_id}", {
        'type': 'broadcast_game_state',
        'data': data
    })
    # print(f"[game_loop.py] Broadcast game_state for game_id={game_id}")
# game/game_objects.py

import random
import math
import time

class Paddle:
    def __init__(self, position, size, speed):
        """
        position: 'left' ou 'right'
        size: taille initiale de la raquette
        speed: vitesse de déplacement
        """
        self.position = position
        self.width = 10
        self.height = size
        self.x = 50 if position == 'left' else 750
        self.y = 200 - self.height // 2
        self.speed = speed
        self.velocity = 0
        self.on_ice = False
        self.shown_size = size  # Current displayed size

    def move(self, direction, is_on_ice, terrain_top, terrain_bottom, speed_boost=False):
        if is_on_ice:
            acceleration = 0.5
            friction = 0.02
            self.velocity += direction * acceleration
            self.velocity *= (1 - friction)
        else:
            self.velocity = direction * (self.speed * 1.5 if speed_boost else self.speed)

        # Apply movement with boundary checking
        new_y = self.y + self.velocity
        if new_y < terrain_top:
            new_y = terrain_top
            self.velocity = 0
        elif new_y + self.height > terrain_bottom:
            new_y = terrain_bottom - self.height
            self.velocity = 0

        self.y = new_y

    def resize(self, new_height):
        self.height = new_height

class Ball:
    def __init__(self, x, y, speed_x, speed_y, size=7):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y
        self.size = size

    def move(self):
        self.x += self.speed_x
        self.y += self.speed_y

    def reset(self, x, y, speed_x, speed_y):
        self.x = x
        self.y = y
        self.speed_x = speed_x
        self.speed_y = speed_y

class PowerUpOrb:
    def __init__(self, game_id, effect_type, terrain_rect, color=None):
        self.game_id = game_id
        self.effect_type = effect_type  # 'invert', 'shrink', 'ice', 'speed', 'sticky', 'flash'
        self.size = 15
        self.color = color or self.get_default_color()
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 0

    def get_default_color(self):
        colors = {
            'invert': (255, 105, 180),  # Pink
            'shrink': (255, 0, 0),      # Red
            'ice': (0, 255, 255),       # Cyan
            'speed': (255, 215, 0),     # Gold
            'flash': (255, 255, 0),     # Yellow
            'sticky': (50, 205, 50)     # Lime green
        }
        return colors.get(self.effect_type, (255, 255, 255))

    def spawn(self, terrain_rect):
        left = terrain_rect['left']
        right = terrain_rect['left'] + terrain_rect['width']
        top = terrain_rect['top']
        bottom = terrain_rect['top'] + terrain_rect['height']

        max_attempts = 100
        for _ in range(max_attempts):
            new_x = random.randint(left + 50, right - 50)
            new_y = random.randint(top + 50, bottom - 50)

            # Ici on suppose qu'il n'y a pas d'autres collisions à vérifier.
            self.x = new_x
            self.y = new_y
            self.rect = (self.x, self.y, self.size, self.size)
            self.active = True
            self.spawn_time = time.time()
            self.duration = 10
            return True

        return False

    def deactivate(self):
        self.active = False

class Bumper:
    def __init__(self, game_id, terrain_rect):
        self.game_id = game_id
        self.size = 20
        self.color = (255, 255, 255)  # White
        self.active = False
        self.x = 0
        self.y = 0
        self.rect = None
        self.spawn_time = 0
        self.duration = 0
        self.last_collision_time = 0 

    def spawn(self, terrain_rect):
        left = terrain_rect['left']
        right = terrain_rect['left'] + terrain_rect['width']
        top = terrain_rect['top']
        bottom = terrain_rect['top'] + terrain_rect['height']

        max_attempts = 100
        for _ in range(max_attempts):
            new_x = random.randint(left + 50, right - 50)
            new_y = random.randint(top + 50, bottom - 50)

            # Ici on suppose qu'il n'y a pas d'autres collisions à vérifier.
            self.x = new_x
            self.y = new_y
            self.rect = (self.x, self.y, self.size, self.size)
            self.active = True
            self.spawn_time = time.time()
            self.duration = 10
            return True

        return False

    def deactivate(self):
        self.active = False
# game/manager.py

import asyncio
from .tasks import start_game_loop
import sys

_GLOBAL_LOOP = None

def set_global_loop(loop):
    """
    Stocke une référence à l'event loop principale.
    Appelée lors du démarrage dans asgi.py via LifespanHandler.
    """
    global _GLOBAL_LOOP
    _GLOBAL_LOOP = loop
    print(f"[manager.py] Global loop set: {loop}")

def get_global_loop():
    """
    Renvoie la référence à l'event loop principale.
    """
    return _GLOBAL_LOOP

def schedule_game(game_id):
    """
    Programme l'exécution de start_game_loop(game_id) sans bloquer la requête.
    Tente d'utiliser create_task, sinon fallback sur run_coroutine_threadsafe avec la loop globale.
    """
    try:
        # Essayer de récupérer l'event loop courant
        current_loop = asyncio.get_event_loop()
        if not current_loop.is_running():
            raise RuntimeError("Event loop is not running")
        current_loop.create_task(start_game_loop(game_id))
        print(f"[schedule_game] create_task OK dans loop={current_loop} pour game_id={game_id}")
    except (RuntimeError, AttributeError) as e:
        # Si aucun event loop n'est disponible dans ce thread, utiliser la loop globale
        print("No current event loop in this thread, fallback run_coroutine_threadsafe", file=sys.stderr)
        global_loop = get_global_loop()
        if global_loop and global_loop.is_running():
            future = asyncio.run_coroutine_threadsafe(start_game_loop(game_id), global_loop)
            print(f"[schedule_game] run_coroutine_threadsafe OK dans global_loop={global_loop} pour game_id={game_id}")
        else:
            print("No global loop available or loop is not running, game cannot be scheduled.", file=sys.stderr)
import uuid
from django.db import models
from django.conf import settings

class GameSession(models.Model):
    """
    Un enregistrement pour représenter une partie (en cours ou terminée).
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    player_left = models.CharField(max_length=50, null=True, blank=True)
    player_right = models.CharField(max_length=50, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    # ex: "running", "finished"
    status = models.CharField(max_length=10, default='running')

    def __str__(self):
        return f"GameSession {self.id} (status={self.status})"


class GameParameters(models.Model):
    BALL_SPEED_CHOICES = [
        (1, 'Slow'),
        (2, 'Medium'),
        (3, 'Fast'),
    ]
    ball_speed = models.PositiveSmallIntegerField(choices=BALL_SPEED_CHOICES, default=2)

    RACKET_SIZE_CHOICES = [
        (1, 'Small'),
        (2, 'Medium'),
        (3, 'Large'),
    ]
    racket_size = models.PositiveSmallIntegerField(choices=RACKET_SIZE_CHOICES, default=2)

    bonus_malus_activation = models.BooleanField(default=True)
    bumpers_activation = models.BooleanField(default=False)

    game_session = models.OneToOneField(
        GameSession,
        related_name='parameters',
        on_delete=models.CASCADE
    )

    def __str__(self):
        return (f"Ball speed: {self.get_ball_speed_display()}, "
                f"Racket size: {self.get_racket_size_display()}, "
                f"Bonus/Malus: {'On' if self.bonus_malus_activation else 'Off'}, "
                f"Bumpers: {'On' if self.bumpers_activation else 'Off'}")


class GameResult(models.Model):
    """
    Enregistre le score final d'une partie terminée.
    """
    game = models.ForeignKey(GameSession, on_delete=models.CASCADE)
    winner = models.CharField(max_length=10)  # "left" ou "right"
    score_left = models.IntegerField()
    score_right = models.IntegerField()
    ended_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"[{self.game.id}] winner={self.winner} => {self.score_left}-{self.score_right}"


class GameInvitation(models.Model):
    from_user = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='invitations_sent', on_delete=models.CASCADE)
    to_user = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='invitations_received', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=10,
        choices=[('pending', 'Pending'), ('accepted', 'Accepted'), ('rejected', 'Rejected')],
        default='pending'
    )
    
    def __str__(self):
        return f"Invitation de {self.from_user.username} à {self.to_user.username} - {self.status}"
from django.urls import re_path
from .consumers import PongConsumer

websocket_urlpatterns = [
    # ws://host/ws/pong/<uuid>/
    re_path(r'^ws/pong/(?P<game_id>[0-9a-f-]+)/$', PongConsumer.as_asgi()),
]
# game/tasks.py

import asyncio

ACTIVE_GAMES = {}  # Dict: { game_id -> asyncio.Task }

async def start_game_loop(game_id):
    """
    Lance la game_loop(game_id) et stocke la Task dans ACTIVE_GAMES.
    """
    from .game_loop import game_loop

    # Créer une nouvelle Task
    task = asyncio.create_task(game_loop(game_id))
    ACTIVE_GAMES[game_id] = task

    print(f"[tasks.py] Game loop started for game_id={game_id}")

    try:
        # Attendre que la boucle se termine (score atteint ou session finished)
        await task
    except asyncio.CancelledError:
        print(f"[tasks.py] Game loop for game_id={game_id} was cancelled.")
    finally:
        # Une fois terminé ou annulé, enlever de ACTIVE_GAMES
        del ACTIVE_GAMES[game_id]
        print(f"[tasks.py] Game loop ended for game_id={game_id}")

def is_game_running(game_id):
    """
    Vérifie si une partie est en cours.
    """
    return game_id in ACTIVE_GAMES

def stop_game(game_id):
    """
    Permet de stopper manuellement une partie en cours (annuler la Task).
    """
    task = ACTIVE_GAMES.get(game_id)
    if task:
        task.cancel()
        print(f"[tasks.py] Game loop for game_id={game_id} has been cancelled.")
from django.test import TestCase

# Create your tests here.
# game/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('create/', views.create_game, name='create_game'),
    path('<uuid:game_id>/', views.game_page, name='game'),
    path('results/', views.list_results, name='list_results'),
]
from django.shortcuts import render, redirect
from .models import GameSession, GameResult, GameParameters
from .manager import schedule_game
from .forms import GameParametersForm
from django.conf import settings
import redis

r = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=0)

def index(request):
    """
    Page d'accueil -> bouton pour créer une partie
    """
    return render(request, 'game/index.html')

def create_game(request):
    """
    Crée un GameSession (UUID), init Redis avec les paramètres personnalisés, lance la loop en non-bloquant
    """
    if request.method == 'POST':
        form = GameParametersForm(request.POST)
        if form.is_valid():
            # Créer une nouvelle GameSession
            session = GameSession.objects.create(status='running') 
            game_id = str(session.id)

            # Créer les GameParameters liés à cette session
            parameters = form.save(commit=False)
            parameters.game_session = session
            parameters.save()

            # Initialiser Redis avec les paramètres personnalisés
            r.set(f"{game_id}:score_left", 0)
            r.set(f"{game_id}:score_right", 0)
            r.set(f"{game_id}:paddle_left_y", 150)
            r.set(f"{game_id}:paddle_right_y", 150)
            r.set(f"{game_id}:ball_x", 300)
            r.set(f"{game_id}:ball_y", 200)
            # Ajuster la vitesse de la balle selon le paramètre
            ball_vx = 3 * parameters.ball_speed
            ball_vy = 2 * parameters.ball_speed
            r.set(f"{game_id}:ball_vx", ball_vx)
            r.set(f"{game_id}:ball_vy", ball_vy)

            # Si les bumpers sont activés, initialiser leurs positions ou autres configurations
            if parameters.bumpers_activation:
                # Exemple: ajouter des bumpers dans Redis
                # À implémenter selon la logique du jeu
                pass

            print(f"[create_game] GameSession {game_id} created avec paramètres personnalisés. Scheduling game_loop.")
            schedule_game(game_id)

            return redirect('game', game_id=game_id)
    else:
        form = GameParametersForm()

    return render(request, 'game/create_game.html', {'form': form})

def game_page(request, game_id):
    """
    Affiche la page HTML (canvas + websocket) pour la partie <game_id>
    """
    return render(request, 'game/game.html', {'game_id': game_id})

def list_results(request):
    """
    Affiche la liste des parties terminées.
    """
    results = GameResult.objects.select_related('game').order_by('-ended_at')[:20]
    return render(request, 'game/results.html', {'results': results})
<!DOCTYPE html>
<html>
<head>
  <title>Game</title>
  <style>
    #gameCanvas {
      background: black;
      border: 2px solid white;
      display: block;
      margin: 0 auto;
      max-width: 100%;
    }

    body {
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        height: 100vh;  /* Force full height */
        background: #1a1a1a;
        color: white;
        overflow: hidden;  /* Prevent scrolling */
        box-sizing: border-box;  /* Include padding in height calculation */
    }

    h1 {
        text-align: center;
        font-size: clamp(1.5rem, 4vw, 2.5rem); /* Responsive font size */
    }

    .game-container {
        width: 100%;
        max-width: 1200px; /* Maximum game width */
        position: relative;
        aspect-ratio: 2/1;
    }
  </style>
</head>
<body>
  <h1>Pong Game - ID : {{ game_id }}</h1>
  <div class="game-container">
    <canvas id="gameCanvas" width="800" height="400"></canvas>
  </div>

  <script>
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    let scale = 1;

    const gameId = "{{ game_id }}";
    const protocol = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
    const wsUrl = protocol + '//' + window.location.host + '/ws/pong/' + gameId + '/';
    const socket = new WebSocket(wsUrl);

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Handle canvas resize
    function handleResize() {
      const container = document.querySelector('.game-container');
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // Calculate new scale
      scale = Math.min(containerWidth / ORIGINAL_WIDTH, containerHeight / ORIGINAL_HEIGHT);
      
      // Set canvas size
      canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
      canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';
      
      // Keep canvas resolution sharp
      canvas.width = ORIGINAL_WIDTH;
      canvas.height = ORIGINAL_HEIGHT;
      
      // Reset context properties
      ctx.imageSmoothingEnabled = false;
    }

    // Add resize event listener
    window.addEventListener('resize', handleResize);
    // Initial resize
    handleResize();

  // Function to create SVG power-up data URLs
    function createPowerupSVG(type) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 50 50");
      svg.setAttribute("width", "30");
      svg.setAttribute("height", "30");
      
      const powerupStyles = {
          'invert': {
              colors: {main: '#FF69B4', glow: '#FF1493'},
              icon: 'M25 15 A10 10 0 1 1 25 35 M25 35 L20 30 M25 35 L30 30'
          },
          'shrink': {
              colors: {main: '#FF0000', glow: '#8B0000'},
              icon: 'M25 25 L35 15 M33 15 L35 15 L35 17 M25 25 L15 15 M17 15 L15 15 L15 17 M25 25 L35 35 M33 35 L35 35 L35 33 M25 25 L15 35 M17 35 L15 35 L15 33'
          },
          'ice': {
              colors: {main: '#00FFFF', glow: '#00CED1'},
              paths: [
                  {d: 'M25 10 L25 40 M18 14 L32 36 M32 14 L18 36 M20 25 L30 25', 
                  fill: 'none', stroke: 'white', width: 3},
                  {d: 'M25 25 m-3,0 a3,3 0 1,0 6,0 a3,3 0 1,0 -6,0', 
                  fill: 'white', stroke: 'none', width: 0}
              ]
          },
          'speed': {
              colors: {main: '#FFD700', glow: '#FFA500'},
              icon: 'M30 10 L20 25 L27 25 L17 40 L32 25 L25 25 L35 10',
              fill: 'white'
          },
          'flash': {
              colors: {main: '#FFFF00', glow: '#FFD700'},
              paths: [
                  {d: 'M25 10 m-8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0', 
                  fill: 'white', stroke: 'none', width: 0},
                  {d: 'M25 10 L25 17 M25 33 L25 40 M35 25 L42 25 M8 25 L15 25 M32 18 L37 13 M13 37 L18 32 M32 32 L37 37 M13 13 L18 18',
                  fill: 'none', stroke: 'white', width: 3}
              ]
          },
          'sticky': {
              colors: {main: '#32CD32', glow: '#228B22'},
              icon: 'M25 10 C15 10 15 20 25 20 C35 20 35 10 25 10 M17 20 C17 40 33 40 33 20',
              fill: 'white'
          }
      };
      
      const style = powerupStyles[type] || powerupStyles['speed'];
      
      // Create gradient
      const gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
      gradient.id = `${type}Glow`;
      
      const stops = [
          {offset: '0%', color: style.colors.main, opacity: '1'},
          {offset: '100%', color: style.colors.glow, opacity: '0.6'}
      ];
      
      stops.forEach(stop => {
          const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
          stopEl.setAttribute("offset", stop.offset);
          stopEl.setAttribute("stop-color", stop.color);
          stopEl.setAttribute("stop-opacity", stop.opacity);
          gradient.appendChild(stopEl);
      });
      
      svg.appendChild(gradient);
      
      // Create base circle
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "25");
      circle.setAttribute("cy", "25");
      circle.setAttribute("r", "20");
      circle.setAttribute("fill", `url(#${type}Glow)`);
      svg.appendChild(circle);
      
      // Add icon(s)
      if (style.paths) {
          // For complex icons with multiple paths
          style.paths.forEach(pathData => {
              const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
              path.setAttribute("d", pathData.d);
              path.setAttribute("stroke", pathData.stroke);
              path.setAttribute("stroke-width", pathData.width);
              path.setAttribute("fill", pathData.fill);
              svg.appendChild(path);
          });
      } else {
          // For single path icons
          const icon = document.createElementNS("http://www.w3.org/2000/svg", "path");
          icon.setAttribute("d", style.icon);
          icon.setAttribute("stroke", "white");
          icon.setAttribute("stroke-width", "3");
          icon.setAttribute("fill", style.fill || "none");
          svg.appendChild(icon);
      }
      
      return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
  }

  function createBumperSVG() {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 100 100");
      
      // Create white orb gradient
      const whiteGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
      whiteGradient.id = "whiteOrbGradient";
      whiteGradient.setAttribute("cx", "40%");
      whiteGradient.setAttribute("cy", "40%");
      whiteGradient.setAttribute("r", "60%");
      
      const whiteStops = [
        {offset: '0%', color: 'white', opacity: '1'},
        {offset: '90%', color: '#e0e0e0', opacity: '1'}
      ];
      
      whiteStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        whiteGradient.appendChild(stopEl);
      });
      
      // Create blue ring gradient
      const blueGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
      blueGradient.id = "blueRingGradient";
      blueGradient.setAttribute("cx", "50%");
      blueGradient.setAttribute("cy", "50%");
      blueGradient.setAttribute("r", "50%");
      
      const blueStops = [
        {offset: '0%', color: '#4169E1', opacity: '1'},
        {offset: '100%', color: '#1E90FF', opacity: '1'}
      ];
      
      blueStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        blueGradient.appendChild(stopEl);
      });
      
      // Add gradients to defs
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      defs.appendChild(whiteGradient);
      defs.appendChild(blueGradient);
      svg.appendChild(defs);
      
      // Blue exterior ring
      const ringCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      ringCircle.setAttribute("cx", "50");
      ringCircle.setAttribute("cy", "50");
      ringCircle.setAttribute("r", "45");
      ringCircle.setAttribute("fill", "none");
      ringCircle.setAttribute("stroke", "url(#blueRingGradient)");
      ringCircle.setAttribute("stroke-width", "8");
      
      // White orb center
      const whiteOrb = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      whiteOrb.setAttribute("cx", "50");
      whiteOrb.setAttribute("cy", "50");
      whiteOrb.setAttribute("r", "35");
      whiteOrb.setAttribute("fill", "url(#whiteOrbGradient)");
      
      // Highlight for 3D effect
      const highlight = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      highlight.setAttribute("cx", "35");
      highlight.setAttribute("cy", "35");
      highlight.setAttribute("r", "15");
      highlight.setAttribute("fill", "white");
      highlight.setAttribute("opacity", "0.3");
      
      svg.appendChild(ringCircle);
      svg.appendChild(whiteOrb);
      svg.appendChild(highlight);
      
      return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
    }


  // Create and cache power-up images
  const powerupImages = {
      'invert': new Image(),
      'shrink': new Image(),
      'ice': new Image(),
      'speed': new Image(),
      'flash': new Image(),
      'sticky': new Image()
  };

  // Initialize power-up images
  function initPowerupImages() {
      Object.keys(powerupImages).forEach(type => {
          powerupImages[type].src = createPowerupSVG(type);
      });
  }

  // Create and cache bumper image
  const bumperImage = new Image();
  bumperImage.src = createBumperSVG();

  // Call initialization
  initPowerupImages();

    // État initial du jeu côté client
    let gameState = {
      type: 'game_state',
      ball_x: 400, 
      ball_y: 200,
      ball_size: 7,
      ball_speed_x: 4,
      ball_speed_y: 4,
      paddle_left_y: 170,
      paddle_right_y: 170,
      paddle_width: 10,
      paddle_left_height: 60,
      paddle_right_height: 60,
      score_left: 0, 
      score_right: 0,
      powerups: [],
      bumpers: [],
      flash_effect: false
    };

    socket.onopen = () => {
      console.log("[Frontend] WebSocket connection opened.");
    };

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      // console.log("[Frontend] Received data:", data);
      if (data.type === 'game_state') {
        gameState = data;
      } else if (data.type === 'game_over') {
        alert("Game Over! Winner = " + data.winner);
        socket.close();
      } else if (data.type === 'powerup_applied') {
        console.log(`[Frontend] Power-up applied to ${data.player}: ${data.effect}`);
      }
    };

    socket.onclose = () => {
      console.log("[Frontend] WebSocket connection closed.");
    };

    let keysPressed = {};

    document.addEventListener('keydown', (evt) => {
      if (evt.repeat) return;

      let action = "start_move", player = null, direction = null;
      
      switch(evt.key) {
        case 'w':
        case 'W':
          player = 'left';
          direction = 'up';
          break;
        case 's':
        case 'S':
          player = 'left';
          direction = 'down';
          break;
        case 'ArrowUp':
          player = 'right';
          direction = 'up';
          break;
        case 'ArrowDown':
          player = 'right';
          direction = 'down';
          break;
      }
      if (player && direction && !keysPressed[evt.key]) {
        socket.send(JSON.stringify({
          action: action,
          player: player,
          direction: direction
        }));
        console.log(`[Frontend] Sent start_move: player=${player}, direction=${direction}`);
        keysPressed[evt.key] = true;
      }
    });

    document.addEventListener('keyup', (evt) => {
      let action = "stop_move", player = null;

      switch(evt.key) {
        case 'w':
        case 'W':
          player = 'left';
          break;
        case 's':
        case 'S':
          player = 'left';
          break;
        case 'ArrowUp':
          player = 'right';
          break;
        case 'ArrowDown':
          player = 'right';
          break;
      }
      if (player && keysPressed[evt.key]) {
        socket.send(JSON.stringify({
          action: action,
          player: player
        }));
        console.log(`[Frontend] Sent stop_move: player=${player}`);
        keysPressed[evt.key] = false;
      }
    });

    function draw() {
      if (gameState.flash_effect) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Terrain
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
        
        // Paddles
        ctx.fillStyle = 'white';
        ctx.fillRect(50, gameState.paddle_left_y, 
          gameState.paddle_width, gameState.paddle_left_height);
        ctx.fillRect(canvas.width - 50 - gameState.paddle_width, 
          gameState.paddle_right_y, 
          gameState.paddle_width, 
          gameState.paddle_right_height);
        
        // Ball
        ctx.beginPath();
        ctx.arc(gameState.ball_x, gameState.ball_y, gameState.ball_size, 0, 2*Math.PI);
        ctx.fill();

        // Power-ups with scaling
        gameState.powerups.forEach(orb => {
            const type = orb.type || 'speed';
            const img = powerupImages[type];
            if (img.complete) {
                ctx.save();
                
                // Add glow effect based on type
                const glowColors = {
                    'invert': '#FF69B4',
                    'shrink': '#FF0000',
                    'ice': '#00FFFF',
                    'speed': '#FFD700',
                    'flash': '#FFFF00',
                    'sticky': '#32CD32'
                };
                
                ctx.shadowColor = glowColors[type] || glowColors['speed'];
                ctx.shadowBlur = 10;
                
                ctx.drawImage(img, 
                    orb.x - 15,
                    orb.y - 15, 
                    30, 
                    30
                );
                
                ctx.restore();
            }
        });

        // Bumpers
        gameState.bumpers.forEach(bumper => {
          if (bumperImage.complete) {
            ctx.save();
            ctx.shadowColor = '#4169E1';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(bumperImage,
              bumper.x - bumperSize,
              bumper.y - bumperSize,
              bumperSize * 2,
              bumperSize * 2
            );
            ctx.restore();
          }
        });
      }

      // Scores
      ctx.fillStyle='white';
      ctx.font="20px Arial";
      ctx.fillText(`${gameState.score_left}`, 20, 30);
      ctx.fillText(`${gameState.score_right}`, canvas.width - 40, 30);

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  </script>
</body>
</html>