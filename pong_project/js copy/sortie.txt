===== ./accountManagement/events.js =====
import { requestPost } from '../api/api.js';
import { handleDeleteAccount } from '../auth/index.js';
import { navigateTo } from '../router.js';

async function handleLanguageChange(language) {
    const formData = new FormData();
    console.log(language);
    formData.append('language', language); // Ajoute la paire cl√©-valeur "language=fr"
    const data = await  requestPost('accounts', 'set_language', formData);
    if (data.status === 'success') {
        location.reload(); // Recharge la page pour appliquer la langue
    }
}

export function attachProfileEvents() {
    // Bouton Activer 2FA
    const enable2FABtn = document.querySelector('#enable-2fa-btn');
    if (enable2FABtn && !enable2FABtn.dataset.bound) {
        enable2FABtn.addEventListener('click', () => {
            navigateTo('/enable-2fa');
        });
        enable2FABtn.dataset.bound = true;
    }

    // Bouton D√©sactiver 2FA
    const disable2FABtn = document.querySelector('#disable-2fa-btn');
    if (disable2FABtn && !disable2FABtn.dataset.bound) {
        disable2FABtn.addEventListener('click', () => {
            navigateTo('/disable-2fa');
        });
        disable2FABtn.dataset.bound = true;
    }

    // Bouton Supprimer le compte
    const deleteAccountBtn = document.querySelector('#delete-account-btn');
    if (deleteAccountBtn && !deleteAccountBtn.dataset.bound) {
        deleteAccountBtn.addEventListener('click', handleDeleteAccount);
        deleteAccountBtn.dataset.bound = true;
    }

    // S√©lectionne tous les boutons de langue
    const languageButtons = document.querySelectorAll('button[data-lang]');
    // Ajoute un gestionnaire d'√©v√©nements √† chaque bouton
    languageButtons.forEach(button => {
        if (!button.dataset.bound) { // Emp√™che les doublons
            button.addEventListener('click', event => {
                event.preventDefault(); // Emp√™che le comportement par d√©faut (soumission du formulaire)
                handleLanguageChange(button.dataset.lang); // R√©cup√®re la valeur
            });
        button.dataset.bound = true;
        }
    });
}

===== ./accountManagement/handleLanguage.js =====

===== ./accountManagement/index.js =====
// profile/index.js
export { attachProfileEvents } from './events.js';
export { handleAccountsManagement } from './accountsManagement.js';
export { initializeaccountsManagementFormHandlers } from './formHandler.js';
===== ./accountManagement/accountsManagement.js =====
import { requestGet } from "../api/index.js";
import { updateHtmlContent, displayErrorMessage } from "../tools/index.js";
import { initializeaccountsManagementFormHandlers } from "./index.js";
import { showStatusMessage } from "../tools/index.js";
async function loadAccountsManagement() {
    try {
        const response = await requestGet('accounts', 'gestion_profil');
        if (!response) {
            return;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html);
        }
        else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue de gestion de profil.');
        }
        return true;
    } catch (error) {
        console.error('Erreur chargement gestion profil:', error);
        showStatusMessage(error.message || 'Erreur lors du chargement de la vue de gestion de profil.', 'errors');
    }
}

export async function handleAccountsManagement() {
    let accountsManagementLoaded;
    try {
        accountsManagementLoaded = await loadAccountsManagement();
        if (!accountsManagementLoaded) {
            return;
        }
        // Si votre backend renvoie directement du HTML, utilisez-le tel quel.
        // Sinon, adaptez en fonction de ce qui est renvoy√©.
        initializeaccountsManagementFormHandlers();
    } catch (error) {
        console.error('Erreur chargement gestion profil:', error);
        showStatusMessage(error.message || 'Erreur lors du chargement de la vue de gestion de profil.', 'errors');
    }
}

===== ./accountManagement/formHandler.js =====
import { requestPost } from '../api/index.js';
import { navigateTo } from '../router.js';
import { showStatusMessage } from '../tools/displayInfo.js';
import { attachProfileEvents } from './events.js';
import { handleNavbar } from '../navbar/index.js';
import { handleLogout } from '../auth/index.js';

// Fonction pour g√©rer la soumission des formulaires
async function handleFormSubmit(form, app, view, successMessage, successSelector) {
    const formData = new FormData(form);
    try {
        const response = await requestPost(app, view, formData);
        if (response.status === 'success') {
            const successElem = document.querySelector(successSelector);
            if (successElem) {
                successElem.textContent = successMessage;
                successElem.style.display = 'block';
                setTimeout(() => successElem.style.display = 'none', 3000);
            }
            form.reset();
            if (successSelector === '#change-avatar-success') {
                await handleNavbar(); 
            }
            else if (successSelector === '#change-username-success') {
                await handleLogout();
            }
            navigateTo('/account')
           
        } else {
            showStatusMessage(response.message, "error");
        }
    } catch (error) {
        console.error(`Erreur lors de la requ√™te vers ${app}/${view}:`, error);
        showStatusMessage(response.message, "error");
    }
}

// Initialise les gestionnaires pour les formulaires
export function initializeaccountsManagementFormHandlers() {
    document.querySelectorAll('form').forEach((form) => {
        if (!form.hasAttribute('data-handled')) {
            form.addEventListener('submit', async function(e) {
                e.preventDefault();

                switch (form.id) {
                    case 'change-username-form':
                        await handleFormSubmit(form, 'accounts', 'profile/update', 'Pseudo mis √† jour!', '#change-username-success');
                        break;
                    case 'change-password-form':
                        await handleFormSubmit(form, 'accounts', 'profile/change_password', 'Mot de passe mis √† jour!', '#change-password-success');
                        break;
                    case 'change-avatar-form':
                        await handleFormSubmit(form, 'accounts', 'profile/update_avatar', 'Avatar mis √† jour!', '#change-avatar-success');
                        break;
                    case 'delete-account-form':
                        break;
                    default:
                        console.warn('Formulaire non reconnu:', form.id);
                }
            });
            form.setAttribute('data-handled', 'true');
        }
    });

    // Attache les √©v√©nements sp√©cifiques aux boutons du profil
    attachProfileEvents();
}
    
===== ./api/apiErrors.js =====
//api/apiErrors.js

// Classe de base pour les erreurs sp√©cifiques √† la requ√™te
export class RequestError extends Error {
    constructor(message, status = null) {
        super(message);
        this.name = "RequestError";
        this.status = status; // Le code HTTP, si disponible
    }
}

// Erreur pour les r√©ponses HTTP non r√©ussies
export class HTTPError extends RequestError {
    constructor(message, status) {
        super(message, status);
        this.name = "HTTPError";
    }
}

// Erreur pour un probl√®me de format inattendu dans la r√©ponse
export class ContentTypeError extends RequestError {
    constructor(message) {
        super(message);
        this.name = "ContentTypeError";
    }
}

// Erreur pour un probl√®me r√©seau (fetch lui-m√™me √©choue)
export class NetworkError extends RequestError {
    constructor(message) {
        super(message);
        this.name = "NetworkError";
    }
}
===== ./api/index.js =====
// api/index.js
// contient uniquement les fonctions que l' on souhaite appeler depuis d'autres fichiers

export { requestGet, requestPost , requestDelete} from './api.js';
export { RequestError, HTTPError, ContentTypeError, NetworkError } from './apiErrors.js';

===== ./api/api.js =====
import { navigateTo } from '../router.js';
import { HTTPError, ContentTypeError, NetworkError } from './apiErrors.js';
import { showStatusMessage } from '../tools/displayInfo.js';

const Api = {
  /**
   * Effectue une requ√™te HTTP avec fetch en utilisant FormData.
   * @param {string} url - L'URL compl√®te de la ressource.
   * @param {string} method - La m√©thode HTTP (GET, POST, PUT, DELETE).
   * @param {FormData|null} formData - Les donn√©es √† envoyer dans le corps de la requ√™te.
   * @param {Object} customHeaders - Headers suppl√©mentaires √† ajouter.
   * @returns {Promise} - Une promesse r√©solue avec les donn√©es JSON ou rejet√©e en cas d'erreur.
   */
  async request(url, method = 'GET', formData = null, customHeaders = {}) {
    try {
      // Pr√©pare et fusionne les en-t√™tes (CSRF et JWT)
      const headers = { ...this.prepareHeaders(), ...customHeaders };

      // V√©rification et renouvellement du token si n√©cessaire
      const jwtAccessToken = this.getJWTaccessToken();
      if (jwtAccessToken && this.isTokenExpiringSoon(jwtAccessToken)) {
        console.warn('Access token sur le point d\'expirer, tentative de renouvellement...');
        const newToken = await this.handleTokenRefresh();
        if (newToken) {
          headers['Authorization'] = `Bearer ${newToken}`;
        }
      }

      // Envoi de la requ√™te
      let response = await this.sendRequest(url, method, formData, headers);

       // Si la r√©ponse est un 401, on lit le JSON pour distinguer le type d'erreur
       // Gestion des erreurs d'authentification
       if (response.status === 401) {
        const data = await response.json(); // lecture unique
        if (data.error_code === 'not_authenticated') {
          showStatusMessage(data.message, 'error');
          navigateTo(data.redirect);
          return; // On arr√™te ici
        } else {
          response = await this.handleUnauthorized(url, method, formData, customHeaders);
        }
      } else if (response.status === 403) {
        const data = await response.json(); // lecture unique
        if (data.error_code === 'auth_partial_required') {
          showStatusMessage(data.message, 'error');
          navigateTo(data.redirect);
          return; // On arr√™te ici
        } else {
          throw new HTTPError(data.message || 'Erreur inconnue.', response.status, data.error_code);
        }
      }
      return await this.handleResponse(response);
    } catch (error) {
      if (error instanceof TypeError) {
        throw new NetworkError('√âchec r√©seau : ' + error.message);
      }
      throw error;
    }
  },

  /**
   * Pr√©pare les en-t√™tes de la requ√™te avec CSRF et JWT.
   * @returns {Object} - Les en-t√™tes pr√©par√©s.
   */
  prepareHeaders() {
    const headers = {
      'X-CSRFToken': this.getCSRFToken(),
    };

    const jwtAccessToken = this.getJWTaccessToken();
    if (jwtAccessToken) {
      headers['Authorization'] = `Bearer ${jwtAccessToken}`;
    }

    return headers;
  },

  /**
   * V√©rifie si le token expire dans moins de 5 minutes.
   * @param {string} token - Le token JWT.
   * @returns {boolean} - True si le token expire bient√¥t.
   */
  isTokenExpiringSoon(token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Math.floor(Date.now() / 1000);
      return payload.exp - currentTime < 300; // Moins de 5 minutes
    } catch (error) {
      console.error('Erreur lors de la v√©rification de l\'expiration du token :', error);
      return true;
    }
  },

  /**
   * Envoie une requ√™te fetch avec les param√®tres fournis.
   */
  async sendRequest(url, method, formData, headers) {
    return fetch(url, {
      method,
      headers,
      body: method !== 'GET' && formData instanceof FormData ? formData : undefined,
    });
  },

  /**
   * G√®re le cas d'une r√©ponse 401 en essayant de rafra√Æchir le token.
   */
  async handleUnauthorized(url, method, formData, customHeaders) {
    console.warn('Acc√®s non autoris√©, tentative de rafra√Æchissement du token...');
    const newAccessToken = await this.handleTokenRefresh();

    if (newAccessToken) {
      // Mise √† jour des en-t√™tes avec le nouveau token
      const updatedHeaders = {
        ...this.prepareHeaders(),
        ...customHeaders,
        'Authorization': `Bearer ${newAccessToken}`,
      };

      const response = await this.sendRequest(url, method, formData, updatedHeaders);
      if (!response.ok) {
        throw new HTTPError(
          response.statusText || '√âchec apr√®s rafra√Æchissement du token',
          response.status
        );
      }
      return response;
    } else {
      throw new HTTPError('Impossible de rafra√Æchir le token.', 401);
    }
  },

  /**
   * Rafra√Æchit le token d'acc√®s en utilisant le refresh token.
   */
  async handleTokenRefresh() {
    const jwtRefreshToken = this.getJWTrefreshToken();
    if (!jwtRefreshToken) {
      console.error('Aucun refresh token disponible.');
      return null;
    }

    try {
      const response = await fetch('/accounts/refreshJwt/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': this.getCSRFToken(),
        },
        body: JSON.stringify({ refresh_token: jwtRefreshToken }),
      });

      if (response.ok) {
        const data = await response.json();
        const newAccessToken = data.access_token;
        localStorage.setItem('access_token', newAccessToken);
        return newAccessToken;
      } else {
        console.error('Erreur lors du rafra√Æchissement du token :', response.statusText);
        return null;
      }
    } catch (error) {
      console.error('√âchec du rafra√Æchissement du token :', error);
      return null;
    }
  },

  /**
   * G√®re la r√©ponse fetch en fonction du type de contenu.
   */
  async handleResponse(response) {
    const contentType = response.headers.get('Content-Type');

    if (response.ok && contentType && contentType.includes('application/json')) {
      return response.json();
    } else if (!response.ok && contentType && contentType.includes('application/json'))
    {

        if (response.status === 302) {
            console.warn('Redirection d√©tect√©e :', response.url);
            navigateTo(response.url);
            return; // On ne retourne pas de donn√©e
          }
          console.log("response", response);
        const errorData = await response.json();
        throw new HTTPError(errorData.message || 'Erreur inconnue.', response.status);
    } else {
      console.log("response", response);
      throw new HTTPError('R√©ponse inattendue.', response.status);
    }
  },

  // --- Fonctions utilitaires pour la gestion des tokens ---

  getCSRFToken() {
    const cookie = document.cookie.split(';').find(c => c.trim().startsWith('csrftoken='));
    return cookie ? cookie.trim().substring('csrftoken='.length) : '';
  },

  getJWTaccessToken() {
    return localStorage.getItem('access_token') || null;
  },

  getJWTrefreshToken() {
    return localStorage.getItem('refresh_token') || null;
  },

  // --- M√©thodes pour les requ√™tes HTTP sp√©cifiques ---

  async get(url) {
    return this.request(url, 'GET');
  },

  async post(url, formData) {
    return this.request(url, 'POST', formData);
  },

  async put(url, formData) {
    return this.request(url, 'PUT', formData);
  },

  async delete(url) {
    return this.request(url, 'DELETE');
  }
};

// --- Fonctions export√©es pour simplifier les appels dans d'autres fichiers ---

export async function requestGet(app, view) {
  const url = `/${app}/${view}/`;
  try {
    return await Api.get(url);
  } catch (error) {
    console.error(`Erreur lors du chargement de ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestPost(app, view, formData) {
  const url = `/${app}/${view}/`;
  console.log('POST request URL:', url);
  try {
    return await Api.post(url, formData);
  } catch (error) {
    console.error(`Erreur lors du chargement de ${app}-${view} :`, error);
    throw error;
  }
}

export async function requestDelete(app, view, ressourceId) {
  const url = `/${app}/${view}/${ressourceId}/`;
  try {
    return await Api.delete(url);
  } catch (error) {
    console.error(`Erreur lors de la suppression de ${app}-${view} avec ID ${ressourceId} :`, error);
    throw error;
  }
}

===== ./auth/2fa/2faDisable.js =====
import { requestGet, requestPost } from '/static/js/api/index.js';
import { updateHtmlContent, showStatusMessage } from '/static/js/tools/index.js';
import { navigateTo } from '/static/js/router.js';



// Fonction pour charger la vue de d√©sactivation de la 2FA
async function loadDisable2FAView() {
    console.log('Chargement de la vue de d√©sactivation de la 2FA...');
    try {
        const response = await requestGet('accounts', '2fa/disable');
        if (!response) {
            return false;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html);
            attachDisable2FAEvent(); // Attache l'√©v√©nement de soumission
        } else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue de d√©sactivation de la 2FA.');
        }
    } catch (error) {
        console.error('Erreur dans loadDisable2FAView:', error);
        showStatusMessage('Impossible de charger la vue de d√©sactivation de la 2FA.', 'error');
        throw error; // Propagation de l'erreur pour gestion dans handleDisable2FA
    }
}

// Fonction pour attacher l'√©v√©nement de soumission au formulaire
function attachDisable2FAEvent() {
    const disable2FAForm = document.querySelector('#disable-2fa-form');
    if (disable2FAForm) {
        disable2FAForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            try {
                await submitDisable2FA(disable2FAForm);
            } catch (error) {
                console.error('Erreur dans submitDisable2FA:', error);
                showStatusMessage('Une erreur est survenue lors de la soumission. Veuillez r√©essayer.', 'error');
            }
        });
    } else {
        console.error('Formulaire de d√©sactivation 2FA introuvable.');
        showStatusMessage('Formulaire de d√©sactivation introuvable. Veuillez r√©essayer.', 'error');
    }
}

// Fonction pour soumettre le formulaire de d√©sactivation de la 2FA
async function submitDisable2FA(form) {
    const formData = new FormData(form);
    console.log('Soumission du formulaire de d√©sactivation de la 2FA...');
    try {
        const response = await requestPost('accounts', '2fa/disable', formData);
        if (response.status === 'success') {
            showStatusMessage('La 2FA a √©t√© d√©sactiv√©e avec succ√®s.', 'success');
             // üî• Ajout de la redirection apr√®s d√©sactivation r√©ussie
             setTimeout(() => {
                console.log('setTimeout ex√©cut√©, on appelle navigateTo("/account")');
                navigateTo('/account'); // Redirige apr√®s 2 secondes
            }, 2000);
        } else {
            throw new Error(response.message || '√âchec de la d√©sactivation de la 2FA.');
        }
    } catch (error) {
        console.error('Erreur dans submitDisable2FA:', error);
        showStatusMessage('Une erreur est survenue lors de la d√©sactivation de la 2FA.', 'error');
        throw error;
    }
}

// Gestionnaire principal pour d√©sactiver la 2FA
export async function handleDisable2FA() {
    console.log('D√©sactivation de la 2FA...');
    let disable2fa;
    try {
        // Charge la vue de d√©sactivation de la 2FA
        disable2fa = await loadDisable2FAView();
    } catch (error) {
        console.error('Erreur dans handleDisable2FA:', error);
        showStatusMessage('Erreur lors de la d√©sactivation de la 2FA.', 'error');
    }
    if (!disable2fa) {
        return;
    }
}

===== ./auth/2fa/2faEnable.js =====
import { navigateTo } from '/static/js/router.js';
import { requestGet, requestPost } from '/static/js/api/index.js';
import { updateHtmlContent, showStatusMessage } from '/static/js/tools/index.js';

// Gestionnaire principal pour activer la 2FA
export async function handleEnable2FA() {
    console.log('Activation de la 2FA...');
    let enable2FALoaded;
    try {
        enable2FALoaded = await loadEnable2FAView(); // Charge la vue d'activation de la 2FA
    } catch (error) {
        console.error('Erreur dans handleEnable2FA:', error);
        showStatusMessage('Erreur lors de l\'activation de la 2FA.', 'error');
    }

    if (!enable2FALoaded) {
        return;
    }
}

// Fonction pour charger la vue d'activation de la 2FA
async function loadEnable2FAView() {
    try {
        const response = await requestGet('accounts', '2fa/enable');
        if (!response) {
            return false;
        }
        if (response.status === 'success' && response.html) {
            updateHtmlContent('#content', response.html); // Met √† jour la vue

            // Attache l'√©v√©nement de v√©rification
            attach2FAVerificationEvent();
        } else {
            throw new Error(response.message || 'Erreur lors du chargement de la vue 2FA.');
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la vue 2FA:', error);
        showStatusMessage('Impossible de charger la vue d\'activation de la 2FA.', 'error');
        throw error;
    }
}

// Fonction pour g√©rer la soumission du formulaire de v√©rification 2FA
async function verification2FA(event) {
    event.preventDefault(); // Emp√™che le comportement par d√©faut

    console.log('Soumission du formulaire de v√©rification 2FA...');
    const form = event.target;
    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', '2fa/check', formData);
        if (response.status === 'success') {
            showStatusMessage('2FA activ√©e avec succ√®s.', 'success');
             // üî• Ajout de la redirection apr√®s activation r√©ussie
             setTimeout(() => {
                console.log('setTimeout ex√©cut√©, on appelle navigateTo("/account")');
                navigateTo('/account'); // Redirige apr√®s 2 secondes (pour voir le message)
            }, 2000);
        } else {
            throw new Error(response.message || 'Code 2FA incorrect.');
        }
    } catch (error) {
        console.error('Erreur lors de la v√©rification 2FA:', error);
        showStatusMessage('Une erreur est survenue lors de la v√©rification 2FA.', 'error');
        throw error;
    }
}

// Fonction pour attacher l'√©v√©nement de v√©rification
function attach2FAVerificationEvent() {
    const verifyForm = document.querySelector('#verify-2fa-form');
    if (verifyForm) {
        verifyForm.addEventListener('submit', async (event) => {
            try {
                await verification2FA(event); // G√®re la soumission du formulaire
            } catch (error) {
                console.error('Erreur lors de la v√©rification 2FA dans attach2FAVerificationEvent:', error);
                showStatusMessage('Une erreur est survenue lors de la v√©rification 2FA.', 'error');
            }
        });
        console.log('√âv√©nement de v√©rification 2FA attach√©.');
    } else {
        console.error('Formulaire de v√©rification 2FA introuvable.');
        showStatusMessage('Formulaire de v√©rification introuvable. Veuillez r√©essayer.', 'error');
    }
}

===== ./auth/2fa/2faLogin.js =====
import { requestPost, requestGet } from '../../api/index.js';
import { handleNavbar } from '../../navbar/index.js'; // Adjust the import path as necessary
import { updateHtmlContent, showStatusMessage } from '../../tools/index.js'; // Adjust the import path as necessary
import { navigateTo } from '../../router.js';

// Soumission du formulaire de connexion 2FA
async function submitLogin2FA(form) {
    const formData = new FormData(form);
    try {
        const response = await requestPost('accounts', '2fa/login2fa', formData);
        if (response.status === 'success') {
            console.log("2FA activ√©e avec succ√®s");
            localStorage.setItem('access_token', response.access_token);
            localStorage.setItem('refresh_token', response.refresh_token);

            setTimeout(async () => {
                window.isAuthenticated = true;
                await handleNavbar();
                navigateTo('/home');
            }, 500);
            showStatusMessage('Connexion 2FA r√©ussie.', 'success');
        } else {
            throw new Error(response.message || 'Code 2FA incorrect.');
        }
    } catch (error) {
        console.error('Erreur lors de la soumission 2FA:', error);
        showStatusMessage(error.message || 'Une erreur est survenue lors de la connexion 2FA.', 'error');
    }
}

// Initialisation de la vue de connexion 2FA
export async function initializeLogin2FAView() {

    try {
        const data = await requestGet('accounts', '2fa/login2fa');
        if (!data) {
            return;
        }
        updateHtmlContent('#content', data.html);
    } catch (error) {
        console.error('Erreur lors de la requ√™te API initializeLogin2FAView:', error);
        showStatusMessage('Impossible de charger la vue de connexion 2FA.', 'error');
        return;
    }

    document.addEventListener('submit', function (e) {
        if (e.target && e.target.id === 'login-2fa-form') {
            e.preventDefault();
            submitLogin2FA(e.target);
        }
    });
}

===== ./auth/index.js =====
// auth/index.js

// Fonctions de d√©connexion et suppression de compte
// Appelle une fonction g√©n√©rique pour nettoyer la session utilisateur
export { handleLogout} from './logout.js';
export { handleDeleteAccount } from './deleteAccount.js';

export { handleLogin } from './login.js';
export { initializeRegisterView } from './register.js';


// Export des vues 2FA
export { handleEnable2FA} from './2fa//2faEnable.js';
export { initializeLogin2FAView } from './2fa/2faLogin.js';
export { handleDisable2FA } from './2fa/2faDisable.js';

===== ./auth/deleteAccount.js =====
import { requestPost } from '../api/index.js';
import { clearSessionAndUI, showStatusMessage} from '../tools/index.js';

// Charge et affiche la modale de suppression
async function loadDeleteAccountView() {
    console.log('Chargement de la vue de suppression...');
    try {
        const modal = document.getElementById('delete-account-modal');
        if (!modal) {
            throw new Error('La modale de suppression du compte est introuvable.');
        }
        modal.style.display = 'flex'; // Affiche la modale
    } catch (error) {
        console.error('Erreur dans loadDeleteAccountView:', error);
        showStatusMessage('Impossible de charger la vue de suppression. Veuillez r√©essayer.', 'error');
        throw error;
    }
}

// Attache les √©v√©nements n√©cessaires √† la modale de suppression
async function attachDeleteAccountEvents() {
    console.log('Attachement des √©v√©nements pour la suppression du compte...');
    try {
        const modal = document.getElementById('delete-account-modal');
        const closeBtn = modal.querySelector('.close-btn');
        const deleteAccountForm = document.getElementById('delete-account-form');

        // Fermer la modale via le bouton de fermeture
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });
        }

        // Fermer la modale en cliquant en dehors de son contenu
        window.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Gestion de la soumission du formulaire de suppression
        if (deleteAccountForm) {
            deleteAccountForm.addEventListener('submit', async (event) => {
                event.preventDefault(); // Emp√™che le comportement par d√©faut
                await submitDeleteAccount(deleteAccountForm);
            });
        }
    } catch (error) {
        console.error('Erreur dans attachDeleteAccountEvents:', error);
        showStatusMessage('Erreur lors de l\'attachement des √©v√©nements de suppression.', 'error');
        throw error;
    }
}

// Soumet la requ√™te de suppression de compte
async function submitDeleteAccount(form) {
    const formData = new FormData(form);
    console.log('Soumission du formulaire de suppression de compte...');

    try {
        const response = await requestPost('accounts', 'profile/delete_account', formData);

        if (response.status !== 'success') {
            console.error('Erreur serveur :', response.message);
            showStatusMessage(response.message || 'Erreur lors de la suppression du compte.', 'error');
            return;
        }

        showStatusMessage('Votre compte a √©t√© supprim√© avec succ√®s.', 'success');

        setTimeout(() => {
            clearSessionAndUI();
        }, 1500);
    } catch (error) {
        console.error('Erreur lors de la soumission de la suppression du compte :', error);
        showStatusMessage('Une erreur est survenue. Veuillez r√©essayer.', 'error');
    }
}

// Gestionnaire principal pour la suppression de compte
export async function handleDeleteAccount() {
    console.log('Suppression du compte...');
    try {
        await loadDeleteAccountView(); // Charge et affiche la modale de suppression
        await attachDeleteAccountEvents();
    } catch (error) {
        console.error('Erreur dans handleDeleteAccount:', error);
        showStatusMessage('Erreur lors de la tentative de suppression du compte.', 'error');
    }
}

===== ./auth/logout.js =====
import { clearSessionAndUI, showStatusMessage } from '../tools/index.js';
import { requestPost } from '../api/index.js';

async function logoutUser() {
    try {
        const formData = new FormData();
        const refreshToken = localStorage.getItem('refresh_token');
        if (!refreshToken) {
            throw new Error('Aucun refresh token trouv√©.');
        }
        formData.append('refresh_token', refreshToken);
        const response = await requestPost('accounts', 'logout', formData);

        if (response.status !== 'success') {
            throw new Error('La d√©connexion a √©chou√© c√¥t√© serveur.');
        }
        return response;
    } catch (error) {
        console.error('Erreur lors de logoutUser :', error);
        throw error;
    }
}

export async function handleLogout() {
    console.log('D√©connexion en cours...');
    try {
        await logoutUser();
        showStatusMessage('Votre compte a √©t√© d√©connect√© avec succ√®s.', 'success');
        setTimeout(() => {
            clearSessionAndUI();
        }, 1500);
        console.log('D√©connexion r√©ussie.');
    } catch (error) {
        console.error('Erreur lors de la d√©connexion :', error);
        showStatusMessage('La d√©connexion a √©chou√©. Veuillez r√©essayer.', 'error');
    }
}

===== ./auth/register.js =====
// auth/register.js
import { requestPost, requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

function handleRegisterResponse(response) {
    if (response.status === 'success') {
        showStatusMessage(response.message, 'success');
        navigateTo('/login');
    } else {
        showStatusMessage(response.message, 'error');
    }
}

async function submitRegistration(form) {
    const submitBtn = document.querySelector('#submit-btn');
    submitBtn.disabled = true;
    submitBtn.textContent = 'Inscription en cours...';

    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', 'submit_register', formData);
        console.log('R√©ponse de la requ√™te POST submit_register :', response);
        handleRegisterResponse(response);
        
    } catch (error) {
        console.error('Erreur lors de l\'inscription :', error);
        showStatusMessage('Une erreur est survenue lors de l\'inscription. Veuillez r√©essayer.', 'error');
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'S\'inscrire';
    }
}

// MAIN FUNCTION
export async function initializeRegisterView() {
    console.log('initializeRegisterView');

    try {
        const data = await requestGet('accounts', 'register');
        updateHtmlContent('#content', data.html);

        const form = document.querySelector('#register-form');
        if (form) {
            form.addEventListener('submit', (e) => {
                e.preventDefault();
                submitRegistration(form);
            });
        }
    } catch (error) {
        console.error('Erreur lors de la requ√™te API initializeRegisterView :', error);
        showStatusMessage('Impossible de charger la vue d\'inscription. Veuillez r√©essayer.', 'error');
    }
}

===== ./auth/login.js =====
import { requestGet, requestPost } from '../api/index.js';
import { handleNavbar } from '../navbar/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer


async function handleLoginResponse(response) {
    console.log('handleLoginResponse');
    if (response.status === 'success') {
        if (response.requires_2fa) {
            navigateTo('/login-2fa');
        } else {
            console.log("Access token = ", response.access_token);
            localStorage.setItem('access_token', response.access_token);
            localStorage.setItem('refresh_token', response.refresh_token);

            setTimeout(async () => {
                window.isAuthenticated = true;
                console.log("handleloginResponse isauthenticated = :", window.isAuthenticated)
                await handleNavbar();
                navigateTo('/home');
            }, 500);
        }
    } else {
        showStatusMessage(response.message, 'error');
    }
}

async function submitLogin(form) {
    console.log('submitLogin');
    const validateBtn = document.querySelector('#validate-btn');
    validateBtn.disabled = true;
    validateBtn.textContent = 'Connexion...';

    const formData = new FormData(form);

    try {
        const response = await requestPost('accounts', 'submit_login', formData);
        console.log('R√©ponse de la requ√™te POST submit_login :', response);
        return response;
    } catch (error) {
        console.error('Erreur lors de la connexion :', error);
        showStatusMessage('Une erreur est survenue. Veuillez r√©essayer.', 'error');
        return null;
    } finally {
        validateBtn.disabled = false;
        validateBtn.textContent = 'Valider';
    }
}

async function initializeLoginForm() {
    try {
        const data = await requestGet('accounts', 'login');
        updateHtmlContent('#content', data.html);

        const form = document.querySelector('#login-form');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('Soumission du formulaire de connexion');
                const response = await submitLogin(form);
                if (response) {
                    await handleLoginResponse(response);
                }
            });
        }
    } catch (error) {
        console.error('Erreur lors de l\'initialisation du formulaire :', error);
        showStatusMessage('Impossible de charger la vue de connexion. Veuillez r√©essayer.', 'error');
    }
}

export async function handleLogin() {
    
    try {
        console.log('Initialisation de la vue de connexion');
        await initializeLoginForm();
        console.log('Vue de connexion initialis√©e avec succ√®s');
    } catch (error) {
        console.error('Erreur dans handleLogin :', error);
        showStatusMessage('Erreur lors de l\'initialisation de la connexion.', 'error');
    }
}

===== ./burgerMenu/events.js =====


import { 
    showFriendPopup, 
    closePopupOnClickOutside, 
    handleOptionPopup,  
    handleAddFriend, 
    handleFriendInvitation  
} from '../friends/index.js';

import { handleStatusChange } from './index.js';
import { handleLogout } from '../auth/index.js';
import { navigateTo } from '../router.js';
import { acceptGameInvitation } from '../game/index.js';
import { declineGameInvitation } from '../game/onlineGame.js';

/**
 * Gestionnaire principal des √©v√©nements pour le menu burger via event delegation.
 * - Attache un seul listener "click" sur #burger-menu-container.
 * - G√®re aussi le "submit" du formulaire d'ajout d'amis.
 */
export function eventsHandlerBurgerMenu() {
    console.log('Initialisation des gestionnaires d\'√©v√©nements (event delegation)...');

    // 1. R√©cup√©rer le conteneur principal du burger menu
    const container = document.getElementById('burger-menu-container');
    if (!container) {
        console.warn("Impossible de trouver #burger-menu-container, annulation des events burger.");
        return;
    }

    // 2. Attacher UN SEUL listener "click" si pas d√©j√† fait
    if (!container.dataset.bound) {
        container.addEventListener('click', handleBurgerMenuClick);
        container.dataset.bound = 'true';
        console.log("Listener 'click' sur #burger-menu-container initialis√©.");
    }

    // 3. G√©rer la soumission du formulaire d'ajout d'amis (√©v√©nement "submit" distinct)
    const addFriendForm = document.querySelector('#add-friend-form');
    if (addFriendForm && !addFriendForm.dataset.bound) {
        addFriendForm.addEventListener('submit', handleAddFriend);
        addFriendForm.dataset.bound = 'true';
        console.log("Event 'submit' pour #add-friend-form attach√©.");
    }

    // 4. G√©rer la fermeture du popup d'ami au clic en dehors (hors du container burger)
    //    Ici, on peut √©couter sur document ou sur un autre √©l√©ment.
    const popup = document.getElementById('friendPopup');
    if (popup && !popup.dataset.bound) {
        document.addEventListener('click', closePopupOnClickOutside);
        popup.dataset.bound = 'true';
        console.log("Listener 'click' pour fermer le friendPopup en dehors.");
    }

    console.log('Event delegation pour le burger menu : termin√©.');
}

/**
 * Fonction centrale qui g√®re tous les clics √† l'int√©rieur de #burger-menu-container.
 */
function handleBurgerMenuClick(e) {
    // 1. Changement de statut (en ligne/hors ligne)
    //    Les boutons ont la classe .status-selector et un data-status
    if (e.target.matches('.status-selector button[data-status]')) {
        const status = e.target.dataset.status;
        if (status) handleStatusChange(status);
        return;
    }

    // 2. Bouton "Voir le profil" (#profile-btn)
    if (e.target.matches('#profile-btn')) {
        e.preventDefault();
        console.log('Profil bouton cliqu√©');
        navigateTo('/profile');
        return;
    }

    // 3. Navigation : Jouer (#play-btn), Tournoi (#tournament-link), Param√®tres (#settings-link)
    if (e.target.matches('#play-btn')) {
        e.preventDefault();
        navigateTo('/game-options');
        return;
    }
    if (e.target.matches('#settings-link')) {
        e.preventDefault();
        navigateTo('/account');
        return;
    }

    // 4. Liste d'amis -> .friend-btn
    //    e.target.closest('.friend-btn') => ouvre un popup
    const friendButton = e.target.closest('.friend-btn');
    if (friendButton) {
        showFriendPopup(e, friendButton.innerText.trim());
        return;
    }

    // 5. Invitations d'amis (#friend-requests-list-container) -> bouton[data-request-id]
    //    on r√©cup√®re l'ID et l'action (accepter/refuser)
    const friendRequestButton = e.target.closest('#friend-requests-list-container button[data-request-id]');
    if (friendRequestButton) {
        const requestId = friendRequestButton.getAttribute('data-request-id');
        const action = friendRequestButton.getAttribute('data-action');
        if (requestId) {
            handleFriendInvitation(requestId, action);
        }
        return;
    }

    // 6. Invitations de jeu (#game-invitations-list-container) -> bouton[data-invitation-id]
    const gameInvitationButton = e.target.closest('#game-invitations-list-container button[data-invitation-id]');
    if (gameInvitationButton) {
        const invitationId = gameInvitationButton.getAttribute('data-invitation-id');
        const action = gameInvitationButton.getAttribute('data-action');
        if (invitationId && action === 'accept') {
            acceptGameInvitation(invitationId, action);
        }
        else {
            declineGameInvitation(invitationId);
        }
        return;
    }

    // 7. Boutons du popup d'ami (voir profil, inviter √† jouer, supprimer) => #view-profile-btn, #invite-to-play-btn, #remove-friend-btn
    if (e.target.matches('#view-profile-btn')) {
        handleOptionPopup('Voir le profil');
        return;
    }
    if (e.target.matches('#invite-to-play-btn')) {
        handleOptionPopup('Inviter √† jouer');
        return;
    }
    if (e.target.matches('#remove-friend-btn')) {
        handleOptionPopup('Supprimer');
        return;
    }

    // 8. Bouton de d√©connexion (#logout-btn)
    if (e.target.matches('#logout-btn')) {
        e.preventDefault();
        handleLogout();
        return;
    }

    // Si aucun des cas ci-dessus n'est match√©, on ne fait rien de particulier.
    // console.log("Clic dans burger-menu-container, mais cible non g√©r√©e:", e.target);
}

===== ./burgerMenu/index.js =====
export { eventsHandlerBurgerMenu } from "./events.js";
export { handleStatusChange } from "./setupStatus.js";

===== ./burgerMenu/setupStatus.js =====
import { requestPost } from '../api/index.js';
import { refreshBurgerMenu } from '../navbar/loadNavbar.js';
import { showStatusMessage } from '../tools/index.js';

async function updateUserStatus(status) {
    console.log('Mise √† jour du statut utilisateur :', status);

    const formData = new FormData();
    formData.append('status', status);

    try {
        const response = await requestPost('accounts', 'burgerMenu/update-status', formData);
        if (response.status !== 'success') {
            throw new Error(response.message || 'Erreur inconnue lors de la mise √† jour du statut.');
        }
        console.log(`Statut mis √† jour avec succ√®s : ${status}`);
        return response; // Retourne la r√©ponse pour une √©ventuelle utilisation
    } catch (error) {
        console.error('Erreur dans updateUserStatus :', error);
        throw error; // Relance l'erreur pour la g√©rer ailleurs
    }
}

// Improve ajouter un refresh burger menu
export async function handleStatusChange(status) {
    try {
        await updateUserStatus(status);
        showStatusMessage('Statut mis √† jour avec succ√®s.', 'success');
        console.log('Statut mis √† jour avec succ√®s dans l\'interface utilisateur.');
    } catch (error) {
        console.error('Erreur lors de la mise √† jour du statut :', error);
        showStatusMessage('Impossible de mettre √† jour le statut. Veuillez r√©essayer.', 'error');
    }
    await refreshBurgerMenu();//added
}

===== ./friends/friendsAction/friendsInvitations.js =====
import { requestPost } from '../../api/index.js';
import {showStatusMessage} from '../../tools/index.js';

async function friendInvitation(requestId, action) {
    console.log(`handleFriendRequestAction: Demande d'ami ID ${requestId}, action : ${action}`);

    const formData = new FormData();
    formData.append('request_id', requestId);
    formData.append('action', action);

    try {
        const response = await requestPost('accounts', 'friends/handle-request', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors du traitement de la demande d\'ami.';
            console.error('Erreur dans friendInvitation:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Erreur dans friendInvitation:', error);
        throw error;
    }
}

export async function handleFriendInvitation(requestId, action) {
    console.log(`Gestionnaire: handleFriendRequest - ID : ${requestId}, action : ${action}`);
    try {
        const response = await friendInvitation(requestId, action);
        showStatusMessage(response.message || 'Demande d\'ami trait√©e avec succ√®s.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Erreur lors du traitement de la demande d\'ami.';
        console.error('Erreur dans handleFriendInvitation:', error);
        showStatusMessage(errorMessage, 'error');
    }
}
===== ./friends/friendsAction/friendProfile.js =====
import { requestGet } from '../../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../../tools/index.js';


async function FriendProfile(friendName) {
    try {
        console.log(`Chargement du profil de l'ami : ${friendName}`);
        const response = await requestGet('accounts', `friend/${friendName}`);

        if (!response) {
            return;
        }
        if (response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors de la r√©cup√©ration du profil.';
            console.error('Erreur dans FriendProfile :', errorMessage);
            throw new Error(errorMessage);
        }

        updateHtmlContent('#content', response.html);
        return response.message;
    } catch (error) {
        console.error('Erreur dans FriendProfile :', error);
        throw error;
    }
}

export async function handleFriendProfile(friendName) {
    console.log(`Gestionnaire: Affichage du profil de l'ami ${friendName}`);

    try {
        const response = await FriendProfile(friendName);
        if (!response) {
            return;
        }
        showStatusMessage(response || 'Profil de l\'ami charg√© avec succ√®s.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Erreur lors de la r√©cup√©ration du profil.';
        console.error('Erreur dans handleFriendProfile :', error);
        showStatusMessage(errorMessage, 'error');
    }
}

===== ./friends/friendsAction/addFriend.js =====
import { requestPost } from '../../api/index.js';
import { showStatusMessage } from '../../tools/index.js';

async function addFriend(friendUsername) {
    console.log('addFriend:', friendUsername);

    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    try {
        const response = await requestPost('accounts', 'friends/add', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur inconnue lors de l\'ajout de l\'ami.';
            console.error('Erreur dans addFriend:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Exception dans addFriend:', error);
        throw error; // Relance l'erreur pour qu'elle soit g√©r√©e ailleurs
    }
}

export async function handleAddFriend(e) {
    e.preventDefault();
    console.log('Gestionnaire: handleAddFriend - Ajout d\'un ami');
    const friendUsernameInput = document.querySelector('#friend-username');
    const addFriendButton = document.querySelector('#add-friend-button'); // S√©lectionnez le bouton d'ajout d'ami

    if (!friendUsernameInput || !addFriendButton) {
        showStatusMessage('Champ utilisateur ou bouton introuvable.', 'error');
        return;
    }

    const friendUsername = friendUsernameInput.value.trim();

    if (!friendUsername) {
        showStatusMessage('Le nom d\'utilisateur ne peut pas √™tre vide.', 'error');
        return;
    }

    console.log('Gestionnaire: handleAddFriend - Ajout d\'un ami:', friendUsername);

    try {
        addFriendButton.disabled = true; // D√©sactivez le bouton pendant la soumission
        await addFriend(friendUsername);
        showStatusMessage('Demande d\'ami envoy√©e avec succ√®s.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Une erreur inattendue est survenue.';
        console.error('Erreur dans handleAddFriend:', error);
        showStatusMessage(errorMessage, 'error');
    } finally {
        addFriendButton.disabled = false; // R√©activez le bouton apr√®s la soumission
    }
}

===== ./friends/friendsAction/removeFriend.js =====
import { requestPost } from '../../api/index.js';
import {showStatusMessage} from '../../tools/index.js';

async function removeFriend(friendName) {
    console.log(`removeFriend: Suppression de l'ami ${friendName}`);

    const formData = new FormData();
    formData.append('friend_username', friendName);

    try {
        const response = await requestPost('accounts', 'friends/remove', formData);
        if (!response || response.status !== 'success') {
            const errorMessage = response?.message || 'Erreur lors de la suppression de l\'ami.';
            console.error('Erreur dans removeFriend:', errorMessage);
            throw new Error(errorMessage);
        }
        return response;
    } catch (error) {
        console.error('Erreur dans removeFriend:', error);
        throw error;
    }
}

// export async function handleRemoveFriend(friendName) {
//     console.log(`Gestionnaire: handleRemoveFriend - Suppression de l'ami : ${friendName}`);
//     try {
//         const response = await removeFriend(friendName);
//         document.querySelector(`.friend-btn:contains('${friendName}')`)?.closest('.friend-item')?.remove();
//         showStatusMessage(response.message || 'Ami supprim√© avec succ√®s.', 'success');
//     } catch (error) {
//         const errorMessage = error?.message || 'Une erreur est survenue lors de la suppression de l\'ami.';
//         console.error('Erreur dans handleRemoveFriend:', error);
//         showStatusMessage(errorMessage, 'error');
//     }
// }
export async function handleRemoveFriend(friendName) {
    console.log(`Gestionnaire: handleRemoveFriend - Suppression de l'ami : ${friendName}`);
    try {
        const response = await removeFriend(friendName);
        
        // Select all elements with class '.friend-btn'
        const friendButtons = document.querySelectorAll('.friend-btn');
        
        // Loop through each friend button to find and remove the correct one
        friendButtons.forEach(button => {
            if (button.textContent.includes(friendName)) {
                button.closest('.friend-item').remove();
            }
        });
        
        showStatusMessage(response.message || 'Ami supprim√© avec succ√®s.', 'success');
    } catch (error) {
        const errorMessage = error?.message || 'Une erreur est survenue lors de la suppression de l\'ami.';
        console.error('Erreur dans handleRemoveFriend:', error);
        showStatusMessage(errorMessage, 'error');
    }
}
===== ./friends/index.js =====

// Fonction qui permet de g√©rer les actions li√©es aux amis
export { handleAddFriend } from "./friendsAction/addFriend.js";
export { handleFriendProfile } from "./friendsAction/friendProfile.js";
export { handleFriendInvitation } from "./friendsAction/friendsInvitations.js";
export { handleRemoveFriend } from "./friendsAction/removeFriend.js";

// Fonction qui permet de g√©rer les √©v√©nements li√©s au popup de la liste d'amis
export { handleOptionPopup } from "./popupFriend/handlePopupOption.js";

// Fonction qui permet de g√©rer la m√©canique du popup de la liste d'amis
export { showFriendPopup, closePopupOnClickOutside  } from "./popupFriend/popupMechanics.js";



===== ./friends/popupFriend/handlePopupOption.js =====
import {  handleRemoveFriend } from '../index.js';
import { navigateTo } from '../../router.js';

export function handleOptionPopup(option) {
    console.log('Option popup cliqu√©e' + option);
    const friendName = document.getElementById('popupFriendName').innerText.trim();
    console.log(`Option: ${option}, Friend: ${friendName}`); // Ajout de log

    if (option === 'Voir le profil') {
        const encodedName = encodeURIComponent(friendName);
        console.log(`Encoded friendName: ${encodedName}`);
        navigateTo(`/profile/${encodedName}`);
    } 
    else if (option === 'Inviter √† jouer') {

        console.log(`Option s√©lectionn√©e : ${option}`);
    }
    else if (option === 'Supprimer') {
        handleRemoveFriend(friendName);
    }
    else {
        console.error(`Option inconnue : ${option}`);
    }
}

===== ./friends/popupFriend/popupMechanics.js =====
// G√®re la m√©canique du popup d'ami

export function showFriendPopup(event, friendName) {
    event.stopPropagation();
    const popup = document.getElementById('friendPopup');
    document.getElementById('popupFriendName').innerText = friendName;

    popup.classList.remove('d-none');
    const popupWidth = popup.offsetWidth;
    const popupHeight = popup.offsetHeight;

    const menu = document.getElementById('burger-menu');

    let top, left;

	const menuRect = menu.getBoundingClientRect();
	const mouseX = event.clientX - menuRect.left + menu.scrollLeft;
	const mouseY = event.clientY - menuRect.top + menu.scrollTop;


	if (mouseX >= 240 && event.clientY <= 250) {
		top = mouseY + popupHeight;
		left = mouseX - (popupWidth / 2);
	} else if (mouseX <= 240 && event.clientY <= 250) {
		top = mouseY + popupHeight;
		left = mouseX + (popupWidth / 2);
	} else if (mouseX <= 240 && event.clientY >= 250) {
		top = mouseY;
		left = mouseX + (popupWidth / 2);
	} else {
		top = mouseY;
		left = mouseX - (popupWidth / 2);
	}
	
    popup.style.top = `${top}px`;
    popup.style.left = `${left}px`;
}

export function closePopupOnClickOutside(event) {
    const popup = document.getElementById('friendPopup');
    if (!popup.contains(event.target) && !event.target.closest('.friend-item')) {
        popup.classList.add('d-none');
    }
}


===== ./game/controls.js =====
// game/controls.js


export function initializeGameControls(controlType) {
    const player = document.querySelector('.player');
    const gameContainer = document.querySelector('.game-container');
    const tutorialBox = document.querySelector('.tutorial-box');
    let containerWidth = gameContainer.offsetWidth;
    let containerHeight = gameContainer.offsetHeight - 50;
    const collectibleCount = 9;
    const collectibles = [];
    let direction = { x: 1, y: 0 }; // Par d√©faut, d√©placement vers la droite
    const playerSpeed = 3;
    let playerX = 0;
    let playerY = containerHeight / 2 - 15; // Milieu vertical
    const keysPressed = {}; // Stocke les touches enfonc√©es
    let lastDiagonalDirection = null; // Stocke la derni√®re direction diagonale
    let touchStartX = null; // Stocke la position X du toucher initial
    let touchStartY = null; // Stocke la position Y du toucher initial

    // Calcul des dimensions de la box
    const tutorialRect = {
        left: 0,
        top: 0,
        right: tutorialBox.offsetWidth,
        bottom: tutorialBox.offsetHeight,
    };

    // Initialisation de la position du joueur
    player.style.left = `${playerX}px`;
    player.style.top = `${playerY}px`;

    // Fonction pour √©viter que les collectibles ne sortent du conteneur pendant un redimensionnement
	function updateContainerDimensions() {
		containerWidth = gameContainer.offsetWidth;
		containerHeight = gameContainer.offsetHeight - 50;
	
		// Mettre √† jour les dimensions dynamiques de la tutorial-box
		tutorialRect.left = tutorialBox.offsetLeft;
		tutorialRect.top = tutorialBox.offsetTop;
		tutorialRect.right = tutorialBox.offsetLeft + tutorialBox.offsetWidth;
		tutorialRect.bottom = tutorialBox.offsetTop + tutorialBox.offsetHeight;
	
		// R√©ajuster les collectibles pour rester dans les limites du conteneur
		collectibles.forEach((collectible) => {
			let collectibleX = parseFloat(collectible.style.left);
			let collectibleY = parseFloat(collectible.style.top);
	
			// Si le collectible est hors des nouvelles limites, repositionner
			if (collectibleX + 30 > containerWidth) {
				collectibleX = containerWidth - 30;
			}
			if (collectibleY + 30 > containerHeight) {
				collectibleY = containerHeight - 30;
			}
	
			// Si le collectible est dans la zone de la tutorial-box
			if (
				collectibleX + 30 > tutorialRect.left &&
				collectibleX < tutorialRect.right &&
				collectibleY + 30 > tutorialRect.top &&
				collectibleY < tutorialRect.bottom
			) {
				// R√©positionner autour de la tutorial-box en fonction de l‚Äôespace disponible
				const spaceLeft = tutorialRect.left;
				const spaceRight = containerWidth - tutorialRect.right;
				const spaceTop = tutorialRect.top;
				const spaceBottom = containerHeight - tutorialRect.bottom;
	
				if (spaceRight >= 30) {
					// Place le collectible √† droite
					collectibleX = tutorialRect.right + 1;
					collectibleY = Math.random() * (containerHeight - 30);
					collectibleY = Math.max(
						Math.min(collectibleY, containerHeight - 30),
						0
					);
				} else if (spaceLeft >= 30) {
					// Place le collectible √† gauche
					collectibleX = tutorialRect.left - 30 - 1;
					collectibleY = Math.random() * (containerHeight - 30);
					collectibleY = Math.max(
						Math.min(collectibleY, containerHeight - 30),
						0
					);
				} else if (spaceBottom >= 30) {
					// Place le collectible en bas
					collectibleY = tutorialRect.bottom + 1;
					collectibleX = Math.random() * (containerWidth - 30);
					collectibleX = Math.max(
						Math.min(collectibleX, containerWidth - 30),
						0
					);
				} else if (spaceTop >= 30) {
					// Place le collectible en haut
					collectibleY = tutorialRect.top - 30 - 1;
					collectibleX = Math.random() * (containerWidth - 30);
					collectibleX = Math.max(
						Math.min(collectibleX, containerWidth - 30),
						0
					);
				} else {
					// Si aucune place n'est disponible, masquer le collectible
					collectible.style.display = 'none';
					return;
				}
			}
	
			// V√©rifier que le collectible reste dans les limites visibles du conteneur
			collectibleX = Math.min(
				Math.max(collectibleX, 0),
				containerWidth - 30
			);
			collectibleY = Math.min(
				Math.max(collectibleY, 0),
				containerHeight - 30
			);
	
			// Appliquer les nouvelles positions
			collectible.style.left = `${collectibleX}px`;
			collectible.style.top = `${collectibleY}px`;
	
			// Si l'√©cran est tellement r√©duit que seule la tutorial-box est visible
			if (
				containerWidth <= tutorialRect.right &&
				containerHeight <= tutorialRect.bottom
			) {
				collectible.style.display = 'none'; // Cacher les collectibles
			} else {
				collectible.style.display = ''; // R√©afficher normalement sinon
			}
		});
	
		// Maintenir le joueur dans les limites du conteneur
		if (playerX + player.offsetWidth > containerWidth) {
			playerX = containerWidth - player.offsetWidth;
		}
		if (playerY + player.offsetHeight > containerHeight) {
			playerY = containerHeight - player.offsetHeight;
		}
		if (playerX < 0) {
			playerX = 0;
		}
		if (playerY < 0) {
			playerY = 0;
		}
	
		player.style.left = `${playerX}px`;
		player.style.top = `${playerY}px`;
	}
	

    function createCollectibles() {
        collectibles.forEach((col) => col.remove()); // Supprime les collectibles existants
        collectibles.length = 0;

        for (let i = 0; i < collectibleCount; i++) {
            let collectible;
            let isValidPosition = false;

            while (!isValidPosition) {
                collectible = document.createElement('div');
                collectible.className = 'collectible';
                const randomX = Math.random() * (containerWidth - 30);
                const randomY = Math.random() * (containerHeight - 30);

                // V√©rifie que le collectible n'est pas dans la zone de la tutorial-box
                if (
                    !(
                        randomX >= tutorialRect.left &&
                        randomX <= tutorialRect.right &&
                        randomY >= tutorialRect.top &&
                        randomY <= tutorialRect.bottom
                    )
                ) {
                    isValidPosition = true;
                    collectible.style.left = `${randomX}px`;
                    collectible.style.top = `${randomY}px`;
                    gameContainer.appendChild(collectible);
                    collectibles.push(collectible);
                }
            }
        }
    }

    function movePlayer() {
        const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
        const normalizedDirection = {
            x: (direction.x / length) * playerSpeed,
            y: (direction.y / length) * playerSpeed,
        };

        playerX += normalizedDirection.x;
        playerY += normalizedDirection.y;

        if (playerX < 0) {
            playerX = containerWidth - player.offsetWidth;
        } else if (playerX > containerWidth - player.offsetWidth) {
            playerX = 0;
        }

        if (playerY < 0) {
            playerY = containerHeight - player.offsetHeight;
        } else if (playerY > containerHeight - player.offsetHeight) {
            playerY = 0;
        }

        // Emp√™cher le joueur d'entrer dans la zone de la tutorial-box
        if (
            playerX + player.offsetWidth >= tutorialRect.left &&
            playerX <= tutorialRect.right &&
            playerY + player.offsetHeight >= tutorialRect.top &&
            playerY <= tutorialRect.bottom
        ) {
            // V√©rifier la direction pour rebondir correctement
            if (direction.x > 0) {
                playerX = tutorialRect.right; // Sortir par la droite
            } else if (direction.x < 0) {
                playerX = tutorialRect.left - player.offsetWidth; // Sortir par la gauche
            }

            if (direction.y > 0) {
                playerY = tutorialRect.bottom; // Sortir par le bas
            } else if (direction.y < 0) {
                playerY = tutorialRect.top - player.offsetHeight; // Sortir par le haut
            }
        }

        player.style.left = `${playerX}px`;
        player.style.top = `${playerY}px`;

        collectibles.forEach((collectible, index) => {
            const collectibleRect = collectible.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();

            if (
                playerRect.left < collectibleRect.right &&
                playerRect.right > collectibleRect.left &&
                playerRect.top < collectibleRect.bottom &&
                playerRect.bottom > collectibleRect.top
            ) {
                collectible.remove();
                collectibles.splice(index, 1);

                if (collectibles.length === 0) {
                    setTimeout(createCollectibles, 500);
                }
            }
        });
    }

    // Gestion des contr√¥les clavier
    function updateDirection() {
        if (keysPressed['ArrowUp'] && keysPressed['ArrowLeft']) {
            direction = { x: -1, y: -1 };
            lastDiagonalDirection = { x: -1, y: -1 };
        } else if (keysPressed['ArrowUp'] && keysPressed['ArrowRight']) {
            direction = { x: 1, y: -1 };
            lastDiagonalDirection = { x: 1, y: -1 };
        } else if (keysPressed['ArrowDown'] && keysPressed['ArrowLeft']) {
            direction = { x: -1, y: 1 };
            lastDiagonalDirection = { x: -1, y: 1 };
        } else if (keysPressed['ArrowDown'] && keysPressed['ArrowRight']) {
            direction = { x: 1, y: 1 };
            lastDiagonalDirection = { x: 1, y: 1 };
        } else if (keysPressed['ArrowUp']) {
            direction = { x: 0, y: -1 };
        } else if (keysPressed['ArrowDown']) {
            direction = { x: 0, y: 1 };
        } else if (keysPressed['ArrowLeft']) {
            direction = { x: -1, y: 0 };
        } else if (keysPressed['ArrowRight']) {
            direction = { x: 1, y: 0 };
        } else if (lastDiagonalDirection) {
            direction = lastDiagonalDirection;
        }
        lastDiagonalDirection = direction;
    }

    function handleTouchStart(event) {
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
    }

    function handleTouchMove(event) {
        if (!touchStartX || !touchStartY) return;

        const touchEndX = event.touches[0].clientX;
        const touchEndY = event.touches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;

        const threshold = 5;

        if (Math.abs(diffX) > Math.abs(diffY)) {
            direction = { x: diffX > 0 ? 1 : -1, y: 0 };
        } else {
            direction = { x: 0, y: diffY > 0 ? 1 : -1 };
        }

        touchStartX = touchEndX;
        touchStartY = touchEndY;
    }

    if (controlType === 'keyboard') {
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
            updateDirection();
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });
    }

    function gameLoop() {
        movePlayer();
        requestAnimationFrame(gameLoop);
    }

    if (controlType === 'touch') {
        gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
    }

    window.addEventListener('resize', () => {
        updateContainerDimensions();
    });

    updateContainerDimensions();
    createCollectibles();
    gameLoop();
}

// export function initializeGameControls(controlType) {
//     const player = document.querySelector('.player');
//     const gameContainer = document.querySelector('.game-container');
//     if (!player || !gameContainer) return;

//     let containerWidth = gameContainer.offsetWidth;
//     let containerHeight = gameContainer.offsetHeight;
//     const collectibleCount = 9;
//     const collectibles = [];
//     let direction = { x: 1, y: 0 };
//     const playerSpeed = 3;
//     let playerX = 0;
//     let playerY = containerHeight / 2 - 15;
//     const keysPressed = {};
//     let lastDiagonalDirection = null;
//     let touchStartX = null;
//     let touchStartY = null;

//     function updateContainerDimensions() {
//         containerWidth = gameContainer.offsetWidth;
//         containerHeight = gameContainer.offsetHeight - 50;
//         collectibles.forEach(collectible => {
//             let cX = parseFloat(collectible.style.left);
//             let cY = parseFloat(collectible.style.top);
//             if (cX + 30 > containerWidth) {
//                 collectible.style.left = `${containerWidth - 30}px`;
//             }
//             if (cY + 30 > containerHeight) {
//                 collectible.style.top = `${containerHeight - 30}px`;
//             }
//         });
//     }

//     function createCollectibles() {
//         collectibles.forEach(col => col.remove());
//         collectibles.length = 0;
//         for (let i = 0; i < collectibleCount; i++) {
//             const collectible = document.createElement('div');
//             collectible.className = 'collectible';
//             collectible.style.left = `${Math.random() * (containerWidth - 30)}px`;
//             collectible.style.top = `${Math.random() * (containerHeight - 30)}px`;
//             gameContainer.appendChild(collectible);
//             collectibles.push(collectible);
//         }
//     }

//     function movePlayer() {
//         const length = Math.sqrt(direction.x ** 2 + direction.y ** 2);
//         const normalized = { x: (direction.x / length) * playerSpeed, y: (direction.y / length) * playerSpeed };
//         playerX += normalized.x;
//         playerY += normalized.y;

//         if (playerX < 0) playerX = containerWidth - player.offsetWidth;
//         else if (playerX > containerWidth - player.offsetWidth) playerX = 0;

//         if (playerY < 0) playerY = containerHeight - player.offsetHeight;
//         else if (playerY > containerHeight - player.offsetHeight) playerY = 0;

//         player.style.left = `${playerX}px`;
//         player.style.top = `${playerY}px`;

//         collectibles.forEach((c, i) => {
//             const cRect = c.getBoundingClientRect();
//             const pRect = player.getBoundingClientRect();
//             if (pRect.left < cRect.right && pRect.right > cRect.left && pRect.top < cRect.bottom && pRect.bottom > cRect.top) {
//                 c.remove();
//                 collectibles.splice(i, 1);
//                 if (collectibles.length === 0) {
//                     setTimeout(createCollectibles, 500);
//                 }
//             }
//         });
//     }

//     function updateDirection() {
//         if (keysPressed['ArrowUp'] && keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: -1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowUp'] && keysPressed['ArrowRight']) {
//             direction = { x: 1, y: -1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowDown'] && keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: 1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowDown'] && keysPressed['ArrowRight']) {
//             direction = { x: 1, y: 1 };
//             lastDiagonalDirection = direction;
//         } else if (keysPressed['ArrowUp']) {
//             direction = { x: 0, y: -1 };
//         } else if (keysPressed['ArrowDown']) {
//             direction = { x: 0, y: 1 };
//         } else if (keysPressed['ArrowLeft']) {
//             direction = { x: -1, y: 0 };
//         } else if (keysPressed['ArrowRight']) {
//             direction = { x: 1, y: 0 };
//         } else if (lastDiagonalDirection) {
//             direction = lastDiagonalDirection;
//         }
//     }

//     if (controlType === 'keyboard') {
//         document.addEventListener('keydown', (e) => {
//             keysPressed[e.key] = true;
//             updateDirection();
//         });
//         document.addEventListener('keyup', (e) => {
//             keysPressed[e.key] = false;
//             if (!keysPressed['ArrowUp'] && !keysPressed['ArrowDown'] && !keysPressed['ArrowLeft'] && !keysPressed['ArrowRight']) {
//                 if (lastDiagonalDirection) direction = lastDiagonalDirection;
//             }
//         });
//     }

//     if (controlType === 'touch') {
//         gameContainer.addEventListener('touchstart', e => {
//             const touch = e.touches[0];
//             touchStartX = touch.clientX;
//             touchStartY = touch.clientY;
//         }, { passive: false });

//         gameContainer.addEventListener('touchmove', e => {
//             if (!touchStartX || !touchStartY) return;
//             const touchEndX = e.touches[0].clientX;
//             const touchEndY = e.touches[0].clientY;
//             const diffX = touchEndX - touchStartX;
//             const diffY = touchEndY - touchStartY;
//             const threshold = 5;
//             if (Math.abs(diffX) > Math.abs(diffY)) {
//                 if (Math.abs(diffY) > threshold) {
//                     direction = { x: diffX > 0 ? 1 : -1, y: diffY > 0 ? 1 : -1 };
//                 } else {
//                     direction = { x: diffX > 0 ? 1 : -1, y: 0 };
//                 }
//             } else {
//                 if (Math.abs(diffX) > threshold) {
//                     direction = { x: diffX > 0 ? 1 : -1, y: diffY > 0 ? 1 : -1 };
//                 } else {
//                     direction = { x: 0, y: diffY > 0 ? 1 : -1 };
//                 }
//             }
//             touchStartX = touchEndX;
//             touchStartY = touchEndY;
//         }, { passive: false });
//     }

//     function gameLoop() {
//         movePlayer();
//         requestAnimationFrame(gameLoop);
//     }

//     window.addEventListener('resize', () => updateContainerDimensions());
//     updateContainerDimensions();
//     createCollectibles();
//     gameLoop();
// }

===== ./game/display.js =====
// game/display.js
import { requestGet }  from '../api/index.js';
import { resetScrollPosition } from '../tools/index.js';


//[IMPROVE] Voir quoi afficher avec le get
export async function displayGame() {
    try {
        const response = await requestGet('game', 'game');
        document.querySelector('#home').innerHTML = response.html || response;
        resetScrollPosition();
    } catch (error) {
        console.log('Erreur chargement jeu:', error);
    }
}

export async function displayTournamentBracket(participantCount) {
    const url = participantCount === 4 ? 'bracket_4.html' : 'bracket_8.html';
    try {
        const response = await Api.get(url);
        document.querySelector('#home').innerHTML = response.html || response;
        resetScrollPosition();
    } catch (error) {
        console.log('Erreur chargement bracket:', error);
    }
}

===== ./game/index.js =====
// game/index.js
// contient uniquement les fonctions que l'on souhaite appeler depuis d'autres fichiers

export { handleInviteGame, handleGameInvitationBurgerMenu } from './handleInvitationGame.js';
//export { startLoading } from './loading.js';
export { displayGame, displayTournamentBracket } from './display.js';
export { initializeGameControls } from './controls.js';
export { initializeGameHomeView } from './home.js';
export { handleGameMenu } from './gameMenu.js';
export { startLoading } from './loading.js';
export { acceptGameInvitation, createGameOnline } from './onlineGame.js'
===== ./game/live_game_svg.js =====
// ========== Fonctions g√©n√©riques pour cr√©er SVG powerups / bumpers ==========

// -- Gestion PowerUp SVG / Bumper SVG (extraits de ton code)
export function createPowerupSVG(type) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 50 50");
    svg.setAttribute("width", "30");
    svg.setAttribute("height", "30");
    
    const powerupStyles = {
        'invert': {
            colors: {main: '#FF69B4', glow: '#FF1493'},
            icon: 'M25 15 A10 10 0 1 1 25 35 M25 35 L20 30 M25 35 L30 30'
        },
        'shrink': {
            colors: {main: '#FF0000', glow: '#8B0000'},
            icon: 'M25 25 L35 15 M33 15 L35 15 L35 17 M25 25 L15 15 M17 15 L15 15 L15 17 M25 25 L35 35 M33 35 L35 35 L35 33 M25 25 L15 35 M17 35 L15 35 L15 33'
        },
        'ice': {
            colors: {main: '#00FFFF', glow: '#00CED1'},
            paths: [
                {d: 'M25 10 L25 40 M18 14 L32 36 M32 14 L18 36 M20 25 L30 25', 
                fill: 'none', stroke: 'white', width: 3},
                {d: 'M25 25 m-3,0 a3,3 0 1,0 6,0 a3,3 0 1,0 -6,0', 
                fill: 'white', stroke: 'none', width: 0}
            ]
        },
        'speed': {
            colors: {main: '#FFD700', glow: '#FFA500'},
            icon: 'M30 10 L20 25 L27 25 L17 40 L32 25 L25 25 L35 10',
            fill: 'white'
        },
        'flash': {
            colors: {main: '#FFFF00', glow: '#FFD700'},
            paths: [
                {d: 'M25 10 m-8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0', 
                fill: 'white', stroke: 'none', width: 0},
                {d: 'M25 10 L25 17 M25 33 L25 40 M35 25 L42 25 M8 25 L15 25 M32 18 L37 13 M13 37 L18 32 M32 32 L37 37 M13 13 L18 18',
                fill: 'none', stroke: 'white', width: 3}
            ]
        },
        'sticky': {
            colors: {main: '#32CD32', glow: '#228B22'},
            icon: 'M25 10 C15 10 15 20 25 20 C35 20 35 10 25 10 M17 20 C17 40 33 40 33 20',
            fill: 'white'
        }
    };
    
    const style = powerupStyles[type] || powerupStyles['speed'];
    
    // Create gradient
    const gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradient.id = `${type}Glow`;
    
    const stops = [
        {offset: '0%', color: style.colors.main, opacity: '1'},
        {offset: '100%', color: style.colors.glow, opacity: '0.6'}
    ];
    
    stops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        gradient.appendChild(stopEl);
    });
    
    svg.appendChild(gradient);
    
    // Create base circle
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", "25");
    circle.setAttribute("cy", "25");
    circle.setAttribute("r", "20");
    circle.setAttribute("fill", `url(#${type}Glow)`);
    svg.appendChild(circle);
    
    // Add icon(s)
    if (style.paths) {
        // For complex icons with multiple paths
        style.paths.forEach(pathData => {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", pathData.d);
            path.setAttribute("stroke", pathData.stroke);
            path.setAttribute("stroke-width", pathData.width);
            path.setAttribute("fill", pathData.fill);
            svg.appendChild(path);
        });
    } else {
        // For single path icons
        const icon = document.createElementNS("http://www.w3.org/2000/svg", "path");
        icon.setAttribute("d", style.icon);
        icon.setAttribute("stroke", "white");
        icon.setAttribute("stroke-width", "3");
        icon.setAttribute("fill", style.fill || "none");
        svg.appendChild(icon);
    }
    
    return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
}

export function createBumperSVG() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 100 100");

    // Create white orb gradient
    const whiteGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    whiteGradient.id = "whiteOrbGradient";
    whiteGradient.setAttribute("cx", "40%");
    whiteGradient.setAttribute("cy", "40%");
    whiteGradient.setAttribute("r", "60%");

    const whiteStops = [
        {offset: '0%', color: 'white', opacity: '1'},
        {offset: '90%', color: '#e0e0e0', opacity: '1'}
    ];

    whiteStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        whiteGradient.appendChild(stopEl);
    });

    // Create blue ring gradient
    const blueGradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    blueGradient.id = "blueRingGradient";
    blueGradient.setAttribute("cx", "50%");
    blueGradient.setAttribute("cy", "50%");
    blueGradient.setAttribute("r", "50%");

    const blueStops = [
        {offset: '0%', color: '#4169E1', opacity: '1'},
        {offset: '100%', color: '#1E90FF', opacity: '1'}
    ];

    blueStops.forEach(stop => {
        const stopEl = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stopEl.setAttribute("offset", stop.offset);
        stopEl.setAttribute("stop-color", stop.color);
        stopEl.setAttribute("stop-opacity", stop.opacity);
        blueGradient.appendChild(stopEl);
    });

    // Add gradients to defs
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    defs.appendChild(whiteGradient);
    defs.appendChild(blueGradient);
    svg.appendChild(defs);

    // Blue exterior ring
    const ringCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    ringCircle.setAttribute("cx", "50");
    ringCircle.setAttribute("cy", "50");
    ringCircle.setAttribute("r", "45");
    ringCircle.setAttribute("fill", "none");
    ringCircle.setAttribute("stroke", "url(#blueRingGradient)");
    ringCircle.setAttribute("stroke-width", "8");

    // White orb center
    const whiteOrb = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    whiteOrb.setAttribute("cx", "50");
    whiteOrb.setAttribute("cy", "50");
    whiteOrb.setAttribute("r", "35");
    whiteOrb.setAttribute("fill", "url(#whiteOrbGradient)");

    // Highlight for 3D effect
    const highlight = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    highlight.setAttribute("cx", "35");
    highlight.setAttribute("cy", "35");
    highlight.setAttribute("r", "15");
    highlight.setAttribute("fill", "white");
    highlight.setAttribute("opacity", "0.3");

    svg.appendChild(ringCircle);
    svg.appendChild(whiteOrb);
    svg.appendChild(highlight);

    return `data:image/svg+xml;base64,${btoa(new XMLSerializer().serializeToString(svg))}`;
    }
===== ./game/loading.js =====
// game/loading.js
import { requestGet }  from '../api/index.js';


// [IMPROVE] verifeir import
//import Animations from '../modules/animations.js';
import { isTouchDevice } from '../tools/utility.js';
import { updateHtmlContent } from '../tools/domHandler.js';
import { initializeGameControls } from './controls.js';
import { displayGame, displayTournamentBracket } from './display.js';

export async function startLoading(participantCount) {
    try {
        const response = await requestGet('game', 'loading');
        updateHtmlContent('#content', response.html);
        //Animations.animateLoadingText();
        if (isTouchDevice()) {
            initializeGameControls('touch');
        } else {
            initializeGameControls('keyboard');
        }

        // setTimeout(() => {
        //     if (participantCount === 1) {
        //         displayGame();
        //     } else {
        //         displayTournamentBracket(participantCount);
        //     }
        // }, 20000);
    } catch (error) {
        console.log('Erreur chargement page loading:', error);
    }
}

===== ./game/gameResults.js =====
import { requestGet} from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";


export async function showResults(gameId) {
	try {
		const response = await requestGet('game', `game_results/${gameId}` );
		if (response.status === 'success')
		{
			showStatusMessage(`Partie termin√©e ! \nwinner : ${response.winner}  looser : ${response.looser}\n${response.score_left} - ${response.score_right}`, 'success');
			updateHtmlContent('#content', response.html);
			
			// IMPROVE : adapter l' ui de en modifiant le dom pour afficher winner
		}
		else{
			// alert(response.message);
			showStatusMessage(response.message, 'error');
		}
	} catch (err) {
		// console.error('Erreur lors de la cr√©ation de la partie :', err);
		showStatusMessage('Impossible d\'obtenir les resultats', 'error');
	}
}
===== ./game/home.js =====
import { updateHtmlContent } from '../tools/index.js';
import { requestGet } from '../api/index.js';
import { navigateTo } from '../router.js';
import { showStatusMessage } from '../tools/index.js';

/**
 * Initialise la vue de la page d'accueil du jeu.
 * Redirige vers la page de jeu si l'utilisateur est authentifi√©.
 */
export async function initializeGameHomeView() {
    console.log('initializeGameHomeView d√©marr√©');

    try {
        const data = await requestGet('game', 'home');
        if (!data) {
            return;
        }

        if (data && data.html) {
            updateHtmlContent('#content', data.html);
        } else {
            showStatusMessage('Les donn√©es HTML de la page d\'accueil sont manquantes ou invalides.', 'error');
        }
    } catch (error) {
        showStatusMessage('Erreur lors du chargement de la page d\'accueil du jeu.', 'error');
        console.error('Erreur lors de la requ√™te API initializeGameHomeView :', error);
        return;
    }

    const playBtn = document.querySelector('#play-btn-home');
    if (!playBtn) {
        showStatusMessage('Le bouton "Jouer" est introuvable dans la vue actuelle.', 'error');
        return;
    }
    
    if (!playBtn.dataset.bound) {
        playBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('Bouton "Jouer" cliqu√©. Redirection vers /game-options.');
            navigateTo('/game-options');
        });
        playBtn.dataset.bound = true; // Emp√™che de lier plusieurs fois l'√©v√©nement
    }

    console.log('initializeGameHomeView termin√©.');
}
===== ./game/localGame.js =====
import { requestGet, requestPost } from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";
import { launchLiveGameWithOptions } from "./live_game.js";
import { showResults } from "./gameResults.js";

export async function handleLocalGame(parametersForm) {
    // Poster vers ton endpoint
	try {
		const response = await requestPost('game', 'create_local_game', parametersForm);
		if (response.status === 'success')
		{
			showStatusMessage(`Partie cr√©√©e avec succ√®s : ID = ${response.game_id}`, 'success');
			updateHtmlContent('#content', response.html);
			const gameId = response.game_id;
			await launchLiveGameWithOptions(gameId, 'both', `start_local_game/${gameId}`);
			// Attendre quelques secondes (par exemple, 3 secondes)
			await showResults(gameId);
			//IMPROVE afficher une page pr√©sentant le winner et looser une fois la game terminee
		}
		else{
			// alert(response.message);
			showStatusMessage(response.message, 'error');

		}
	} catch (err) {
		console.error('Error local game', err);
		showStatusMessage('Error local game', 'error');
	}
}

===== ./game/gameMenu.js =====
import { requestGet, requestPost } from '../api/index.js'; 
import { updateHtmlContent } from '../tools/index.js'; 
// import { handleInviteGame } from './handleInvitationGame.js'; // Suppose qu'on g√®re l'invitation en ligne ici
// import { launchLiveGameWithOptions } from './live_game.js';
import { handleLocalGame } from './localGame.js'
import { createGameOnline } from './onlineGame.js'

import { navigateTo } from '../router.js';

function attachGameMenuEvents() {
    const sections = ['local', 'online', 'tournament'];

    sections.forEach((section) => {
        // Bouton de s√©lection
        document.getElementById(`${section}-game-btn`)?.addEventListener('click', () => {
            sections.forEach((s) => {
                document.getElementById(`customization-${s}`).classList.add('d-none');
            });
            document.getElementById(`customization-${section}`).classList.remove('d-none');
        });

        // Bouton Voir Tuto
        document.getElementById(`tutorial-btn-${section}`)?.addEventListener('click', () => {
            const tutorialContent = document.getElementById(`tutorial-content-${section}`);
            tutorialContent.classList.toggle('collapse');
        });

        // Gestion de la vitesse de la balle
        document.getElementById(`ballSpeed${section.charAt(0).toUpperCase() + section.slice(1)}`)?.addEventListener('input', (event) => {
            console.log(`Vitesse de balle (${section}):`, event.target.value);
        });

        // Bouton principal (Lancer Partie, Inviter un ami, Lancer Tournoi)
        const startGameButton = document.getElementById(`start-game-btn-${section}`);
        const inviteGameButton = document.getElementById(`invite-game-btn-${section}`);
        const inviteTournamentButton = document.getElementById(`invite-tournament-btn-${section}`);
        const test = document.getElementById(`${section}-game-btn`); 

        // D√©finir un comportement diff√©rent selon le bouton
        if (startGameButton && section === 'local') {
            startGameButton.addEventListener('click', async () => {
                const parametersForm = new FormData();
                parametersForm.append('game_type', section);

                // R√©cup√©rer les √©l√©ments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                // V√©rifier s‚Äôils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }
                    
                console.log(`Vitesse de balle (${section}):`, ballSpeedElement.value);
                console.log(`Taille de raquette (${section}):`, paddleSizeElement.value);
                console.log(`Bonus activ√© (${section}):`, bonusCheckbox?.checked);
                console.log(`Obstacles activ√©s (${section}):`, obstacleCheckbox?.checked);
                // Lire les valeurs
                parametersForm.append('ball_speed', ballSpeedElement.value);
                parametersForm.append('paddle_size', paddleSizeElement.value);
                parametersForm.append('bonus_enabled', bonusCheckbox?.checked ?? false);
                parametersForm.append('obstacles_enabled', obstacleCheckbox?.checked ?? false);

                await handleLocalGame(parametersForm)
            });
        }

        if (startGameButton && section === 'online') {
            startGameButton.addEventListener('click', async () => {
                try {
                    // R√©cup√®re les √©l√©ments
                    const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                    const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                    const bonusCheckbox = document.getElementById(`bonus${section}`);
                    const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);

                    if (!ballSpeedElement || !paddleSizeElement) {
                        console.error(`Impossible de trouver les champs pour la section "${section}".`);
                        return;
                    }
                    
                    // Stockage en m√©moire JS
                    const onlineParams = {
                        ball_speed: ballSpeedElement.value,
                        paddle_size: paddleSizeElement.value,
                        bonus_enabled: bonusCheckbox?.checked ?? false,
                        obstacles_enabled: obstacleCheckbox?.checked ?? false,
                    };
                    sessionStorage.setItem('params', JSON.stringify(onlineParams));
                    console.log('Param√®tres de la partie online:', onlineParams);

                    // Maintenant on va charger la page "invite_game.html"
                    // et injecter le HTML dans #content (ou autre conteneur).
                    navigateTo('/online');

                } catch (err) {
                    console.error('Erreur lors de la phase d\'invitation :', err);
                    alert('Impossible d\'inviter un ami.');
                }
            });
        }

        if (startGameButton && section === 'tournament') {
            startGameButton.addEventListener('click', async () => {
                

                // R√©cup√©rer les √©l√©ments
                const ballSpeedElement = document.getElementById(`ballSpeed${section}`);
                const paddleSizeElement = document.getElementById(`paddleSizeSelect${section}`);
                const bonusCheckbox = document.getElementById(`bonus${section}`);
                const obstacleCheckbox = document.getElementById(`bonusObstacle${section}`);
                
                // V√©rifier s‚Äôils existent
                if (!ballSpeedElement || !paddleSizeElement) {
                    console.error(`Impossible de trouver les champs pour la section "${section}".`);
                    return;
                }

                 // Stockage en m√©moire JS
                const tournamentparams = {
                    ball_speed: ballSpeedElement.value,
                    paddle_size: paddleSizeElement.value,
                    bonus_enabled: bonusCheckbox?.checked ?? false,
                    obstacles_enabled: obstacleCheckbox?.checked ?? false,
                };

                sessionStorage.setItem('params', JSON.stringify(tournamentparams));
                navigateTo(`/tournament`);
            });
        }
    });
}



export async function handleGameMenu() {
    console.log('Chargement du menu du jeu...');
    try {
        // 1) On va chercher le HTML du menu
        const response = await requestGet('game', 'menu');
        if (!response) {
            return;
        }
        // 2) On injecte ce HTML dans la div #content
        updateHtmlContent('#content', response.html);
        // 3) On attache les √©v√©nements
        attachGameMenuEvents();
    } catch (error) {
        console.error('Erreur dans handleGameMenu:', error);
    }
}

===== ./game/onlineGame.js =====
import { requestGet, requestPost } from "../api/index.js";
import { updateHtmlContent } from "../tools/index.js";
import { showStatusMessage } from "../tools/index.js";
import { isTouchDevice } from "../tools/utility.js";
import { initializeGameControls } from "./controls.js";
import { launchLiveGameWithOptions } from "./live_game.js";
import { HTTPError } from "../api/index.js";
import { showResults } from "./gameResults.js";
import { navigateTo } from "../router.js";

export async function createGameOnline() {
    
    console.log('createGameOnline');
    if (typeof localStorage !== "undefined" && !localStorage.getItem('access_token')) {
		navigateTo('/');
		return;
	}
    let onlineParams = sessionStorage.getItem('params');
	if (onlineParams === null)
	{
		showStatusMessage("Param√®tres online invalides.", 'error');
		navigateTo('/game-options');
		return;
	}
	try {
		onlineParams = JSON.parse(onlineParams);
	} catch (e) {
		showStatusMessage("Erreur lors de la recuperation des Param√®tres.", 'error'); //[IMPROVE]
		return;
	}

    const formData = new FormData();
    if (onlineParams) {
        formData.append('ball_speed',               onlineParams.ball_speed);
        formData.append('paddle_size',             onlineParams.paddle_size);
        formData.append('bonus_enabled',  onlineParams.bonus_enabled);
        formData.append('obstacles_enabled',      onlineParams.obstacles_enabled);
    } else {
        console.warn('Aucun param√®tre.');
    }
    try {
        console.log('Avant le try');
        const response = await requestPost('game', 'create_game_online', formData);
        console.log('requestPost effectu√©'); 
        if (response.status === 'error') {
            console.log('requestPost error'); 

            showStatusMessage(response.message, 'error');
        } else {
            updateHtmlContent('#content', response.html);
            initializeFriendInvitationBtn(response.game_id);
        }
    } catch (error) {
            showStatusMessage('Une erreur est survenue.', 'error');
            console.error('Erreur createGameOnline :', error);
    }
}


async function sendInvitation(button, game_id) {
    console.log('[sendInvitation] Envoi de l\'invitation...');
    const friendUsername = button.closest('li')?.getAttribute('data-username');
    if (!friendUsername) {
        console.error('Nom d\'utilisateur introuvable.');
        return;
    }

    const formData = new FormData();
    formData.append('friend_username', friendUsername);
    formData.append('session_id', game_id);

    try {
        const response = await requestPost('game', 'send_gameSession_invitation', formData);
        if (response.status === 'success') {
            checkGameInvitationStatus(response);
        } else {
            throw new Error(response.message || 'Erreur inconnue');
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi :', error);
        button.textContent = 'Erreur';
        button.classList.add('error');
        setTimeout(() => {
            button.innerHTML = 'Inviter <span class="cancel-icon d-none">&times;</span>';
            button.classList.remove('error');
        }, 3000);
    }
}

// Lanc√©e pour le joueur left apr√®s qu'il ait fait sendInvitation()
// Check le statut de l'invitation envoy√©e toutes les 3 secondes 
// Pendant que le joueur est sur la page loading.html
// redirige vers joinOnlineGameAsLeft() quand l'autre joueur a accept√© l'invitation
async function checkGameInvitationStatus(response) {
    // 1) On met √† jour le contenu HTML et on initialise les contr√¥les (comme tu le fais d√©j√†)
    updateHtmlContent('#content', response.html);

    if (isTouchDevice()) {
        initializeGameControls('touch');
    } else {
        initializeGameControls('keyboard');
    }

    // 2) On r√©cup√®re l'ID de l'invitation depuis la r√©ponse 
    //    (assure-toi que ton backend t'envoie bien `invitation_id` dans `response`)
    const invitationId = response.invitation_id;  

    // 3) On d√©finit l'interval pour faire un GET sur CheckGameInvitationStatusView
    const intervalDelay = 3000; // en ms, par ex. toutes les 3 secondes
    let pollInterval = setInterval(async () => {
        try {
            const data = await requestGet('game', `check_invitation_status/${invitationId}`);
            // G√©rer la r√©ponse
            if (data.status === 'success') {
                
              // V√©rifier data.status (succ√®s) et data.invitation_status (pending, accepted, etc.)
                if (data.status === 'success') {
                    // data.invitation_status => 'pending', 'accepted', 'rejected', 'expired'
                    switch (data.invitation_status) {
                        case 'pending':
                            // On ne fait rien, on attend le prochain interval
                            console.log("Invitation toujours en attente...");
                            break;

                        case 'accepted':
                            console.log("Invitation accept√©e !");
                            // 1) Arr√™ter le polling
                            clearInterval(pollInterval);

                            // 2) Rediriger vers la page de jeu
                            joinOnlineGameAsLeft(data.session_id);
                            break;

                        case 'rejected':
                            clearInterval(pollInterval);
                            showStatusMessage('Invitation refus√©e.', 'error');
                            createGameOnline();
                            break;
                        case 'expired':
                            clearInterval(pollInterval);
                            showStatusMessage('Invitation expir√©e.', 'error');
                            createGameOnline();
                            break;
                        default:
                            console.warn("Statut inconnu :", data.invitation_status);
                            break;
                    }
                } else {
                    // G√©rer data.status = 'error'
                    console.error("Erreur lors de la v√©rification :", data.message);
                    clearInterval(pollInterval);
                }
            } else {
                // Statut HTTP non 200 => on arr√™te tout
                console.error("√âchec de la requ√™te GET sur check_invitation_status :", statusResponse.status);
                clearInterval(pollInterval);
            }
        } catch (err) {
            console.error("Erreur r√©seau/JS pendant le polling:", err);
            clearInterval(pollInterval);
        }
    }, intervalDelay); 
}


function initializeFriendInvitationBtn(game_id) {
    document.addEventListener('click', async (event) => {
        const btn = event.target.closest('.invite-button');
        if (!btn) return;

        if (event.target.classList.contains('cancel-icon')) {
            event.stopPropagation();
            await cancelInvitation(btn);
            return;
        }

        // Si pas d√©j√† envoy√©
        if (!btn.classList.contains('sent')) {
            await sendInvitation(btn, game_id);
        }
    });
}


// cette fonction est lanc√©e par la fonction checkGameInvitation status quand le joueur right a accept√© l'invitation
// elle redirige le joueur left (celui qui a envoy√© l'invitation) vers la page de jeu
// sur la page de jeu le joueur pourra cliquer sur un bouton qui lancera le jeu en arri√®re plan (cf.live_online_game_left.js)
async function joinOnlineGameAsLeft(game_id) {
    try {
        const tactile = isTouchDevice();
        console.log('tactile :', tactile);
        
        // Cr√©ez un FormData et ajoutez le param√®tre is_touch
        const formData = new FormData();
        formData.append('is_touch', tactile);

        // Construit l'URL sans query string
        const url = `join_online_game_as_left/${game_id}`;  // Assurez-vous d'avoir le slash final si n√©cessaire
        
        // Utilisez requestPost pour envoyer la requ√™te avec le FormData
        const response = await requestPost('game', url, formData);
        
        if (response.status === 'success') {
            // Afficher le HTML renvoy√© par le back-end
            updateHtmlContent('#content', response.html);
            // Lancer le jeu c√¥t√© front pour le joueur left
            await launchLiveGameWithOptions(game_id, 'left', `start_online_game/${game_id}`);
            await showResults(game_id);
        } else {
            showStatusMessage(response.message, 'error');
        }
    } catch (error) {
        if (error instanceof HTTPError) {
            showStatusMessage(error.message, 'error');
        } else {
            showStatusMessage('Une erreur est survenue.', 'error');
        }
        console.error('Erreur joinOnlineGameAsLeft :', error);
    }
}


// IMPROVE : creer une fonction manageGameInvitation() qui gere les cas accept et decline
// lanc√©e par handleGameInvitationBurgerMenu() lorsque le joueur clique sur accepter l'invitation
// fait disparaitre l'item d'invitation
// redirige le joueur ayant accept√© l'invit vers la page de jeu avec joinOnlineGameAsRight()
export async function acceptGameInvitation(invitationId, action) {
    try {
        if (action === 'accept') {
            const url = `accept_game_invitation/${invitationId}`;
            const response = await requestPost('game', url, null);

            if (response.status === 'success') {
                console.log('Invitation accept√©e => session cr√©√©e :', response);

                // Supprime l'invitation de l'UI
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();

                // Rejoindre le jeu en tant que joueur RIGHT
                joinOnlineGameAsRight(response.session.id);
            } else {
                console.error('Erreur √† l\'acceptation :', response.message);
            }
        } else if (action === 'decline') {
            await declineGameInvitation(invitationId);
        }
    } catch (error) {
        console.error('Erreur r√©seau lors du traitement de l\'invitation :', error);
    }
}

// lancee par acceptGameInvitation() 
// rediriger le joueur ayant accept√© l'invitation vers la page de jeu
async function joinOnlineGameAsRight(sessionId) {
    try {
        const tactile = isTouchDevice();
        console.log('tactile :', tactile);
        
        // Cr√©ez un FormData et ajoutez le param√®tre is_touch
        const formData = new FormData();
        formData.append('is_touch', tactile);

        // Construit l'URL sans query string
        const url = `join_online_game_as_left/${sessionId}`;  // Assurez-vous d'avoir le slash final si n√©cessaire
        
        // Utilisez requestPost pour envoyer la requ√™te avec le FormData
        const response = await requestPost('game', url, formData);

        // Gestion des erreurs renvoy√©es par le serveur
        if (response.status === 'error') {
            console.error("Erreur lors de la tentative de rejoindre le jeu :", response.message);
            showStatusMessage(response.message, 'error');
            return;
        }
        // Si succ√®s, afficher la page de jeu 
        updateHtmlContent('#content', response.html);
        await launchLiveGameWithOptions(response.game_id, 'right', `start_online_game/${response.game_id}`);
        await showResults(response.game_id);


    } catch (error) {
        console.error('Erreur r√©seau lors de la connexion au jeu en tant que joueur Right:', error);
        showStatusMessage('Une erreur r√©seau est survenue. Veuillez r√©essayer.', 'error');
    }
}

export async function declineGameInvitation(invitationId) {
    try {
        const formData = new FormData();
        formData.append('invitation_id', invitationId);
        formData.append('action', 'decline');

        const url = `reject_game_invitation/${invitationId}`;
        const response = await requestPost('game', url, formData);

        if (response.status === 'success') {
            console.log('Invitation refus√©e :', response);
            document.querySelector(`[data-invitation-id="${invitationId}"]`)
                ?.closest('.invitation-item')
                ?.remove();
        } else {
            console.error('Erreur lors du refus :', response.message);
        }
    } catch (error) {
        console.error('Erreur lors du refus de l\'invitation :', error);
    }
}
===== ./game/tournament.js =====
import { requestGet, requestPost } from "../api/index.js";
import { showStatusMessage, updateHtmlContent } from "../tools/index.js";
import { launchLiveGameWithOptions } from './live_game.js';
import { TournamentNextMatch } from './tournament_utils.js';
import { showResults } from "./gameResults.js";
import { navigateTo } from "../router.js";


// Fonction principale appel√©e quand on clique sur "Lancer Tournoi" dans le menu
export async function handleTournament() {

	if (typeof localStorage !== "undefined" && !localStorage.getItem('access_token')) {
		navigateTo('/');
		return;
	}

	let tournamentParam = sessionStorage.getItem('params');
	if (tournamentParam === null)
	{
		showStatusMessage("Param√®tres de tournoi invalides.", 'error');
		navigateTo('/game-options');
		return;
	}
	try {
		tournamentParam = JSON.parse(tournamentParam);
	} catch (e) {
		showStatusMessage("Erreur lors de la recuperation des Param√®tres.", 'error'); //[IMPROVE]
		return;
	}
	
		console.log("Tournament param est √©gale a :", tournamentParam);
		// 1) R√©cup√®re le formulaire (GET)
	const formHtml = await getTournamentForm();
	if (!formHtml)
		return;
	updateHtmlContent('#content', formHtml);

	// 2) S√©lection du form dans le DOM
	const form = document.querySelector('#content form');
	if (!form) {
		console.error("Formulaire introuvable dans le HTML inject√©.");
		return;
	}

	// 3) Au submit => POST de cr√©ation du tournoi
	form.addEventListener("submit", async (event) => {
		event.preventDefault();

		// R√©cup√©ration des champs du form
		const formData = new FormData(form);

		// Si vous avez d‚Äôautres param√®tres pass√©s depuis un menu (tournamentParam),
		// on peut forcer/√©craser ici dans le formData :
		if (tournamentParam) {
		formData.set('ball_speed', tournamentParam.ball_speed);
		formData.set('paddle_size', tournamentParam.paddle_size);
		formData.set('bonus_enabled', tournamentParam.bonus_enabled);
		formData.set('obstacles_enabled', tournamentParam.obstacles_enabled);
		}

		try {
		const response = await createTournament(formData);
		if (response.status === 'success') {
			alert(`Tournoi cr√©√© : ID = ${response.tournament_id}`);
			// Lance la suite (loop + affichage bracket + next match etc.)
			await runTournamentFlow(response.tournament_id);
		} else {
			alert("Erreur : " + response.message);
		}
		} catch (error) {
		console.error("Erreur lors de la cr√©ation du tournoi :", error);
		alert("Une erreur est survenue lors de la cr√©ation du tournoi.");
		}
	});
}

// -- Petites fonctions factorielles pour clarifier --

async function getTournamentForm() {
  const responseGet = await requestGet('game', 'create_tournament');
  if (!responseGet)
	  return false;
  if (responseGet.status === 'success') {
    return responseGet.html;
  } 
  else if (responseGet.status === 'error') {
	showStatusMessage("Erreur lors de la r√©cup√©ration du formulaire du tournoi :", 'error');
	navigateTo('/game-options');
  }
}

async function createTournament(formData) {
  // Appel POST vers /game/create_tournament
  return await requestPost('game', 'create_tournament', formData);
}

// -- Le ‚Äúflow‚Äù du tournoi (r√©cup bracket, next match, etc.) --

async function runTournamentFlow(tournamentId) {
  while (true) {
    // 1) Afficher le bracket
    const bracketResp = await requestGet('game', `tournament_bracket/${tournamentId}`);
    if (!bracketResp || bracketResp.status !== "success") {
      console.error("Impossible de r√©cup√©rer le bracket du tournoi.");
      break;
    }

    console.log(bracketResp);
    updateHtmlContent("#content", bracketResp.html);
	console.log("BRACKET UPDATED\n");
    updateBracketUI(bracketResp)
    await delay(3000);  // Pause de 4s (si vraiment n√©cessaire)
    
    // TODO : si le backend renvoie un champ indiquant ‚Äúfinished‚Äù, sortir de la boucle
    // Exemple si bracketResp renvoie un `tournament_finished: true` ou
    // un champ `tournament_status = "finished"`.
    if (bracketResp.tournament_status === "finished") {
      console.log("Tournoi termin√© (d‚Äôapr√®s bracket).");
      break;
    }
    // 2) R√©cup√©rer les joueurs du prochain match
    const nextResp = await requestGet('game', `tournament_next_game/${tournamentId}`);
    if (!nextResp || nextResp.status !== "success") {
      console.error("Impossible de r√©cup√©rer le prochain match.");
      break;
    }

    if (nextResp.next_match_type === "finished") {
      console.log("Tournoi termin√© (d‚Äôapr√®s next_game).");
      break;
    }

    updateHtmlContent("#content", nextResp.html);
	updateNextGameUI(bracketResp, nextResp);
	TournamentNextMatch();
    await delay(3000);

    // 3) Cr√©er la gameSession de match (semi1, semi2, finale‚Ä¶) en POST
    const gameId = await createTournamentGameSession(tournamentId, nextResp.next_match_type);
    if (!gameId) {
      console.error("Erreur lors de la cr√©ation de la session de match.");
      break;
    }

    // 4) Lancer le liveGame 
    await launchLiveGameWithOptions(gameId, 'both', `start_tournament_game_session/${gameId}`);
  }

  sessionStorage.removeItem('tournamentparams');
  console.log("Fin du flux tournoi");
}


function updateNextGameUI(bracketResp, nextResp) {
	// R√©cup√®re le type de match prochain (ex. "semifinal1", "semifinal2" ou "final")
	const matchType = nextResp.next_match_type;
	
	// Variables pour le joueur de gauche (avatar1) et celui de droite (avatar2)
	let leftPlayerName = "";
	let rightPlayerName = "";
	let leftPlayerAvatar = "";
	let rightPlayerAvatar = "";
	
	// R√©cup√®re le dictionnaire des avatars envoy√© par le serveur
	const avatars = bracketResp.player_avatars;
	
	// Adaptation du switch aux valeurs renvoy√©es par la vue
	switch(matchType) {
	  case "semifinal1":
		leftPlayerName = bracketResp.player1;
		rightPlayerName = bracketResp.player2;
		leftPlayerAvatar = avatars[bracketResp.player1];
		rightPlayerAvatar = avatars[bracketResp.player2];
		break;
	  case "semifinal2":
		leftPlayerName = bracketResp.player3;
		rightPlayerName = bracketResp.player4;
		leftPlayerAvatar = avatars[bracketResp.player3];
		rightPlayerAvatar = avatars[bracketResp.player4];
		break;
	  case "final":
		// Pour le final, on utilise les gagnants des demi-finales
		leftPlayerName = bracketResp.winner_semifinal_1;
		rightPlayerName = bracketResp.winner_semifinal_2;
		leftPlayerAvatar = avatars[bracketResp.winner_semifinal_1] || "/static/svg/default_avatar.svg";
		rightPlayerAvatar = avatars[bracketResp.winner_semifinal_2] || "/static/svg/default_avatar.svg";
		break;
	  default:
		console.error("Type de match inconnu :", matchType);
		return;
	}
	
	// Mise √† jour des √©l√©ments du DOM :
	// avatar1 correspond au joueur de gauche et avatar2 au joueur de droite.
	const leftAvatarImg = document.querySelector(".avatar1 img.avatar");
	const leftNameElem = document.querySelector(".avatar1 .player-name");
	const rightAvatarImg = document.querySelector(".avatar2 img.avatar");
	const rightNameElem = document.querySelector(".avatar2 .player-name");
	
	if (leftAvatarImg) {
	  leftAvatarImg.src = leftPlayerAvatar;
	}
	if (leftNameElem) {
	  leftNameElem.textContent = leftPlayerName;
	}
	if (rightAvatarImg) {
	  rightAvatarImg.src = rightPlayerAvatar;
	}
	if (rightNameElem) {
	  rightNameElem.textContent = rightPlayerName;
	}
	
	console.log("Next match type:", matchType);
	console.log("Gauche :", leftPlayerName, leftPlayerAvatar);
	console.log("Droite :", rightPlayerName, rightPlayerAvatar);
  }



// Met √† jour le bracket en fonction de l'√©tat du tournoi
// Improve remplacer par des balises django dans le front ??
function updateBracketUI(bracketResp) {
	const status = bracketResp.tournament_status;
	const name = bracketResp.tournament_name;
	const winnerSemi1 = bracketResp.winner_semifinal_1;
	const winnerSemi2 = bracketResp.winner_semifinal_2;
	const winnerFinal = bracketResp.winner_final;

	console.log("updateBracketUI status:", status, "winnerSemi1:", winnerSemi1, "winnerSemi2:", winnerSemi2, "winnerFinal:", winnerFinal);
	console.log("updateBracketUI status: eclair ? ",document.querySelector('.eclair.match-1'));
	// R√©cup√®re le dictionnaire des avatars depuis le JSON
	const playerAvatars = bracketResp.player_avatars;
	
	// Mettez √† jour le titre avec le nom du tournoi
    document.querySelector('.title-choosen').textContent = name

	// Masque tous les paragraphes d'√©tat
	document.querySelectorAll('.tournament-title p').forEach(p => p.classList.add('d-none'));
	
	// Mise √† jour des avatars et noms pour chaque joueur
	document.querySelector('[data-player-id="1"] .avatar').src = playerAvatars[bracketResp.player1];
	document.querySelector('[data-player-id="2"] .avatar').src = playerAvatars[bracketResp.player2];
	document.querySelector('[data-player-id="3"] .avatar').src = playerAvatars[bracketResp.player3];
	document.querySelector('[data-player-id="4"] .avatar').src = playerAvatars[bracketResp.player4];
	
	document.querySelector('[data-player-id="1"] .player-name').textContent = bracketResp.player1;
	document.querySelector('[data-player-id="2"] .player-name').textContent = bracketResp.player2;
	document.querySelector('[data-player-id="3"] .player-name').textContent = bracketResp.player3;
	document.querySelector('[data-player-id="4"] .player-name').textContent = bracketResp.player4;
	
	// Affichage contextuel selon l'√©tat du tournoi
	if (status === "pending") {
	  document.querySelector('.tournament-title p:nth-child(2)').classList.remove('d-none'); 
	  document.querySelector('.eclair.match-1').classList.remove('d-none');
	} else if (status === "semifinal1_done") {
	  document.querySelector('.tournament-title p:nth-child(3)').classList.remove('d-none');
	  document.querySelector('.eclair.match-2').classList.remove('d-none');
	} else if (status === "semifinal2_done") {
	  document.querySelector('.tournament-title p:nth-child(4)').classList.remove('d-none');
	  document.querySelector('.eclair.match-3').classList.remove('d-none');
	} else if (status === "finished") {
	  document.querySelector('.tournament-title p:nth-child(5)').classList.remove('d-none');
	}
	
	// Affichage des gagnants des demi-finales
	if (winnerSemi1) {
	  document.querySelector(".winner1").classList.remove("d-none");
	  document.querySelector(".winner1 .avatar").src = playerAvatars[winnerSemi1];
	  document.querySelector(".winner1 .player-name").textContent = winnerSemi1;
	}
	
	if (winnerSemi2) {
	  document.querySelector(".winner2").classList.remove("d-none");
	  document.querySelector(".winner2 .avatar").src = playerAvatars[winnerSemi2];
	  document.querySelector(".winner2 .player-name").textContent = winnerSemi2;
	}
	
	// Affichage du final
	if (winnerFinal) {
	  const finalWinnerElem = document.querySelector(".winner3");
	  finalWinnerElem.classList.remove("d-none");
  
	  let finalAvatar = playerAvatars[winnerFinal];
	  if (!finalAvatar) {
		console.error("Avatar introuvable pour le final winner:", winnerFinal);
		finalAvatar = "/static/svg/default_avatar.svg"; // Avatar par d√©faut
	  } else {
		console.log("Final winner:", winnerFinal, "Avatar URL:", finalAvatar);
	  }
	  
	  document.querySelector(".winner3 .avatar").src = finalAvatar;
	  document.querySelector(".winner3 .winner-name").textContent = winnerFinal;
	}
  }
// Cr√©ation de la session (POST vers /game/create_tournament_game_session/<tournament_id>)
async function createTournamentGameSession(tournamentId, nextMatchType) {
  try {
    const formData = new FormData();
    formData.set('next_match_type', nextMatchType);

    const response = await requestPost(
      'game',
      `create_tournament_game_session/${tournamentId}`,
      formData
    );
    if (response.status === 'success') {
      updateHtmlContent("#content", response.html);
      return response.game_id; // On retourne juste l‚ÄôID
    } else {
      console.error("createTournamentGameSession error:", response.message);
      return null;
    }
  } catch (err) {
    console.error("createTournamentGameSession exception:", err);
    return null;
  }
}


// Petit utilitaire de pause asynchrone
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

===== ./game/tournament_utils.js =====
function updateSvgViewBox(mediaQuery) {
    const svg = document.getElementById('eclair-svg');
    if (!svg) {
        console.warn("L'√©l√©ment 'eclair-svg' est introuvable dans le DOM.");
        return; // Arr√™te la fonction si l'√©l√©ment n'existe pas
    }
    
    console.log("svg passe !");
    if (mediaQuery.matches) {
        svg.setAttribute('viewBox', '150 -50 400 1350'); // Pour petit √©cran
    } else {
        svg.setAttribute('viewBox', '40 -20 650 1300'); // ViewBox originale
    }
}
// Fonction pour changer la taille (width et height) du SVG
 // Fonction pour changer la taille (width et height) du SVG
 function updateSvgSize(mediaQuery) {
	const svg = document.getElementById('eclair-svg');
	if (!svg) {
		console.warn("L'√©l√©ment 'eclair-svg' est introuvable dans le DOM.");
		return;
	}
	if (mediaQuery.matches) {
		svg.setAttribute('width', '30vh'); // Ajust√©e pour petit √©cran
		svg.setAttribute('height', '100vw');
	} else {
		svg.setAttribute('width', '30vw'); // Taille originale
		svg.setAttribute('height', '90vh');
	}
}

// Cr√©ez une media query
const mediaQuery = window.matchMedia("(max-aspect-ratio: 3/3)");

// Fonction principale pour mettre √† jour le SVG
function updateSvg(mediaQuery) {
updateSvgViewBox(mediaQuery); // Mise √† jour de la viewBox
updateSvgSize(mediaQuery);    // Mise √† jour des dimensions
}

export async function TournamentNextMatch(){
// Ajoutez un √©couteur d'√©v√©nements pour les changements de media query
mediaQuery.addEventListener('change', () => updateSvg(mediaQuery));

// Appelez la fonction pour initialiser la bonne viewBox et taille
updateSvg(mediaQuery);

}


===== ./game/handleInvitationGame.js =====
// game/invitations.js
import { requestPost, requestGet }  from '../api/index.js';
import { showStatusMessage, updateHtmlContent } from '../tools/index.js';
import { HTTPError } from '../api/index.js';
import { navigateTo } from '../router.js';

///////////////////////////////
//  PARTIE BURGER MENU
///////////////////////////////
export async function handleGameInvitationBurgerMenu(invitationId, action) {
    try {
        if (action === 'accept') {
            // On appelle AcceptGameInvitationView
            const url = `accept_invitation/${invitationId}`;
            const formData = new FormData();

            const response = await requestPost('game', url, formData);
            if (response.status === 'success') {
                console.log('Invitation accept√©e => session cr√©√©e :', response);
                // Supprime l'invitation de l'UI
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();

                // Rediriger l'utilisateur (B) vers loading (SPA => adapter URL si besoin)
                navigateTo(`/game-loading`);
                //window.location.href = `/game/loading/${response.session.id}`;
            } else {
                console.error('Erreur √† l\'acceptation :', response.message);
            }
        } 
        else if (action === 'decline') {
            // On appelle RespondToInvitationView
            const formData = new FormData();
            formData.append('invitation_id', invitationId);
            formData.append('action', 'decline');

            const response = await requestPost('game', 'respond_to_invitation', formData);
            if (response.status === 'success') {
                console.log('Invitation refus√©e :', response);
                document.querySelector(`[data-invitation-id="${invitationId}"]`)
                    ?.closest('.invitation-item')
                    ?.remove();
            } else {
                console.error('Erreur lors du refus :', response.message);
            }
        }
    } catch (error) {
        console.error('Erreur r√©seau lors du traitement de l\'invitation :', error);
    }
}


///////////////////////////////
//  PARTIE INVITATION ONLINE
///////////////////////////////
let cachedOnlineParams = null;

/**
 * Fonction appel√©e quand on clique sur "Inviter un ami" dans la section "online".
 * On re√ßoit les param√®tres (ball_speed, paddle_size, etc.), on affiche la liste d'amis.
 */
export async function handleInviteGame(onlineParams) {
    console.log('[handleInviteGame] Param√®tres online = ', onlineParams);

    
    try {
        const response = await requestGet('game', 'invite_game');
        if (!response) {
            return;
        }
        cachedOnlineParams = onlineParams;
        if (response.status === 'error') {
            showStatusMessage(response.message, 'error');
        } else {
            updateHtmlContent('#content', response.html);
            // Optionnel : si tu veux lancer le polling direct
                    // (pour que A voie en temps quasi-r√©el l'acceptation)
            startWaitingRoomPolling();
            initializeFriendInvitationBtn();
        }
    } catch (error) {
        if (error instanceof HTTPError) {
            showStatusMessage(error.message, 'error');
        } else {
            showStatusMessage('Une erreur est survenue.', 'error');
        }
        console.error('Erreur handleInviteGame :', error);
    }
}

function initializeFriendInvitationBtn() {
    document.addEventListener('click', async (event) => {
        const btn = event.target.closest('.invite-button');
        if (!btn) return;

        if (event.target.classList.contains('cancel-icon')) {
            event.stopPropagation();
            await cancelInvitation(btn);
            return;
        }

        // Si pas d√©j√† envoy√©
        if (!btn.classList.contains('sent')) {
            await sendInvitation(btn);
        }
    });
}

async function sendInvitation(button) {
    console.log('[sendInvitation] Envoi de l\'invitation...');
    const friendUsername = button.closest('li')?.getAttribute('data-username');
    if (!friendUsername) {
        console.error('Nom d\'utilisateur introuvable.');
        return;
    }

    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    // On inclut les params r√©cup√©r√©s en "cachedOnlineParams"
    if (cachedOnlineParams) {
        formData.append('ball_speed', cachedOnlineParams.ball_speed);
        formData.append('paddle_size', cachedOnlineParams.paddle_size);
        formData.append('bonus_enabled', cachedOnlineParams.bonus_enabled);
        formData.append('obstacles_enabled', cachedOnlineParams.obstacles_enabled);
    } else {
        console.warn('Aucun param√®tre en cache.');
    }

    try {
        // D√©sactiver le bouton pendant l'envoi
        button.disabled = true;

        const response = await requestPost('game', 'send_invitation', formData);
        if (response.status === 'success') {
            button.innerHTML = 'Envoy√© <span class="cancel-icon">&times;</span>';
            button.classList.add('sent');
        } else {
            throw new Error(response.message || 'Erreur inconnue');
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi :', error);
        button.textContent = 'Erreur';
        button.classList.add('error');
        setTimeout(() => {
            button.innerHTML = 'Inviter <span class="cancel-icon d-none">&times;</span>';
            button.classList.remove('error');
        }, 3000);
    } finally {
        // R√©activer le bouton apr√®s la requ√™te
        button.disabled = false;
    }
}

async function cancelInvitation(button) {
    const friendBtn = button.parentElement.querySelector('.friend-btn');
    const friendUsername = friendBtn ? friendBtn.textContent : null;
    if (!friendUsername) return;

    console.log('[cancelInvitation] Annulation invitation √†', friendUsername);
    const formData = new FormData();
    formData.append('friend_username', friendUsername);

    try {
        const response = await requestPost('game', 'cancel_invitation', formData);
        if (response.status === 'success') {
            button.innerHTML = 'Inviter';
            button.classList.remove('sent');
        }
    } catch (error) {
        console.error('Erreur annulation invitation:', error);
    }
}


///////////////////////////////
//  POLLING OPTIONNEL
///////////////////////////////
let pollInterval = null;

export function startWaitingRoomPolling() {
    if (pollInterval) return; // D√©j√† en cours ?

    pollInterval = setInterval(pollInvitations, 3000);
}

async function pollInvitations() {
    try {
        const response = await requestGet('game', 'list_invitations');
        if (response.status === 'success') {
            const sent = response.data.sent_invitations;
            // Chercher si une invitation est accepted + a un session_id
            const accepted = sent.find(inv => inv.status === 'accepted' && inv.session_id != null);

            if (accepted) {
                clearInterval(pollInterval);
                pollInterval = null;

                // Redirige vers /game/loading/<session_id>
                navigateTo(`/game-loading`);
                //window.location.href = `/game/loading/${accepted.session_id}`;
            }
        }
    } catch (error) {
        console.error('Erreur polling invitations:', error);
    }
}

===== ./game/live_game_utils.js =====
// export function isTouchDevice() {
//   return (('ontouchstart' in window) || 
//           (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || 
//           (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0));
// }

  



function handleResize() {
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    const margin = 12; // Marge interne utilis√©e pour le positionnement
    const container = document.querySelector('.game-container');
	const containerHeight = container.clientHeight;
    if (!container) return;

    // Dimensions du conteneur et de la fen√™tre
    const containerWidth = container.clientWidth;
    const windowHeight = window.innerHeight;

    // Calcul du scale en fonction de l'espace disponible
    let scale = Math.min(containerWidth / ORIGINAL_WIDTH, windowHeight * 0.7 / ORIGINAL_HEIGHT);

    // Appliquer le scale sur le canvas (dimension affich√©e)
    canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
    canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';

    // Garder la r√©solution logique du canvas inchang√©e
    canvas.width = ORIGINAL_WIDTH;
    canvas.height = ORIGINAL_HEIGHT;
    
    // Ajuster dynamiquement la hauteur du game-container (en fonction de la largeur)
    container.style.height = Math.min(windowHeight * 0.8, containerWidth / 2) + 'px';

    ctx.imageSmoothingEnabled = false;

    // Utilisation du facteur d'√©chelle pour d'autres ajustements
    const s = scale;

    // Positionnement absolu de score-display par rapport √† game-container
    // On consid√®re que :
    //   - Le canvas est positionn√© en absolute dans le game-container (d√©j√† d√©fini dans votre CSS).
    //   - Le canvas est d√©cal√© d'une marge (margin) par rapport au bord sup√©rieur et gauche du container.
    // On positionne alors le score-display pour qu'il soit centr√© horizontalement sur le bord sup√©rieur du canvas.
    const scoreDisplay = document.getElementById("score-display");
    if (scoreDisplay) {
        // Assurez-vous que le game-container est en position relative (pour que le positionnement absolu se fasse par rapport √† lui)
        container.style.position = "relative";
        // Le canvas devrait √™tre positionn√© en absolute (v√©rifiez votre CSS)
        // R√©cup√©rer la position du canvas par rapport au container (offsetLeft et offsetTop fonctionnent si le container est en position relative)
        const canvasLeft = canvas.offsetLeft;
        const canvasTop = canvas.offsetTop;
        // Calculer la largeur affich√©e du canvas (en pixels)
        const canvasDisplayWidth = ORIGINAL_WIDTH * s;

        // Placer le score-display centr√© sur le bord sup√©rieur du canvas.
        // On fixe sa position verticale √† la m√™me valeur que canvasTop (souvent √©gale √† la marge appliqu√©e)
        // et sa position horizontale au centre du canvas.
        scoreDisplay.style.position = "absolute";
        scoreDisplay.style.left = (canvasLeft + canvasDisplayWidth / 2) + "px";
        scoreDisplay.style.top = (canvasTop + 2) + "px";
        // Pour centrer le score-display par rapport √† son point de positionnement, on d√©cale de 50% de sa largeur.
        scoreDisplay.style.transform = "translate(-50%, 0)";
        scoreDisplay.style.transformOrigin = "center top";

        // On fixe la taille de la police en pixels pour √©viter les fluctuations li√©es aux unit√©s rem
        scoreDisplay.style.fontSize = (30 * s) + "px";
    }
}

window.addEventListener('resize', handleResize);
handleResize(); // Appel initial


function updateScoreDisplay() {
	const scoreEl = document.getElementById("score-nb");
	if (scoreEl) {
	  // Ici, on suppose que les noms sont d√©j√† inject√©s via Django dans le HTML.
	  // Par exemple, on pourrait avoir utilis√© des attributs data pour conserver ces noms.
	  // Si ce n'est pas le cas, vous pouvez √©galement d√©finir des variables globales inject√©es par Django.
	  // Ici, nous allons lire le texte initial et remplacer uniquement la partie num√©rique.
	  // Pour plus de flexibilit√©, vous pouvez modifier cette fonction selon vos besoins.
	  // Exemple avec des attributs data (optionnel) :
	  scoreEl.innerText = ` ${gameState.score_left} - ${gameState.score_right} `;
	}
  }

  updateScoreDisplay();
===== ./game/live_game.js =====
/* live_game.js
 *
 * Centralise les fonctions communes pour :
 * dessiner le canvas, les bumpers et les powerups
 * lancer le jeu en co-routine avec le bouton startGame 
 * recevoir les notifications (envoy√©es par broadcast.py > consumers.py > websocket)
 *    detecter la position de tous les elements de jeu (gameState)
 *    afficher des animations aux lieux d'impacts de la balle /lieux d'apparition des bumpers et powerups 
 * 
 */

import { requestPost } from '../api/index.js';
import { createPowerupSVG, createBumperSVG } from './live_game_svg.js';
import { isTouchDevice } from "../tools/index.js";


export async function launchLiveGameWithOptions(gameId, userRole, urlStartButton) {
  const protocol = (window.location.protocol === 'https:') ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws/pong/${gameId}/`;

  let startGameSelector = null;
  let onStartGame = null;
  
  console.log(`userRole = ${userRole}`);
  if (urlStartButton) {
    // S√©lectionner l'√©l√©ment DOM correspondant au bouton de d√©marrage
    startGameSelector = document.querySelector("#startGameBtn");
    // V√©rifier que l'√©l√©ment a bien √©t√© trouv√©
    if (!startGameSelector) {
      console.error("L'√©l√©ment avec le s√©lecteur '#startGameBtn' n'a pas √©t√© trouv√©.");
    }
    
    onStartGame = async (gameId) => {
      // Assurez-vous que startGameSelector est bien un √©l√©ment DOM avant d'acc√©der √† classList
      if (startGameSelector) {
        startGameSelector.classList.add('d-none');
      }
      const url = urlStartButton;
      const formData = new FormData();
      formData.append('game_id', gameId);
      formData.append('userRole', userRole);
  
      const response = await requestPost('game', url, formData);
      if (response.status !== 'success') {
        alert("Erreur lors du d√©marrage : " + response.message);
      }
    };
  }

  // fonction qui gere toute la logique de jeu √† partir de notre config
  return initLiveGame({
    gameId,
    userRole,
    wsUrl,
    startGameSelector,
    onStartGame
  });
}


  // ========== initPowerupImages ==========
  
  function initPowerupImages(powerupImages) {
    // Initialise la map de type => Image()
    Object.keys(powerupImages).forEach(type => {
      powerupImages[type].src = createPowerupSVG(type);
    });
  }
  
  // ========== applyFlashEffect ==========
  
  function applyFlashEffect(gameState, duration = 300) {
    gameState.flash_effect = true;
    setTimeout(() => {
      gameState.flash_effect = false;
    }, duration);
  }



// ========== La grosse fonction initLiveGame ==========

/**
 * Initialise un "live game" (local ou online) dans le canvas.
 * @param {Object} config 
 *    config.gameId  : string
 *    config.userRole: "left" | "right" | "both"   // ex: "both" = local, "left" ou "right" = online
 *    config.wsUrl   : URL du WebSocket
 *    config.startGameSelector?: ID du bouton (ex: "#startGameBtn")
 *    config.onStartGame?: Function de callback pour lancer la partie 
 *                         (ex: faire un POST sur /start_online_game/ ou /start_local_game/)
   */
function initLiveGame(config) {
  return new Promise((resolve) => {
    // 1) Pr√©parer les √©l√©ments HTML
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startGameBtn = config.startGameSelector;
    console.log("Appareil tactile ?", isTouchDevice());
    cleanupGamePage();
    setupGamePage();
    // 2) G√©rer le bouton "Start" (optionnel)
    if (startGameBtn && config.onStartGame) {
      // D√©bloquer le bouton apr√®s 3s (optionnel)
  //     setTimeout(() => { 
	// 	startGameBtn.style.opacity = "0.7";
  //       startGameBtn.disabled = false;
	    startGameBtn.classList.add("active");
	
	// }, 3000);
  
      // Clic => on appelle la callback onStartGame
      startGameBtn.addEventListener('click', async () => {
        await config.onStartGame()
        // await startGameWithCountdown(startGameBtn, config.onStartGame, config.gameId);
      });
    }



	// Draw visual effects / added
	function drawCollisionEffects() {
		collisionEffects.forEach(effect => {
			const age = effect.type.includes('spawn') ?
			  Date.now() - effect.startTime :
			  Date.now() - effect.startTime;
			const duration = effect.type.includes('spawn') ?
			  SPAWN_EFFECT_DURATION :
			  EXPIRE_EFFECT_DURATION;
			const progress = age / duration;
  
			ctx.save();
			ctx.globalAlpha = 1 - progress;
  
			switch(effect.type) {
				case 'paddle_collision':
					// Ripple effect
					const rippleSize = 20 + (progress * 40);
					ctx.strokeStyle = 'white';
					ctx.lineWidth = 3 * (1 - progress);
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, rippleSize, 0, Math.PI * 2);
					ctx.stroke();
					break;
  
				// case 'border_collision':
				//     // Simple glow effect at collision point
				//     const glowSize = 20 * (1 - progress);
				//     ctx.shadowColor = 'white';
				//     ctx.shadowBlur = 15 * (1 - progress);
					
				//     ctx.beginPath();
				//     ctx.arc(effect.x, effect.border_side === 'up' ? 50 : 350, glowSize, 0, Math.PI * 2);
				//     ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - progress) + ')';
				//     ctx.fill();
				//     break;
  
				case 'bumper_collision':
					// Explosion effect
					const numParticles = 8;
					const radius = 30 * progress;
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 3 * (1 - progress);
					
					for (let i = 0; i < numParticles; i++) {
						const angle = (i / numParticles) * Math.PI * 2;
						const startX = effect.x + Math.cos(angle) * 10;
						const startY = effect.y + Math.sin(angle) * 10;
						const endX = effect.x + Math.cos(angle) * radius;
						const endY = effect.y + Math.sin(angle) * radius;
						
						ctx.beginPath();
						ctx.moveTo(startX, startY);
						ctx.lineTo(endX, endY);
						ctx.stroke();
					}
					break;
				case 'powerup_spawn':
					// Expanding circles with powerup color
					const circles = 3;
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2;
					
					for (let i = 0; i < circles; i++) {
						const circleProgress = (progress + (i / circles)) % 1;
						const radius = circleProgress * 40;
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
						ctx.stroke();
					}
  
					// Add sparkles
					const sparkles = 8;
					for (let i = 0; i < sparkles; i++) {
						const angle = (i / sparkles) * Math.PI * 2;
						const sparkleDistance = 20 + (progress * 20);
						const x = effect.x + Math.cos(angle) * sparkleDistance;
						const y = effect.y + Math.sin(angle) * sparkleDistance;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fillStyle = effect.color;
						ctx.fill();
					}
					break;
  
				case 'powerup_expire':
					// Imploding effect
					const fadeRadius = 20 * (1 - progress);
					ctx.strokeStyle = effect.color;
					ctx.lineWidth = 2 * (1 - progress);
					
					// Shrinking circle
					ctx.beginPath();
					ctx.arc(effect.x, effect.y, fadeRadius, 0, Math.PI * 2);
					ctx.stroke();
					
					// Particles moving inward
					const particles = 6;
					for (let i = 0; i < particles; i++) {
						const angle = (i / particles) * Math.PI * 2;
						const distance = fadeRadius * 2;
						const x = effect.x + Math.cos(angle) * distance * progress;
						const y = effect.y + Math.sin(angle) * distance * progress;
						
						ctx.beginPath();
						ctx.arc(x, y, 2, 0, Math.PI * 2);
						ctx.fill();
					}
					break;
  
				case 'bumper_spawn':
					// Expanding diamond pattern
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2;
					const size = 40 * progress;
					const rotation = progress * Math.PI;
					
					ctx.translate(effect.x, effect.y);
					ctx.rotate(rotation);
					
					// Inner diamond
					ctx.beginPath();
					ctx.moveTo(0, -size);
					ctx.lineTo(size, 0);
					ctx.lineTo(0, size);
					ctx.lineTo(-size, 0);
					ctx.closePath();
					ctx.stroke();
					
					// Outer diamond
					ctx.beginPath();
					ctx.moveTo(0, -size * 1.5);
					ctx.lineTo(size * 1.5, 0);
					ctx.lineTo(0, size * 1.5);
					ctx.lineTo(-size * 1.5, 0);
					ctx.closePath();
					ctx.stroke();
					break;
  
				case 'bumper_expire':
					// Dissolving rings effect
					ctx.strokeStyle = '#4169E1';
					ctx.lineWidth = 2 * (1 - progress);
					
					const rings = 3;
					for (let i = 0; i < rings; i++) {
						const ringProgress = (progress + (i / rings)) % 1;
						const ringRadius = 20 * ringProgress;
						
						ctx.beginPath();
						ctx.arc(effect.x, effect.y, ringRadius, 0, Math.PI * 2);
						ctx.stroke();
						
						// Add dissolving particles
						const particleCount = 8;
						for (let j = 0; j < particleCount; j++) {
							const particleAngle = (j / particleCount) * Math.PI * 2;
							const distance = ringRadius * (1 + progress);
							const px = effect.x + Math.cos(particleAngle) * distance;
							const py = effect.y + Math.sin(particleAngle) * distance;
							
							ctx.fillStyle = '#4169E1';
							ctx.fillRect(px - 1, py - 1, 2, 2);
						}
					}
					break;
			}
			ctx.restore();
		});
	}


	function drawCountdown() {
    if (typeof gameState.countdown !== 'undefined') {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
  
      ctx.fillStyle = 'white';
      ctx.font = 'bold 80px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillText(gameState.countdown, canvas.width / 2, canvas.height / 3);
      ctx.restore();
    }
	}
  
    // 3) Mise en place du redimensionnement du canvas
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 400;
    let scale = 1;

	    // Const for visual effects on notifications / added
		const collisionEffects = [];
		const EFFECT_DURATION = 300;
		const SPAWN_EFFECT_DURATION = 500;
		const EXPIRE_EFFECT_DURATION = 300;
	  
		// spawn visual effect / added
		function createSpawnEffect(type, x, y, effectType, color) {
		  const effect = {
			  type,
			  x,
			  y,
			  effectType,
			  color: color || '#FFFFFF',
			  startTime: Date.now(),
			  alpha: 1
		  };
		  collisionEffects.push(effect);
		  
		  setTimeout(() => {
			  const index = collisionEffects.indexOf(effect);
			  if (index > -1) {
				  collisionEffects.splice(index, 1);
			  }
		  }, type.includes('spawn') ? SPAWN_EFFECT_DURATION : EXPIRE_EFFECT_DURATION);
	  }
	
	  // collision visual effects / added
	  function createCollisionEffect(type, x, y, color) {
		const effect = {
			type,
			x,
			y,
			color,
			startTime: Date.now(),
			alpha: 1
		};
		collisionEffects.push(effect);
		
		// Remove effect after duration
		setTimeout(() => {
			const index = collisionEffects.indexOf(effect);
			if (index > -1) {
				collisionEffects.splice(index, 1);
			}
		}, EFFECT_DURATION);
	  }

    
      // --- Pour g√©rer l'orientation sur mobile tactile ---
    function onOrientationChange() {
      // Petit d√©lai si besoin pour que la taille soit bien mise √† jour
      setTimeout(handleresizeTactile, 200);
    }

    // --- Setup de la page de jeu ---
   async function setupGamePage() {
      if (isTouchDevice()) {
        console.log("Mode tactile activ√©");
        window.addEventListener('resize', handleresizeTactile);
        window.addEventListener('orientationchange', onOrientationChange);
        handleresizeTactile();
      } else {
        console.log("Mode non tactile activ√©");
        window.addEventListener('resize', handleResize);
        handleResize();
      }
    }

    // --- Cleanup de la page de jeu ---
    function cleanupGamePage() {
      if (isTouchDevice()) {
        window.removeEventListener('resize', handleresizeTactile);
        window.removeEventListener('orientationchange', onOrientationChange);
      } else {
        window.removeEventListener('resize', handleResize);
      }
    }
      
    function handleResize() {
      const ORIGINAL_WIDTH = 800;
      const ORIGINAL_HEIGHT = 400;
      const margin = 12; // Marge interne utilis√©e pour le positionnement
      const container = document.querySelector('.game-container');
      if (!container) return;
  
      // Dimensions du conteneur et de la fen√™tre
      const containerWidth = container.clientWidth;
      const windowHeight = window.innerHeight;
  
      // Calcul du scale en fonction de l'espace disponible
      let scale = Math.min(containerWidth / ORIGINAL_WIDTH, windowHeight * 0.7 / ORIGINAL_HEIGHT);
  
      // Appliquer le scale sur le canvas (dimension affich√©e)
      canvas.style.width = (ORIGINAL_WIDTH * scale) + 'px';
      canvas.style.height = (ORIGINAL_HEIGHT * scale) + 'px';
  
      // Garder la r√©solution logique du canvas inchang√©e
      canvas.width = ORIGINAL_WIDTH;
      canvas.height = ORIGINAL_HEIGHT;
      
      // Ajuster dynamiquement la hauteur du game-container (en fonction de la largeur)
      container.style.height = Math.min(windowHeight * 0.8, containerWidth / 2) + 'px';
  
      ctx.imageSmoothingEnabled = false;
  
      // Utilisation du facteur d'√©chelle pour d'autres ajustements
      const s = scale;
  
      // Positionnement absolu de score-display par rapport √† game-container
      // On consid√®re que :
      //   - Le canvas est positionn√© en absolute dans le game-container (d√©j√† d√©fini dans votre CSS).
      //   - Le canvas est d√©cal√© d'une marge (margin) par rapport au bord sup√©rieur et gauche du container.
      // On positionne alors le score-display pour qu'il soit centr√© horizontalement sur le bord sup√©rieur du canvas.
      const scoreDisplay = document.getElementById("score-display");
      if (scoreDisplay) {
          // Assurez-vous que le game-container est en position relative (pour que le positionnement absolu se fasse par rapport √† lui)
          container.style.position = "relative";
          // Le canvas devrait √™tre positionn√© en absolute (v√©rifiez votre CSS)
          // R√©cup√©rer la position du canvas par rapport au container (offsetLeft et offsetTop fonctionnent si le container est en position relative)
          const canvasLeft = canvas.offsetLeft;
          const canvasTop = canvas.offsetTop;
          // Calculer la largeur affich√©e du canvas (en pixels)
          const canvasDisplayWidth = ORIGINAL_WIDTH * s;
  
          // Placer le score-display centr√© sur le bord sup√©rieur du canvas.
          // On fixe sa position verticale √† la m√™me valeur que canvasTop (souvent √©gale √† la marge appliqu√©e)
          // et sa position horizontale au centre du canvas.
          scoreDisplay.style.position = "absolute";
          scoreDisplay.style.left = (canvasLeft + canvasDisplayWidth / 2) + "px";
          scoreDisplay.style.top = (canvasTop + 2) + "px";
          // Pour centrer le score-display par rapport √† son point de positionnement, on d√©cale de 50% de sa largeur.
          scoreDisplay.style.transform = "translate(-50%, 0)";
          scoreDisplay.style.transformOrigin = "center top";
  
          // On fixe la taille de la police en pixels pour √©viter les fluctuations li√©es aux unit√©s rem
          scoreDisplay.style.fontSize = (30 * s) + "px";
      }
  }


  function handleresizeTactile() {
    // Dimensions internes du canvas (logique du jeu inchang√©e)
    const ORIGINAL_WIDTH = 800;   // Utilis√© pour la hauteur du terrain (apr√®s rotation)
    const ORIGINAL_HEIGHT = 400;  // Utilis√© pour la largeur du terrain (apr√®s rotation)
    const margin = 20;            // Marge interne dans la game-container
    const horizontalExtra = 2 * margin; // 40px au total
    const baseControlHeight = 100; // Hauteur de base des boutons pour s = 1

    // Pour le calcul vertical total, on tient compte de :
    // - La hauteur affich√©e du terrain : ORIGINAL_WIDTH * s + horizontalExtra
    // - La hauteur du conteneur des boutons : baseControlHeight * s
    // - Le padding vertical du conteneur principal (#livegame) : 20 top + 20 bottom = 40
    // - Une marge fixe entre terrain et boutons : 5px
    // Total vertical = 800*s + 40 + 100*s + 45 = 900*s + 85
    const verticalExtra = 85;

    // Pour le calcul horizontal, nous utilisons la largeur disponible dans la colonne Bootstrap.
    const parentCol = document.getElementById('game-col');
    const availableWidth = parentCol ? parentCol.clientWidth : window.innerWidth;

    // Calcul de l'√©chelle horizontal : la largeur affich√©e du terrain sera ORIGINAL_HEIGHT * s + horizontalExtra
    const s_h = (availableWidth - horizontalExtra) / ORIGINAL_HEIGHT;

    // Calcul de l'√©chelle vertical : l'espace total requis verticalement est 900*s + 85, qui doit tenir dans window.innerHeight.
    const s_v = (window.innerHeight - verticalExtra) / 900;

    // On prend le facteur le plus contraignant
    const computedS = Math.min(s_h, s_v);

    // Calcul de l'√©chelle minimale pour que le terrain ait au moins 100px de largeur et 200px de hauteur.
    const sMinWidth = (100 - horizontalExtra) / ORIGINAL_HEIGHT;   // (100 - 40)/400 = 0.15
    const sMinHeight = (200 - horizontalExtra) / ORIGINAL_WIDTH;    // (200 - 40)/800 = 0.2
    const sMin = Math.max(sMinWidth, sMinHeight); // ici sMin = 0.2

    // On s'assure que l'√©chelle ne descend pas en dessous de sMin.
    const s = Math.max(computedS, sMin);

    // Mise √† jour des dimensions du game-container (terrain)
    const gameContainer = document.querySelector('.game-container');
    if (!gameContainer) {
      console.error("L'√©l√©ment '.game-container' est introuvable dans le DOM.");
      return;
    }
    gameContainer.style.width = (ORIGINAL_HEIGHT * s + horizontalExtra) + "px"; // 400*s + 40
    gameContainer.style.height = (ORIGINAL_WIDTH * s + horizontalExtra) + "px";  // 800*s + 40

    // Transformation du canvas pour le rendre vertical :
    const canvas = document.getElementById('gameCanvas');
    canvas.style.transform =
      `translate(${margin}px, ${margin}px) translateY(${ORIGINAL_WIDTH * s}px) rotate(-90deg) scale(${s})`;

    // Mise √† jour de la hauteur du conteneur des boutons (touch-controls) en fonction de l'√©chelle.
    const controls = document.getElementById('left_player');
    const controlHeight = baseControlHeight * s;
    if (controls) {
      controls.style.height = controlHeight + "px";
    }

    // Transmet l'√©chelle aux boutons via la variable CSS --btn-scale pour qu'ils se redimensionnent proportionnellement.
    document.documentElement.style.setProperty('--btn-scale', s);

    // Mise √† jour de la position de la zone de score pour l'accrocher entre le bord du game-container et celui du canvas (sans rotation)
const scoreDisplay = document.getElementById("score-display");
if (scoreDisplay) {
    // On souhaite que le score soit positionn√© de sorte que son centre soit √† mi-distance
    // entre le bord gauche du game-container (0) et le bord gauche du canvas (qui est √† "margin" pixels)
    const posX = margin / 2;  // Ceci correspond au point milieu horizontal
    // Pour le centrage vertical, on se base sur la hauteur actuelle du game-container.
    const posY = gameContainer.clientHeight / 2;
    
    // Positionnement absolu dans le game-container :
    scoreDisplay.style.left = posX + "px";
    scoreDisplay.style.top = posY + "px";
    
    // Appliquer un translate(-50%, -50%) pour que le centre de la zone corresponde √† ce point,
    // sans aucune rotation (le texte reste dans son orientation normale)
    scoreDisplay.style.transform = "translate(-50%, -50%)";
    scoreDisplay.style.transformOrigin = "center";
    
    // Adaptez la taille de la police en fonction du scale, pour qu'elle reste proportionnelle
    scoreDisplay.style.fontSize = (1.5 * s) + "rem";
}

}
  
    // 4) Initialiser WebSocket
    const socket = new WebSocket(config.wsUrl);
    
    socket.onopen = () => {
      console.log("[live_game_utils] WebSocket connection opened:", config.wsUrl);
      initializeTouchControls(config.userRole, socket);
    };
    socket.onclose = () => {
      console.log("[live_game_utils] WebSocket connection closed.");
    };
  
    // 5) G√©rer l'√©tat du jeu local
    const activeEffects = { left: new Set(), right: new Set() };
    const effectTimers = {};
    let gameState = {
      type: 'game_state',
      ball_x: 400, 
      ball_y: 200,
      ball_size: 7,
      ball_speed_x: 4,
      ball_speed_y: 4,
      paddle_left_y: 170,
      paddle_right_y: 170,
      paddle_width: 10,
      paddle_left_height: 60,
      paddle_right_height: 60,
      score_left: 0, 
      score_right: 0,
      powerups: [],
      bumpers: [],
      flash_effect: false
    };
	// let showCountdown = false;
    // let countdownNumber = 3;
  
    // 6) G√©rer la r√©ception de messages WebSocket
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
  
      if (data.type === 'game_state') {
        // M√©moriser les effets actifs avant maj
        const prevLeft = new Set(activeEffects.left);
        const prevRight = new Set(activeEffects.right);
        gameState = data;
        // R√©injecter
        activeEffects.left = prevLeft;
        activeEffects.right = prevRight;
      }  else if (data.type === 'powerup_spawned') {
		const powerupColor = {
			'invert': '#FF69B4',
			'shrink': '#FF0000',
			'ice': '#00FFFF',
			'speed': '#FFD700',
			'flash': '#FFFF00',
			'sticky': '#32CD32'
		}[data.powerup.type] || '#FFFFFF';
		
		createSpawnEffect('powerup_spawn', 
			data.powerup.x, 
			data.powerup.y, 
			data.powerup.type,
			powerupColor);
	  } else if (data.type === 'powerup_expired') {
		createSpawnEffect('powerup_expire',
			data.powerup.x,
			data.powerup.y,
			data.powerup.type);
		} else if (data.type === 'bumper_spawned') {
			createSpawnEffect('bumper_spawn',
				data.bumper.x,
				data.bumper.y);
			
		} else if (data.type === 'bumper_expired') {
			createSpawnEffect('bumper_expire',
				data.bumper.x,
				data.bumper.y);
    } else if (data.type === 'countdown') {
      // Stocker le compte √† rebours dans le gameState
      gameState.countdown = data.countdown_nb;
      // drawCountdown(data.countdown_nb);
		} else if (data.type === 'collision_event') {
			const collision = data.collision;
			switch(collision.type) {
				case 'paddle_collision':
					createCollisionEffect('paddle_collision', 
						collision.paddle_side === 'left' ? 60 : canvas.width - 60, 
						gameState.ball_y);
					break;
					
				case 'border_collision':
					createCollisionEffect('border_collision',
						collision.coor_x_collision,
						collision.border_side === 'up' ? 50 : 350);
					break;
					
				case 'bumper_collision':
					createCollisionEffect('bumper_collision',
						collision.bumper_x,
						collision.bumper_y);
					break;
			}
		}
		else if (data.type === 'game_over') {
        console.log("[live_game_utils] Game over detected");
        // alert("Game Over! Winner = " + data.winner);
        socket.close();
        resolve();  // üîπ Signale √† `runTournamentFlow()` que la partie est termin√©e
      }
      else if (data.type === 'powerup_applied') {
        // console.log(`[live_game_utils] Power-up applied to ${data.player}: ${data.effect}`);
        if (data.effect === 'flash') {
          applyFlashEffect(gameState);
          return;
        }
        let displaySide = data.player;
        if (!['speed','sticky'].includes(data.effect)) {
          // Les autres s'appliquent √† l'adversaire
          displaySide = (data.player === 'left') ? 'right' : 'left';
        }
        activeEffects[displaySide].add(data.effect);
  
        // Timer pour retirer l'effet
        if (effectTimers[`${displaySide}_${data.effect}`]) {
          clearTimeout(effectTimers[`${displaySide}_${data.effect}`]);
        }
        effectTimers[`${displaySide}_${data.effect}`] = setTimeout(() => {
          console.log(`[live_game_utils] Removing effect ${data.effect} for ${displaySide}`);
          activeEffects[displaySide].delete(data.effect);
        }, data.duration * 1000);
      }
    };
  
    // 7) G√©rer le clavier et les touches tactiles
    function initializeTouchControls(userRole, socket) {
      // On active les contr√¥les tactiles uniquement si on est en mode tactile
      if (!isTouchDevice()) return; // Si pas tactile, on ne fait rien ici.
    
      // Gestion globale du double tap pour emp√™cher le zoom
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
          // Si deux touchend se succ√®dent rapidement, on annule l'action par d√©faut
          e.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
    
      // S√©lectionnez les boutons par leur id
      const btnUp = document.getElementById("touch1");
      const btnDown = document.getElementById("touch2");
    
      // V√©rifiez que les boutons existent
      if (!btnUp || !btnDown) {
        console.error("Les boutons tactiles ne sont pas d√©finis dans le DOM.");
        return;
      }
    
      // Pour le bouton "up"
      btnUp.addEventListener('touchstart', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "up"
        }));
      });
      btnUp.addEventListener('touchend', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "stop_move",
          player: userRole
        }));
      });
      // Optionnel pour le clic (au cas o√π)
      btnUp.addEventListener('click', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "up"
        }));
        setTimeout(() => {
          socket.send(JSON.stringify({
            action: "stop_move",
            player: userRole
          }));
        }, 200);
      });
    
      // Pour le bouton "down"
      btnDown.addEventListener('touchstart', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "down"
        }));
      });
      btnDown.addEventListener('touchend', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "stop_move",
          player: userRole
        }));
      });
      btnDown.addEventListener('click', (e) => {
        e.preventDefault();
        socket.send(JSON.stringify({
          action: "start_move",
          player: userRole,
          direction: "down"
        }));
        setTimeout(() => {
          socket.send(JSON.stringify({
            action: "stop_move",
            player: userRole
          }));
        }, 200);
      });
    }    

    if (!isTouchDevice()) {
    const keysPressed = {};
  
    document.addEventListener('keydown', (evt) => {
      if (evt.repeat) return;
      let action = "start_move";
      let player = null, direction = null;
  

      if (config.userRole === 'both') {
        switch(evt.key) {
          case 'w':
          case 'W':
            player = 'left';
            direction = 'up';
            break;
          case 's':
          case 'S':
            player = 'left';
            direction = 'down';
            break;
          case 'ArrowUp':
            player = 'right';
            direction = 'up';
            break;
          case 'ArrowDown':
            player = 'right';
            direction = 'down';
            break;
        }
      }
	  else if (config.userRole === 'right') {
        switch(evt.key) {
			case 'ArrowUp':
			  player = 'right';
			  direction = 'up';
			  break;
			case 'ArrowDown':
			  player = 'right';
			  direction = 'down';
			  break;
		  }
      }
      else if (config.userRole === 'left') {
        switch(evt.key) {
          case 'ArrowUp':
            player = 'left';
            direction = 'up';
            break;
          case 'ArrowDown':
            player = 'left';
            direction = 'down';
            break;
        }
      }
  
      if (player && direction && !keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player, direction }));
        }
        keysPressed[evt.key] = true;
        // console.log(`[live_game_utils] start_move: ${player}, ${direction}`);
      }
    });
  
    document.addEventListener('keyup', (evt) => {
      let action = "stop_move";
      let player = null;
  
      if (config.userRole === 'both') {
        if (['w','W','s','S'].includes(evt.key)) {
          player = 'left';
        }
      }
      
      if ((config.userRole === 'both' || config.userRole === 'right' || config.userRole === 'left') && !player) {
        if (['ArrowUp','ArrowDown'].includes(evt.key)) {
          if(config.userRole === 'both' || config.userRole === 'right')
		  	player = 'right';
		  else if(config.userRole === 'left')
		  	player = 'left';
        }
      }
  
      if (player && keysPressed[evt.key]) {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ action, player}));
        }
        keysPressed[evt.key] = false;
        // console.log(`[live_game_utils] stop_move: ${player}`);
      }
    });
  }


    
  
    // 8) Pr√©parer les images powerups/bumper
    const powerupImages = {
      'invert': new Image(),
      'shrink': new Image(),
      'ice': new Image(),
      'speed': new Image(),
      'flash': new Image(),
      'sticky': new Image()
    };
    initPowerupImages(powerupImages);
  
    const bumperImage = new Image();
    bumperImage.src = createBumperSVG();


	// // -- Fonction pour d√©marrer la partie
  //   async function startGameWithCountdown(startGameBtn, onStartGame, gameId) {
	// 	showCountdown = true;
	// 	startGameBtn.classList.add('d-none');
		
	// 	// Start countdown animation
	// 	let count = 3;
		
	// 	// Function to update the countdown
  //   const updateCount = async () => {
	// 		countdownNumber = count;
	// 		count--;
			
	// 		if (count < 0) {
	// 			clearInterval(countdownInterval);
	// 			showCountdown = false;
	// 			// onStartGame && await onStartGame(gameId);
	// 		}
	// 	};
	
	// 	// Show first number immediately
	// 	updateCount();
		
	// 	// Then update every second
	// 	const countdownInterval = setInterval(updateCount, 1000);
	// }

  // async function displayCountdownNumber(countdown_nb, startGameBtn) {
	// 	showCountdown = true;
    
	// 	drawCountdown(countdown_nb)
		// Start countdown animation
		// let count = 3;
		
		// // Function to update the countdown
    // const updateCount = async () => {
		// 	countdownNumber = count;
		// 	count--;
			
		// 	if (count < 0) {
		// 		clearInterval(countdownInterval);
		// 		showCountdown = false;
		// 		// onStartGame && await onStartGame(gameId);
		// 	}
		// };
	
		// // Show first number immediately
		// updateCount();
		
		// // Then update every second
		// const countdownInterval = setInterval(updateCount, 1000);
	// }
  
    // 9) La boucle de dessin
    function draw() {
      if (gameState.flash_effect) {
        ctx.fillStyle = 'white';
        ctx.fillRect(0,0,canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#101A32';
        ctx.fillRect(0,0,canvas.width, canvas.height);
  
        // Zone de jeu
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(50,50, canvas.width-100, canvas.height-100);
  
        // Dessin raquettes
        ['left','right'].forEach(side => {
          ctx.save();
          if (activeEffects[side].size > 0) {
            activeEffects[side].forEach(effect => {
              const glowColor = {
                'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
                'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
              }[effect];
              ctx.shadowColor = glowColor;
              ctx.shadowBlur = 10 * scale;
            });
          }
          ctx.fillStyle = 'white';
          if (side==='left') {
            ctx.fillRect(50, gameState.paddle_left_y,
                        gameState.paddle_width, gameState.paddle_left_height);
          } else {
            ctx.fillRect(canvas.width-50 - gameState.paddle_width, 
                        gameState.paddle_right_y,
                        gameState.paddle_width, gameState.paddle_right_height);
          }
          ctx.restore();
        });
  
        // Balle
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(gameState.ball_x, gameState.ball_y, gameState.ball_size, 0, 2*Math.PI);
        ctx.fill();
  
        // Powerups
        gameState.powerups.forEach(orb => {
          const type = orb.type || 'speed';
          const img = powerupImages[type];
          if (img.complete) {
            ctx.save();
            const glowColors = {
              'invert':'#FF69B4','shrink':'#FF0000','ice':'#00FFFF',
              'speed':'#FFD700','flash':'#FFFF00','sticky':'#32CD32'
            };
            ctx.shadowColor = glowColors[type] || '#FFD700';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(img, orb.x - 15, orb.y - 15, 30, 30);
            ctx.restore();
          }
        });
  
        // Bumpers
        gameState.bumpers.forEach(bmp => {
          if (bumperImage.complete) {
            ctx.save();
            ctx.shadowColor = '#4169E1';
            ctx.shadowBlur = 10 * scale;
            ctx.drawImage(bumperImage,
              bmp.x - bmp.size, bmp.y - bmp.size,
              bmp.size*2, bmp.size*2
            );
            ctx.restore();
          }
        });
      }
  
      // Scores
      // ctx.fillStyle = 'white';
      // ctx.font = '20px Arial';
      // ctx.fillText(""+ gameState.score_left, 20, 30);
      // ctx.fillText(""+ gameState.score_right, canvas.width-40, 30);
      
      function updateScoreDisplay() {
        const scoreEl = document.getElementById("score-nb");
        if (scoreEl) {
          // Ici, on suppose que les noms sont d√©j√† inject√©s via Django dans le HTML.
          // Par exemple, on pourrait avoir utilis√© des attributs data pour conserver ces noms.
          // Si ce n'est pas le cas, vous pouvez √©galement d√©finir des variables globales inject√©es par Django.
          // Ici, nous allons lire le texte initial et remplacer uniquement la partie num√©rique.
          // Pour plus de flexibilit√©, vous pouvez modifier cette fonction selon vos besoins.
          // Exemple avec des attributs data (optionnel) :
          scoreEl.innerText = ` ${gameState.score_left} - ${gameState.score_right} `;
        }
        }

      // Affichage powerups actifs
      const powerupNames = {
        'speed':'SPEED','shrink':'SHRINK','ice':'ICE','sticky':'STICKY','invert':'INVERT'
      };
      // Gauche
      if (activeEffects.left.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.left.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          ctx.fillText(powerupNames[effect], 20, yOffset);
          yOffset+=25;
        });
      }
      // Droite
      if (activeEffects.right.size > 0) {
        ctx.font='16px Arial';
        let yOffset=60;
        activeEffects.right.forEach(effect => {
          ctx.fillStyle = {
            'speed':'#FFD700','shrink':'#FF0000','ice':'#00FFFF',
            'sticky':'#32CD32','invert':'#FF69B4','flash':'#FFFF00'
          }[effect];
          const tW = ctx.measureText(powerupNames[effect]).width;
          ctx.fillText(powerupNames[effect], canvas.width-20 - tW, yOffset);
          yOffset+=25;
        });
      }
    updateScoreDisplay();
	  drawCollisionEffects();
	  drawCountdown();
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  
    // on peut retourner un objet si on veut
    return {
      socket,
      getGameState: () => gameState
    };
  });
}
  
===== ./landing/coreHome.js =====
import { requestGet } from '../api/index.js';
import { HTTPError } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

function attachNavigationEvents() {
    const loginBtn = document.querySelector('#login-btn');
    if (loginBtn) {
        loginBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('login clicked');
            navigateTo('/login'); // Utiliser Navigo pour naviguer
        });
    }

    const registerBtn = document.querySelector('#register-btn');
    if (registerBtn) {
        registerBtn.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('register clicked');
            navigateTo('/register'); // Utiliser Navigo pour naviguer
        });
    }
}

export async function initializeHomeView() {
    console.log('initializeHomeView');
    try {
        const data = await requestGet('core', 'home');

        if (data && data.html) {
            updateHtmlContent('#content', data.html);
        } else {
            console.error("Les donn√©es HTML de la page d'accueil sont manquantes.");
            showStatusMessage("Impossible de charger la page d'accueil.", 'error');
            return;
        }

    } catch (error) {
        if (error instanceof HTTPError) {
            if (error.status === 403) {
                console.error('Erreur 403 : Utilisateur d√©j√† authentifi√©');
                showStatusMessage('Vous √™tes d√©j√† connect√©. Redirection...', 'error');
                navigateTo('/home');
                return;
            }
        } else {
            console.error('Erreur non trait√©e lors de la r√©cup√©ration de core home :', error);
            showStatusMessage("Une erreur inattendue est survenue. Veuillez r√©essayer.", 'error');
        }
    }

    attachNavigationEvents();
    console.log('Fin de initializeHomeView');
}


===== ./main.js =====
// main.js

// Import des modules transverses
import { handleNavbar } from './navbar/index.js';
import { loadPongAnimation } from './modules/groundAnimation.js';
import { adjustBurgerHeight } from './modules/animations.js';
import { adjustSinNavHeight } from './modules/animations.js';
import { adjustContainerIfExists } from './modules/animations.js';
import { adjustAllContainers } from './modules/animations.js';
import { initializeRouter } from './router.js'; // Nouveau routeur Navigo

document.addEventListener('DOMContentLoaded', async () => {
    // Charger la navbar
    console.log('DOMContentLoaded');
    await handleNavbar();

    // Initialiser le routeur Navigo
    initializeRouter();

    // Charger les animations et ajustements au d√©marrage
    loadPongAnimation();
    adjustAllContainers(); // Pour resize
    adjustBurgerHeight(); // Pour load
    adjustSinNavHeight(); // Pour load
    adjustContainerIfExists('login'); // Pour load
    adjustContainerIfExists('register'); // Pour load
	adjustContainerIfExists('bracket_tournament'); // Pour load
});
===== ./modules/animations.js =====
// Ajuster la hauteur du menu burger avec marges
export function adjustBurgerHeight() {
    const navAndMarginHeight = 66; // Hauteur navbar et marge pour le menu burger
    const availableHeight = window.innerHeight - navAndMarginHeight;
    document.documentElement.style.setProperty('--burger-height', `${availableHeight}px`);
}

// Ajuster la hauteur sans la barre navigation
export function adjustSinNavHeight() {
    const navAndMarginHeight = 50; // Hauteur sans la navbar
    const availableHeight = window.innerHeight - navAndMarginHeight;
    document.documentElement.style.setProperty('--sin-nav-height', `${availableHeight}px`);
}


//Fonction responsive
function adjustContainer(ContainerId) {
  console.log("Rentre dans adjust container");
	const container = document.getElementById(ContainerId);
	if (!container) {
    console.log("adjustContainer: container error");
    return;
  } 
	const threshold = 50; // Seuil de hauteur pour activer le centrage
	// Si le contenu d√©passe la hauteur de l'√©cran, on enl√®ve `center-content`
	if (container.scrollHeight > window.innerHeight - threshold) {
		container.classList.remove('center-content');
		container.classList.add('normal-content');
	} else {
    container.classList.add('center-content');
		container.classList.remove('normal-content');
	}
}


/**
 * V√©rifie si un √©l√©ment avec l'ID sp√©cifi√© existe dans le DOM
 * et appelle adjustContainer si l'√©l√©ment est pr√©sent.
 * @param {string} containerId - L'ID de l'√©l√©ment √† ajuster.
 */
export function adjustContainerIfExists(containerId) {
    const container = document.getElementById(containerId);
    if (container) {
        adjustContainer(containerId);
    }
}


//[IMPROVE] Faire en sorte que adjustContainer login et register soit bind en event uniquement au chargement de leurs pages respectives pour √©viter de les appeler inutilement

export function adjustAllContainers() {

    window.addEventListener('resize', () => {
        adjustBurgerHeight();
        adjustSinNavHeight();
        adjustContainerIfExists('login');
        adjustContainerIfExists('register');
		adjustContainerIfExists('bracket_tournament');
    });
}

===== ./modules/groundAnimation.js =====
// Configuration et donn√©es des frames
const terrainConfig = {
	width: 80, // en pourcentage (vw)
	height: 40 // en pourcentage (vh)
  };
  
  const frames = [
	{ balleX: 1, balleY: 47, raquetteGaucheY: 36.5, raquetteDroiteY: 36.5 },
	{ balleX: 48, balleY: 0, raquetteGaucheY: 0, raquetteDroiteY: 73 },
	{ balleX: 97, balleY: 47, raquetteGaucheY: 47, raquetteDroiteY: 26 },
	{ balleX: 41, balleY: 95, raquetteGaucheY: 7, raquetteDroiteY: 69 },
	{ balleX: 1, balleY: 60, raquetteGaucheY: 60, raquetteDroiteY: 10 },
	{ balleX: 53, balleY: 0, raquetteGaucheY: 7, raquetteDroiteY: 65 },
	{ balleX: 97, balleY: 37, raquetteGaucheY: 67, raquetteDroiteY: 32 },
	{ balleX: 48, balleY: 95, raquetteGaucheY: 7, raquetteDroiteY: 73 }
  ];
  
  const transitionTime = 2200; // Temps de transition en ms
  let currentFrame = 0;
  let animationRunning = true;
  
  // S√©lection des √©l√©ments
  const balle = document.querySelector('.balle');
  const traitGauche = document.querySelector('.trait-gauche');
  const traitDroit = document.querySelector('.trait-droit');
  
  /**
   * Initialise les positions des √©l√©ments (balle, raquettes) √† partir de la premi√®re frame.
   */
  function initPositions() {
	setPositions(frames[0]);
  }
  
  /**
   * Met √† jour les positions des √©l√©ments en fonction de la frame donn√©e.
   * @param {Object} frame - Frame contenant les positions de la balle et des raquettes.
   */
  function setPositions(frame) {
	balle.style.left = frame.balleX + '%';
	balle.style.top = frame.balleY + '%';
	traitGauche.style.top = frame.raquetteGaucheY + '%';
	traitDroit.style.top = frame.raquetteDroiteY + '%';
  }
  
  /**
   * D√©place la balle et les raquettes avec interpolation entre les frames.
   */
  function deplacerBalleEtRaquettes() {
	if (!animationRunning) return;
  
	const frameActuelle = frames[currentFrame];
	const prochaineFrame = frames[(currentFrame + 1) % frames.length];
	let startTime = null;
  
	function animate(time) {
	  if (!animationRunning) return;
  
	  if (!startTime) startTime = time;
	  const progress = (time - startTime) / transitionTime;
  
	  if (progress < 1) {
		updatePositions(frameActuelle, prochaineFrame, progress);
		requestAnimationFrame(animate);
	  } else {
		currentFrame = (currentFrame + 1) % frames.length;
		requestAnimationFrame(deplacerBalleEtRaquettes);
	  }
	}
  
	requestAnimationFrame(animate);
  }
  
  /**
   * Met √† jour les positions interpol√©es de la balle et des raquettes.
   * @param {Object} frameActuelle - Frame actuelle.
   * @param {Object} prochaineFrame - Frame suivante.
   * @param {number} progress - Progression de l'interpolation (de 0 √† 1).
   */
  function updatePositions(frameActuelle, prochaineFrame, progress) {
	balle.style.left = interpolate(frameActuelle.balleX, prochaineFrame.balleX, progress) + '%';
	balle.style.top = interpolate(frameActuelle.balleY, prochaineFrame.balleY, progress) + '%';
	traitGauche.style.top = interpolate(frameActuelle.raquetteGaucheY, prochaineFrame.raquetteGaucheY, progress) + '%';
	traitDroit.style.top = interpolate(frameActuelle.raquetteDroiteY, prochaineFrame.raquetteDroiteY, progress) + '%';
  }
  
  /**
   * Fonction d'interpolation lin√©aire.
   * @param {number} start - Valeur de d√©part.
   * @param {number} end - Valeur d'arriv√©e.
   * @param {number} progress - Progression entre 0 et 1.
   * @returns {number} - Valeur interpol√©e.
   */
  function interpolate(start, end, progress) {
	return start + (end - start) * progress;
  }
  
/**
 * Arr√™te l'animation.
 */
export function stopPongAnimation() {
  animationRunning = false;
  }
  

export async function loadPongAnimation() {
    // Initialisation et lancement
    initPositions();
    deplacerBalleEtRaquettes();
  }

===== ./navbar/index.js =====
// navbar/index.js
export { handleNavbar } from './loadNavbar.js';
export { toggleBurgerMenu } from './toggleBurgerMenu.js';

===== ./navbar/delegation.js =====
// burgerMenu/delegation.js

/**
 * Initialise la d√©l√©gation d'√©v√©nements pour g√©rer la fermeture du burger menu.
 */
export function initBurgerMenuDelegation() {
    // Gestion du clic ext√©rieur pour fermer le menu
    document.addEventListener('click', (event) => {
        const menu = document.getElementById('burger-menu');
        const burgerToggle = document.getElementById('burger-menu-toggle');
        const overlay = document.getElementById('overlay');
        if (!menu || !burgerToggle || !overlay) return;

        // Si le menu est affich√© et que le clic se fait en dehors du menu et du toggle...
        if (
            menu.style.display === 'block' &&
            !menu.contains(event.target) &&
            !burgerToggle.contains(event.target)
        ) {
            menu.style.display = 'none';
            overlay.style.display = 'none';
        }
    });

    // Gestion d√©l√©gu√©e pour les boutons qui ferment le burger menu
    document.addEventListener('click', (event) => {
        if (event.target.matches('#profile-btn, #play-btn, #settings-link, #view-profile-btn')) {
            const menu = document.getElementById('burger-menu');
            const overlay = document.getElementById('overlay');
            if (menu && overlay) {
                menu.style.display = 'none';
                overlay.style.display = 'none';
            }
        }
    });
}

===== ./navbar/loadNavbar.js =====
// loadnavbar.js

import { toggleBurgerMenu } from './toggleBurgerMenu.js';
import { requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { initBurgerMenuDelegation } from './delegation.js'; // Notre module de d√©l√©gation
import { eventsHandlerBurgerMenu } from '../burgerMenu/index.js';
import { navigateTo } from '../router.js'; // Pour naviguer

/**
 * Initialise le burger menu : attache l'√©v√©nement sur le bouton de toggle.
 */
async function initializeBurgerMenu(flag) {
    const burgerToggle = document.querySelector('#burger-menu-toggle');
    if (burgerToggle && !burgerToggle.dataset.bound) {
        burgerToggle.addEventListener('click', () => toggleBurgerMenu(flag));
        burgerToggle.dataset.bound = true; // Marque comme attach√©
        console.log('√âv√©nements du burger menu initialis√©s.');
    }
}

function handleHomeButtonClick(isAuthenticated) {
    if (isAuthenticated) {
        // Redirige vers la page de jeu
        navigateTo('/home');
    } else {
        // Redirige vers la page de connexion
        navigateTo('/');
    }
}

/**
 * Charge et affiche la navbar, puis initialise le burger menu.
 */
async function loadNavbar() {
    console.log('D√©but de loadNavbar');
    try {
        // R√©cup√®re les donn√©es de la navbar
        const data = await requestGet('core', 'navbar');

        if (data && data.html) {
            // Met √† jour le contenu HTML de la navbar
            updateHtmlContent('#navbar', data.html);
            console.log('Contenu de la navbar mis √† jour.');

            // Attache l'√©v√©nement au bouton "home"
            const homeButton = document.querySelector('#home-btn');
            if (homeButton && !homeButton.dataset.bound) {
                homeButton.addEventListener('click', () => handleHomeButtonClick(data.is_authenticated));
                homeButton.dataset.bound = true;
            }

            return data.is_authenticated;
        } else {
            console.error('Les donn√©es HTML de la navbar sont manquantes.');
            showStatusMessage('Impossible de charger la barre de navigation.', 'error');
            return false;
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la navbar:', error);
        showStatusMessage('Une erreur est survenue lors du chargement de la barre de navigation.', 'error');
        throw error;
    } finally {
        console.log('Fin de loadNavbar');
    }
}

/**
 * Rafra√Æchit le contenu du burger menu.
 */
export async function refreshBurgerMenu() {
    try {
        let menu = document.getElementById('burger-menu');
        let overlay = document.getElementById('overlay');

        if (!menu || !overlay) return;

        const data = await requestGet('accounts', 'burgerMenu');
        if (data.status === 'success') {
            // Mise √† jour du contenu du burger menu selon son √©tat d'affichage
            if (menu.style.display === 'block') {
                updateHtmlContent('#burger-menu-container', data.html);
                menu = document.getElementById('burger-menu');
                overlay = document.getElementById('overlay');
                menu.style.display = 'block';
                overlay.style.display = 'block';
            } else {
                updateHtmlContent('#burger-menu-container', data.html);
                menu = document.getElementById('burger-menu');
                overlay = document.getElementById('overlay');
                menu.style.display = 'none';
                overlay.style.display = 'none';
            }
            // R√©initialise le burger menu (pour le bouton de toggle, etc.)
            initializeBurgerMenu('refresh btn');
            eventsHandlerBurgerMenu();

            console.log('Burger menu mis √† jour avec succ√®s.');
        } else {
            console.warn('Burger menu non mis √† jour, statut:', data.status);
        }
    } catch (error) {
        console.error('Erreur lors du rafra√Æchissement du burger menu:', error);
    }
}

/**
 * G√®re le chargement de la navbar et du burger menu.
 */
export async function handleNavbar() {
    console.log('Chargement de la navbar...');
    try {
        const is_authenticated = await loadNavbar();

        if (is_authenticated) {
            await initializeBurgerMenu(null);
            // Initialise la d√©l√©gation d'√©v√©nements pour le burger menu
            initBurgerMenuDelegation();
            eventsHandlerBurgerMenu();
            console.log('Navbar et burger menu charg√©s avec succ√®s.');
            // Rafra√Æchissement p√©riodique si l'utilisateur est authentifi√©
            setInterval(refreshBurgerMenu, 10000);
        } else {
            console.log('Utilisateur non authentifi√© ou erreur de chargement.');
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la navbar dans handleNavbar:', error);
        showStatusMessage('Erreur lors du chargement de la barre de navigation. Veuillez r√©essayer.', 'error');
    }
}

===== ./navbar/toggleBurgerMenu.js =====
// toggleBurgerMenu.js

/**
 * Affiche ou masque le burger menu.
 *
 * @param {string} flag - Un flag √©ventuel pour certains cas particuliers (ex: "refresh btn").
 */
export function toggleBurgerMenu(flag) {
    console.log('toggleBurgerMenu');
    const menu = document.getElementById('burger-menu');
    const overlay = document.getElementById('overlay');
    if (flag === 'refresh btn') return;
    if (!menu || !overlay) return;

    if (menu.style.display === 'block') {
        closeBurgerMenu(menu, overlay);
    } else {
        openBurgerMenu(menu, overlay);
    }
}

function openBurgerMenu(menu, overlay) {
    menu.style.display = 'block';
    overlay.style.display = 'block';
}

function closeBurgerMenu(menu, overlay) {
    menu.style.display = 'none';
    overlay.style.display = 'none';
}

===== ./tools/displayInfo.js =====
/**
 * Affiche un message de succ√®s dans un √©l√©ment sp√©cifi√©.
 * @param {string} elementId - L'ID de l'√©l√©ment o√π afficher le message.
 * @param {string} message - Le message de succ√®s √† afficher.
 */
export function displaySuccessMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'green';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Affiche un message d'erreur dans un √©l√©ment sp√©cifi√©.
 * @param {string} elementId - L'ID de l'√©l√©ment o√π afficher le message.
 * @param {string} message - Le message d'erreur √† afficher.
 */
export function displayErrorMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'red';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Affiche un message d'information dans un √©l√©ment sp√©cifi√©.
 * @param {string} elementId - L'ID de l'√©l√©ment o√π afficher le message.
 * @param {string} message - Le message d'information √† afficher.
 */
export function displayInfoMessage(elementId, message) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.style.color = 'blue';
        element.style.display = 'block';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

/**
 * Efface les messages affich√©s dans un √©l√©ment sp√©cifi√©.
 * @param {string} elementId - L'ID de l'√©l√©ment dont le contenu doit √™tre effac√©.
 */
export function clearMessage(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = '';
        element.style.display = 'none';
    } else {
        console.warn(`Element with ID '${elementId}' not found.`);
    }
}

export function showStatusMessage (message, status) {
    const popup = document.getElementById('popup');
    const info = document.getElementById('info');

    // D√©finir le message
    info.textContent = message;

    // Supprimer les anciennes classes
    popup.classList.remove('success', 'error', 'd-none', 'hide');

    // Ajouter la classe appropri√©e
    if (status === 'success') {
        popup.classList.add('success');
    } else if (status === 'error') {
        popup.classList.add('error');
    }

    // Afficher le popup
    popup.classList.add('show');

    // Cacher automatiquement apr√®s 3 secondes
    setTimeout(() => {
        popup.classList.remove('show');
        popup.classList.add('hide');
        setTimeout(() => popup.classList.add('d-none'), 500);
    }, 3000);
}
===== ./tools/domHandler.js =====
// Utilitaire pour mettre √† jour le contenu texte d'un √©l√©ment HTML
/**
 * Met √† jour le texte affich√© d'un √©l√©ment HTML s√©lectionn√©.
 *
 * @param {string} selector - S√©lecteur CSS pour cibler l'√©l√©ment HTML.
 * @param {string} text - Contenu texte √† ins√©rer dans l'√©l√©ment.
 *
 * Cette fonction utilise `querySelector` pour s√©lectionner **le premier √©l√©ment**
 * correspondant au s√©lecteur fourni.
 * 
 * - Si le s√©lecteur est une **classe combin√©e** comme `.profile-info h3`, la fonction
 *   va chercher **le premier `<h3>`** trouv√© √† l'int√©rieur de l'√©l√©ment ayant la classe `profile-info`.
 * - Si l'√©l√©ment a un **`id` unique** (ex. : `id="profile-username"`), vous pouvez le cibler directement
 *   avec le s√©lecteur `#profile-username`, ce qui est plus pr√©cis et performant.
 *
 * Si l'√©l√©ment correspondant n'est pas trouv√© dans le DOM, la fonction ne fait rien
 * et ne l√®ve aucune erreur.
 *
 * Exemple d'utilisation avec une classe combin√©e :
 * updateTextContent('.profile-info h3', 'Pseudo : JohnDoe');
 *
 * Exemple d'utilisation avec un `id` :
 * updateTextContent('#profile-username', 'Pseudo : JohnDoe');
 *
 * R√©sultat attendu dans le DOM :
 * Avant : <h3 class="profile-info">Pseudo :</h3>
 * Apr√®s : <h3 class="profile-info">Pseudo : JohnDoe</h3>
 */
export function updateTextContent(selector, text) {
    const element = document.querySelector(selector); // S√©lectionne le premier √©l√©ment correspondant au s√©lecteur
    if (element) {
        element.textContent = text; // Modifie le contenu texte de l'√©l√©ment
    }
}

// Utilitaire pour mettre √† jour un attribut d'un √©l√©ment HTML
/**
 * Met √† jour un attribut sp√©cifique d'un √©l√©ment HTML s√©lectionn√©.
 *
 * @param {string} selector - S√©lecteur CSS pour cibler l'√©l√©ment HTML.
 * @param {string} attribute - Nom de l'attribut √† mettre √† jour (par ex. : `src`, `alt`, `href`).
 * @param {string} value - Nouvelle valeur √† attribuer √† l'attribut.
 *
 * Cette fonction utilise `querySelector` pour s√©lectionner **le premier √©l√©ment**
 * correspondant au s√©lecteur fourni.
 * 
 * - Si le s√©lecteur est une **classe combin√©e** comme `.profile-info img`, la fonction
 *   va chercher **la premi√®re balise `<img>`** trouv√©e √† l'int√©rieur de l'√©l√©ment ayant la classe `profile-info`.
 * - Si l'√©l√©ment poss√®de un **`id` unique**, il est recommand√© d'utiliser ce `id` directement
 *   dans le s√©lecteur (ex. : `#profile-avatar`) pour une s√©lection plus rapide et pr√©cise.
 *
 * Si l'√©l√©ment correspondant n'est pas trouv√© dans le DOM, la fonction ne fait rien
 * et ne l√®ve aucune erreur.
 *
 * Exemple d'utilisation avec une classe combin√©e :
 * updateAttribute('.profile-info img', 'src', '/path/to/image.jpg');
 *
 * Exemple d'utilisation avec un `id` :
 * updateAttribute('#profile-avatar', 'src', '/path/to/image.jpg');
 *
 * R√©sultat attendu dans le DOM :
 * Avant : <img class="profile-info" src="" alt="">
 * Apr√®s : <img class="profile-info" src="/path/to/image.jpg" alt="">
 */
export function updateAttribute(selector, attribute, value) {
    const element = document.querySelector(selector);
    console.log(`S√©lecteur : ${selector}, √âl√©ment trouv√© :`, element);
    if (element) {
        element.setAttribute(attribute, value);
        console.log(`Attribut ${attribute} mis √† jour avec la valeur : ${value}`);
    } else {
        console.error(`√âl√©ment non trouv√© pour le s√©lecteur : ${selector}`);
    }
}

//Ajout et modification dynamique du html dans les divs
// Selector = #content ou #navbar 
//  [IMPROVE] A voir aussi ou inclure le bruger menu 
export function updateHtmlContent(selector, html) {
    console.log(`rentre dans updateHtmlContent selector =`, selector);
    if (!html)
            console.log('html est vide');
    try {
        // Mise √† jour du contenu √† partir des donn√©es re√ßues
        document.querySelector(selector).innerHTML = html;
    } catch {
        //[IMPROVE] faire un autre throw ici pour gerer l' erreur dans les fonctions specialisees
        document.querySelector(selector).innerHTML = '<p>Une erreur est survenue lors du chargement du contenu.</p>';
    }
}


===== ./tools/clearSession.js =====
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer


/**
 * Supprime les tokens, nettoie l'interface utilisateur et redirige vers une URL donn√©e.
 * @param {string} redirectUrl - L'URL vers laquelle rediriger apr√®s le nettoyage. (Par d√©faut : '#core-home')
 */
export function clearSessionAndUI(redirectUrl = '/') {
    console.log('Nettoyage de la session et de l\'interface utilisateur...');

    // Suppression des tokens
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');

    // Nettoyage de l'interface utilisateur
    const navbar = document.querySelector('#navbar');
    const burgerMenu = document.querySelector('#burger-menu');
    const content = document.querySelector('#content');

    if (navbar) navbar.innerHTML = '';
    if (burgerMenu) burgerMenu.innerHTML = '';
    if (content) content.innerHTML = '';

    // Redirection
    navigateTo(redirectUrl);
    location.reload();
    

    console.log(`Redirection vers ${redirectUrl}`);
}

===== ./tools/errorPage.js =====
import { requestGet } from "../api/index.js";
import { updateHtmlContent } from "./domHandler.js";

export async function initializeNotFoundView()
{
    const response = await requestGet('core', '404');
    if (response.status === 'success')
        updateHtmlContent('#content', response.html)
}

===== ./tools/index.js =====

// Fonctions g√©n√©riques pour l'affichages d'informations
export { displayErrorMessage, displaySuccessMessage, clearMessage, displayInfoMessage, showStatusMessage } from './displayInfo.js';

export { updateTextContent, updateAttribute , updateHtmlContent} from './domHandler.js';
export { isTouchDevice, resetScrollPosition } from './utility.js';

// Fonction g√©n√©rique, supprime les tokens et remet √† z√©ro l'interface utilisateur
export {clearSessionAndUI} from './clearSession.js';

export {initializeNotFoundView} from './errorPage.js';

===== ./tools/utility.js =====
//utility.js
//fonctions que l' on ne sait pas encore ou mettre mais qui sont en rapport avec le jeu sur tel(loading screen)


export function isTouchDevice() {
  return Boolean(
    ('ontouchstart' in window) || 
    (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || 
    (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0)
  );
}
  

export function resetScrollPosition() {
    // document.scrollingElement est support√© par la majorit√© des navigateurs modernes.
    console.log("resetScrollPosition");
    const scrollingElement = document.scrollingElement || document.documentElement;
    scrollingElement.scrollTop = 0;
  }
===== ./userProfile/index.js =====
// Affiche le profil utilisateur et active le bouton gestion de profil.
export { handleViewProfile } from './userProfile.js';	
===== ./userProfile/userProfile.js =====
import { requestGet } from '../api/index.js';
import { updateHtmlContent, showStatusMessage } from '../tools/index.js';
import { navigateTo } from '../router.js'; // Importer la fonction pour naviguer

// Fonction principale qui r√©cup√®re et affiche le profil utilisateur
async function viewUserProfile() {
    try {
        const response = await requestGet('accounts', 'userProfile');

        // Si la r√©ponse est undefined, cela signifie que la redirection a d√©j√† √©t√© d√©clench√©e
        if (!response) {
            return false;
        }

        if (response.status === 'success' && response.html) {
            console.log('Profil utilisateur charg√© avec succ√®s.');
            updateHtmlContent('#content', response.html);
        } else {
            const message = response.message || 'Erreur lors du chargement du profil utilisateur.';
            console.error('Erreur :', message);
            showStatusMessage(message, 'error');
            throw new Error(message);
        }
        return true;
    } catch (error) {
        console.error('Erreur r√©seau ou r√©ponse lors du chargement du profil utilisateur:', error);
        showStatusMessage('Une erreur est survenue lors du chargement du profil utilisateur.', 'error');
        throw error; // Propagation de l'erreur pour gestion dans handleViewProfile
    }
}

// Fonction pour g√©rer les √©v√©nements sp√©cifiques au profil
async function initializeProfileEvents() {
    try {
        const gestionBtn = document.querySelector('#gestion-btn');
        if (!gestionBtn) {
            const message = 'Bouton de gestion de profil introuvable.';
            console.error(message);
            showStatusMessage(message, 'error');
            throw new Error(message);
        }

        gestionBtn.addEventListener('click', () => {
            console.log('Clic sur Gestion de Profil');
            navigateTo('/account'); 
        });

        console.log('√âv√©nements de profil initialis√©s.');
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des √©v√©nements de profil:', error);
        showStatusMessage('Une erreur est survenue lors de l\'initialisation des √©v√©nements du profil.', 'error');
        throw error; // Relance l'erreur pour qu'elle soit g√©r√©e par handleViewProfile
    }
}

// Fonction pour g√©rer l'affichage du profil utilisateur
export async function handleViewProfile() {
    console.log('Chargement du profil utilisateur...');

    let profileLoaded;
    try {
        profileLoaded = await viewUserProfile(); // Appel de la fonction principale pour charger le profil
    } catch (error) {
        console.error('Erreur lors du chargement du profil utilisateur dans viewUserProfile:', error);
        showStatusMessage('Erreur lors du chargement du profil utilisateur.', 'error');
        return; // Arr√™te l'ex√©cution si le chargement √©choue
    }

    // Si le profil n'a pas √©t√© charg√© (par exemple, √† cause d'une redirection), on arr√™te ici.
    if (!profileLoaded) {
        return;
    }

    try {
        await initializeProfileEvents(); // Initialisation des √©v√©nements sp√©cifiques au profil
    } catch (error) {
        console.error('Erreur lors de l\'initialisation des √©v√©nements dans initializeProfileEvents:', error);
        showStatusMessage('Erreur lors de l\'initialisation des √©v√©nements du profil.', 'error');
    }
}


===== ./router.js =====
import { initializeHomeView } from './landing/coreHome.js';
import { handleLogin, initializeRegisterView, initializeLogin2FAView, handleDisable2FA, handleEnable2FA } from './auth/index.js';
import { handleInviteGame, initializeGameHomeView } from './game/index.js';
import { handleAccountsManagement } from './accountManagement/index.js';
import { handleViewProfile } from './userProfile/index.js';
import {handleGameMenu} from './game/index.js';
import { handleFriendProfile } from './friends/index.js';
import { handleNavbar } from './navbar/loadNavbar.js';
import { initializeNotFoundView } from './tools/errorPage.js';
import { handleTournament } from './game/tournament.js'
import { createGameOnline } from './game/index.js';
// Initialisation du routeur Navigo
const router = new window.Navigo('/', { hash: false });


/**
 * Initialisation des routes Navigo.
 */
export function initializeRouter() {
    router
        .on('/', () => {
            console.log('Route: Home');
            handleNavbar();
            initializeHomeView();
        })
        .on('/login', () => {
            console.log('Route: Login');
            handleLogin();
        })
        .on('/login-2fa', () => {
            console.log('Route: Login');
            initializeLogin2FAView();
        })
        .on('/register', () => {
            console.log('Route: Register');
            initializeRegisterView();
        })
        .on('/enable-2fa', () => {
            console.log('Route: 2FA Login');
            handleEnable2FA();
        })
        .on('/disable-2fa', () => {
            console.log('Route: 2FA Login');
            handleDisable2FA();
        })
        .on('/home', () => {
            console.log('Route: Game Home');
            initializeGameHomeView();
        })
        .on('/account', () => {
            console.log('Route: account');
            handleAccountsManagement();
        })
        .on('/profile', () => {
            console.log('Route: profile');
            handleViewProfile();
        })
        .on('/game-options', () => {
            console.log('Route: game-options');
            handleGameMenu();
        })
        .on('/online', () => {
            console.log('Route: online');
            createGameOnline();
        })
        .on('/tournament', () => {
            console.log('Route: tournament');
            handleTournament();
        })
        //improve : ne faut il pas changer le nom en game-option ?
        .on('/game-loading', () => {
            console.log('Route: game-loading');
            startLoading();
        })
        .on('/profile/:friendUsername', ({ data }) => {
            const friendUsername = data.friendUsername; // Utilisez `data` pour extraire le param√®tre
            console.log(`Route: Profile for ${friendUsername}`);
            handleFriendProfile(friendUsername);
        })
        .notFound(() => {
            console.error('Route inconnue : Page non trouv√©e');
            initializeNotFoundView(); // Charge la vue 404 sans recharger landing.html

        });

    // R√©solution de la route actuelle
    router.resolve();
}

/**
 * Navigation dynamique.
 * @param {string} route - La route cible.
 */
export function navigateTo(route) {
    console.log(`Navigation vers ${route}`);
    router.navigate(route);
}

